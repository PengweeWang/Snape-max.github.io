"use strict";(self["webpackChunkastar"]=self["webpackChunkastar"]||[]).push([[174],{4322:function(n,e,t){t.d(e,{I:function(){return U},v:function(){return z}});var r=t(897),o=t(413),i=(t(4114),t(6015));function s(n,e,t){if(n)for(const r in n){const o=r.toLocaleLowerCase(),s=e[o];if(s){let e=n[r];"header"===r&&(e=e.replace(/@in\s+[^;]+;\s*/g,"").replace(/@out\s+[^;]+;\s*/g,"")),t&&s.push(`//----${t}----//`),s.push(e)}else(0,i.R)(`${r} placement hook does not exist in shader`)}}const u=/\{\{(.*?)\}\}/g;function a(n){const e={},t=n.match(u)?.map((n=>n.replace(/[{()}]/g,"")))??[];return t.forEach((n=>{e[n]=[]})),e}function c(n,e){let t;const r=/@in\s+([^;]+);/g;while(null!==(t=r.exec(n)))e.push(t[1])}function l(n,e,t=!1){const r=[];c(e,r),n.forEach((n=>{n.header&&c(n.header,r)}));const o=r;t&&o.sort();const i=o.map(((n,e)=>`       @location(${e}) ${n},`)).join("\n");let s=e.replace(/@in\s+[^;]+;\s*/g,"");return s=s.replace("{{in}}",`\n${i}\n`),s}function d(n,e){let t;const r=/@out\s+([^;]+);/g;while(null!==(t=r.exec(n)))e.push(t[1])}function f(n){const e=/\b(\w+)\s*:/g,t=e.exec(n);return t?t[1]:""}function m(n){const e=/@.*?\s+/g;return n.replace(e,"")}function h(n,e){const t=[];d(e,t),n.forEach((n=>{n.header&&d(n.header,t)}));let r=0;const o=t.sort().map((n=>n.indexOf("builtin")>-1?n:`@location(${r++}) ${n}`)).join(",\n"),i=t.sort().map((n=>`       var ${m(n)};`)).join("\n"),s=`return VSOutput(\n                ${t.sort().map((n=>` ${f(n)}`)).join(",\n")});`;let u=e.replace(/@out\s+[^;]+;\s*/g,"");return u=u.replace("{{struct}}",`\n${o}\n`),u=u.replace("{{start}}",`\n${i}\n`),u=u.replace("{{return}}",`\n${s}\n`),u}function p(n,e){let t=n;for(const r in e){const n=e[r],o=n.join("\n");t=o.length?t.replace(`{{${r}}}`,`//-----${r} START-----//\n${n.join("\n")}\n//----${r} FINISH----//`):t.replace(`{{${r}}}`,"")}return t}const g=Object.create(null),x=new Map;let v=0;function b({template:n,bits:e}){const t=_(n,e);if(g[t])return g[t];const{vertex:r,fragment:o}=P(n,e);return g[t]=w(r,o,e),g[t]}function y({template:n,bits:e}){const t=_(n,e);return g[t]||(g[t]=w(n.vertex,n.fragment,e)),g[t]}function P(n,e){const t=e.map((n=>n.vertex)).filter((n=>!!n)),r=e.map((n=>n.fragment)).filter((n=>!!n));let o=l(t,n.vertex,!0);o=h(t,o);const i=l(r,n.fragment,!0);return{vertex:o,fragment:i}}function _(n,e){return e.map((n=>(x.has(n)||x.set(n,v++),x.get(n)))).sort(((n,e)=>n-e)).join("-")+n.vertex+n.fragment}function w(n,e,t){const r=a(n),o=a(e);return t.forEach((n=>{s(n.vertex,r,n.name),s(n.fragment,o,n.name)})),{vertex:p(n,r),fragment:p(e,o)}}const M="\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n        \n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n       \n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n",T="\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n   \n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n        \n        {{start}}\n\n        var outColor:vec4<f32>;\n      \n        {{main}}\n        \n        return outColor * vColor;\n      };\n",$="\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n        \n        {{start}}\n        \n        vColor = vec4(1.);\n        \n        {{main}}\n        \n        vUV = uv;\n        \n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n",C="\n   \n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n        \n        {{start}}\n\n        vec4 outColor;\n      \n        {{main}}\n        \n        finalColor = outColor * vColor;\n    }\n",A={name:"global-uniforms-bit",vertex:{header:"\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        "}},S={name:"global-uniforms-bit",vertex:{header:"\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        "}};function z({bits:n,name:e}){const t=b({template:{fragment:T,vertex:M},bits:[A,...n]});return o.B.from({name:e,vertex:{source:t.vertex,entryPoint:"main"},fragment:{source:t.fragment,entryPoint:"main"}})}function U({bits:n,name:e}){return new r.M({name:e,...y({template:{vertex:$,fragment:C},bits:[S,...n]})})}},7011:function(n,e,t){t.d(e,{F:function(){return r},a:function(){return o}});const r={name:"color-bit",vertex:{header:"\n            @in aColor: vec4<f32>;\n        ",main:"\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        "}},o={name:"color-bit",vertex:{header:"\n            in vec4 aColor;\n        ",main:"\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        "}}},145:function(n,e,t){t.d(e,{P:function(){return c},_:function(){return s}});t(4114);const r={};function o(n){const e=[];if(1===n)e.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"),e.push("@group(1) @binding(1) var textureSampler1: sampler;");else{let t=0;for(let r=0;r<n;r++)e.push(`@group(1) @binding(${t++}) var textureSource${r+1}: texture_2d<f32>;`),e.push(`@group(1) @binding(${t++}) var textureSampler${r+1}: sampler;`)}return e.join("\n")}function i(n){const e=[];if(1===n)e.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");else{e.push("switch vTextureId {");for(let t=0;t<n;t++)t===n-1?e.push("  default:{"):e.push(`  case ${t}:{`),e.push(`      outColor = textureSampleGrad(textureSource${t+1}, textureSampler${t+1}, vUV, uvDx, uvDy);`),e.push("      break;}");e.push("}")}return e.join("\n")}function s(n){return r[n]||(r[n]={name:"texture-batch-bit",vertex:{header:"\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            ",main:"\n                vTextureId = aTextureIdAndRound.y;\n            ",end:"\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            "},fragment:{header:`\n                @in @interpolate(flat) vTextureId: u32;\n    \n                ${o(16)}\n            `,main:`\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n    \n                ${i(16)}\n            `}}),r[n]}const u={};function a(n){const e=[];for(let t=0;t<n;t++)t>0&&e.push("else"),t<n-1&&e.push(`if(vTextureId < ${t}.5)`),e.push("{"),e.push(`\toutColor = texture(uTextures[${t}], vUV);`),e.push("}");return e.join("\n")}function c(n){return u[n]||(u[n]={name:"texture-batch-bit",vertex:{header:"\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n              \n            ",main:"\n                vTextureId = aTextureIdAndRound.y;\n            ",end:"\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            "},fragment:{header:`\n                in float vTextureId;\n    \n                uniform sampler2D uTextures[${n}];\n              \n            `,main:`\n    \n                ${a(16)}\n            `}}),u[n]}},5886:function(n,e,t){t.d(e,{Ls:function(){return r},_Q:function(){return o},mA:function(){return i}});const r={name:"local-uniform-bit",vertex:{header:"\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        ",main:"\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        ",end:"\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        "}},o={...r,vertex:{...r.vertex,header:r.vertex.header.replace("group(1)","group(2)")}},i={name:"local-uniform-bit",vertex:{header:"\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        ",main:"\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        ",end:"\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        "}}},7882:function(n,e,t){t.d(e,{b:function(){return r},m:function(){return o}});const r={name:"round-pixels-bit",vertex:{header:"\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> \n            {\n                return (floor((position * 0.5 + 0.5) * targetSize) / targetSize) * 2.0 - 1.0;\n            }\n        "}},o={name:"round-pixels-bit",vertex:{header:"   \n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {       \n                return (floor((position * 0.5 + 0.5) * targetSize) / targetSize) * 2.0 - 1.0;\n            }\n        "}}},897:function(n,e,t){t.d(e,{M:function(){return b}});var r=t(3929),o=t(1655);let i,s;function u(){if(!i||i?.isContextLost()){const n=o.e.get().createCanvas();i=n.getContext("webgl",{})}return i}function a(){if(!s){s="mediump";const n=u();if(n&&n.getShaderPrecisionFormat){const e=n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT);s=e.precision?"highp":"mediump"}}return s}function c(n,e,t){return e?n:t?(n=n.replace("out vec4 finalColor;",""),`\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in varying\n        #define finalColor gl_FragColor\n        #define texture texture2D\n        #endif\n        ${n}\n        `):`\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in attribute\n        #define out varying\n        #endif\n        ${n}\n        `}function l(n,e,t){const r=t?e.maxSupportedFragmentPrecision:e.maxSupportedVertexPrecision;if("precision"!==n.substring(0,9)){let o=t?e.requestedFragmentPrecision:e.requestedVertexPrecision;return"highp"===o&&"highp"!==r&&(o="mediump"),`precision ${o} float;\n${n}`}return"highp"!==r&&"precision highp"===n.substring(0,15)?n.replace("precision highp","precision mediump"):n}function d(n,e){return e?`#version 300 es\n${n}`:n}const f={},m={};function h(n,{name:e="pixi-program"},t=!0){e=e.replace(/\s+/g,"-"),e+=t?"-fragment":"-vertex";const r=t?f:m;if(r[e]?(r[e]++,e+=`-${r[e]}`):r[e]=1,-1!==n.indexOf("#define SHADER_NAME"))return n;const o=`#define SHADER_NAME ${e}`;return`${o}\n${n}`}function p(n,e){return e?n.replace("#version 300 es",""):n}const g={stripVersion:p,ensurePrecision:l,addProgramDefines:c,setProgramName:h,insertVersion:d},x=Object.create(null),v=class n{constructor(e){e={...n.defaultOptions,...e};const t=-1!==e.fragment.indexOf("#version 300 es"),o={stripVersion:t,ensurePrecision:{requestedFragmentPrecision:e.preferredFragmentPrecision,requestedVertexPrecision:e.preferredVertexPrecision,maxSupportedVertexPrecision:"highp",maxSupportedFragmentPrecision:a()},setProgramName:{name:e.name},addProgramDefines:t,insertVersion:t};let i=e.fragment,s=e.vertex;Object.keys(g).forEach((n=>{const e=o[n];i=g[n](i,e,!0),s=g[n](s,e,!1)})),this.fragment=i,this.vertex=s,this._key=(0,r.X)(`${this.vertex}:${this.fragment}`,"gl-program")}destroy(){this.fragment=null,this.vertex=null,this._attributeData=null,this._uniformData=null,this._uniformBlockData=null,this.transformFeedbackVaryings=null}static from(e){const t=`${e.vertex}:${e.fragment}`;return x[t]||(x[t]=new n(e)),x[t]}};v.defaultOptions={preferredVertexPrecision:"highp",preferredFragmentPrecision:"mediump"};let b=v},413:function(n,e,t){t.d(e,{B:function(){return m}});var r=t(3929),o=t(9289);const i={f32:"float32","vec2<f32>":"float32x2","vec3<f32>":"float32x3","vec4<f32>":"float32x4",vec2f:"float32x2",vec3f:"float32x3",vec4f:"float32x4",i32:"sint32","vec2<i32>":"sint32x2","vec3<i32>":"sint32x3","vec4<i32>":"sint32x4",u32:"uint32","vec2<u32>":"uint32x2","vec3<u32>":"uint32x3","vec4<u32>":"uint32x4",bool:"uint32","vec2<bool>":"uint32x2","vec3<bool>":"uint32x3","vec4<bool>":"uint32x4"};function s({source:n,entryPoint:e}){const t={},r=n.indexOf(`fn ${e}`);if(-1!==r){const e=n.indexOf("->",r);if(-1!==e){const s=n.substring(r,e),u=/@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;let a;while(null!==(a=u.exec(s))){const n=i[a[3]]??"float32";t[a[2]]={location:parseInt(a[1],10),format:n,stride:(0,o.m)(n).stride,offset:0,instance:!1,start:0}}}}return t}function u(n){const e=/(^|[^/])@(group|binding)\(\d+\)[^;]+;/g,t=/@group\((\d+)\)/,r=/@binding\((\d+)\)/,o=/var(<[^>]+>)? (\w+)/,i=/:\s*(\w+)/,s=/struct\s+(\w+)\s*{([^}]+)}/g,u=/(\w+)\s*:\s*([\w\<\>]+)/g,a=/struct\s+(\w+)/,c=n.match(e)?.map((n=>({group:parseInt(n.match(t)[1],10),binding:parseInt(n.match(r)[1],10),name:n.match(o)[2],isUniform:"<uniform>"===n.match(o)[1],type:n.match(i)[1]})));if(!c)return{groups:[],structs:[]};const l=n.match(s)?.map((n=>{const e=n.match(a)[1],t=n.match(u).reduce(((n,e)=>{const[t,r]=e.split(":");return n[t.trim()]=r.trim(),n}),{});return t?{name:e,members:t}:null})).filter((({name:n})=>c.some((e=>e.type===n))))??[];return{groups:c,structs:l}}t(4114);var a=(n=>(n[n["VERTEX"]=1]="VERTEX",n[n["FRAGMENT"]=2]="FRAGMENT",n[n["COMPUTE"]=4]="COMPUTE",n))(a||{});function c({groups:n}){const e=[];for(let t=0;t<n.length;t++){const r=n[t];e[r.group]||(e[r.group]=[]),r.isUniform?e[r.group].push({binding:r.binding,visibility:a.VERTEX|a.FRAGMENT,buffer:{type:"uniform"}}):"sampler"===r.type?e[r.group].push({binding:r.binding,visibility:a.FRAGMENT,sampler:{type:"filtering"}}):"texture_2d"===r.type&&e[r.group].push({binding:r.binding,visibility:a.FRAGMENT,texture:{sampleType:"float",viewDimension:"2d",multisampled:!1}})}return e}function l({groups:n}){const e=[];for(let t=0;t<n.length;t++){const r=n[t];e[r.group]||(e[r.group]={}),e[r.group][r.name]=r.binding}return e}function d(n,e){const t=new Set,r=new Set,o=[...n.structs,...e.structs].filter((n=>!t.has(n.name)&&(t.add(n.name),!0))),i=[...n.groups,...e.groups].filter((n=>{const e=`${n.name}-${n.binding}`;return!r.has(e)&&(r.add(e),!0)}));return{structs:o,groups:i}}const f=Object.create(null);class m{constructor(n){this._layoutKey=0;const{fragment:e,vertex:t,layout:r,gpuLayout:o,name:i}=n;if(this.name=i,this.fragment=e,this.vertex=t,e.source===t.source){const n=u(e.source);this.structsAndGroups=n}else{const n=u(t.source),r=u(e.source);this.structsAndGroups=d(n,r)}this.layout=r??l(this.structsAndGroups),this.gpuLayout=o??c(this.structsAndGroups),this.autoAssignGlobalUniforms=!(void 0===this.layout[0]?.globalUniforms),this.autoAssignLocalUniforms=!(void 0===this.layout[1]?.localUniforms),this._generateProgramKey()}_generateProgramKey(){const{vertex:n,fragment:e}=this,t=n.source+e.source+n.entryPoint+e.entryPoint;this._layoutKey=(0,r.X)(t,"program")}get attributeData(){return this._attributeData??(this._attributeData=s(this.vertex)),this._attributeData}destroy(){this.gpuLayout=null,this.layout=null,this.structsAndGroups=null,this.fragment=null,this.vertex=null}static from(n){const e=`${n.vertex.source}:${n.fragment.source}:${n.fragment.entryPoint}:${n.vertex.entryPoint}`;return f[e]||(f[e]=new m(n)),f[e]}}},9289:function(n,e,t){t.d(e,{m:function(){return o}});const r={uint8x2:{size:2,stride:2,normalised:!1},uint8x4:{size:4,stride:4,normalised:!1},sint8x2:{size:2,stride:2,normalised:!1},sint8x4:{size:4,stride:4,normalised:!1},unorm8x2:{size:2,stride:2,normalised:!0},unorm8x4:{size:4,stride:4,normalised:!0},snorm8x2:{size:2,stride:2,normalised:!0},snorm8x4:{size:4,stride:4,normalised:!0},uint16x2:{size:2,stride:4,normalised:!1},uint16x4:{size:4,stride:8,normalised:!1},sint16x2:{size:2,stride:4,normalised:!1},sint16x4:{size:4,stride:8,normalised:!1},unorm16x2:{size:2,stride:4,normalised:!0},unorm16x4:{size:4,stride:8,normalised:!0},snorm16x2:{size:2,stride:4,normalised:!0},snorm16x4:{size:4,stride:8,normalised:!0},float16x2:{size:2,stride:4,normalised:!1},float16x4:{size:4,stride:8,normalised:!1},float32:{size:1,stride:4,normalised:!1},float32x2:{size:2,stride:8,normalised:!1},float32x3:{size:3,stride:12,normalised:!1},float32x4:{size:4,stride:16,normalised:!1},uint32:{size:1,stride:4,normalised:!1},uint32x2:{size:2,stride:8,normalised:!1},uint32x3:{size:3,stride:12,normalised:!1},uint32x4:{size:4,stride:16,normalised:!1},sint32:{size:1,stride:4,normalised:!1},sint32x2:{size:2,stride:8,normalised:!1},sint32x3:{size:3,stride:12,normalised:!1},sint32x4:{size:4,stride:16,normalised:!1}};function o(n){return r[n]??r.float32}},6076:function(n,e,t){t.d(e,{M:function(){return c}});t(4114);var r=t(8611),o=t(897),i=t(8486),s=t(413),u=t(3074),a=t(1852);class c extends r.A{constructor(n){super(),this._uniformBindMap=Object.create(null),this._ownedBindGroups=[];let{gpuProgram:e,glProgram:t,groups:r,resources:o,compatibleRenderers:s,groupMap:c}=n;this.gpuProgram=e,this.glProgram=t,void 0===s&&(s=0,e&&(s|=u.W.WEBGPU),t&&(s|=u.W.WEBGL)),this.compatibleRenderers=s;const l={};if(o||r||(o={}),o&&r)throw new Error("[Shader] Cannot have both resources and groups");if(!e&&r&&!c)throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");if(!e&&r&&c)for(const i in c)for(const n in c[i]){const e=c[i][n];l[e]={group:i,binding:n,name:e}}else if(e&&r&&!c){const n=e.structsAndGroups.groups;c={},n.forEach((n=>{c[n.group]=c[n.group]||{},c[n.group][n.binding]=n.name,l[n.name]=n}))}else if(o){if(e){const n=e.structsAndGroups.groups;c={},n.forEach((n=>{c[n.group]=c[n.group]||{},c[n.group][n.binding]=n.name,l[n.name]=n}))}else{c={},r={99:new i.T},this._ownedBindGroups.push(r[99]);let n=0;for(const e in o)l[e]={group:99,binding:n,name:e},c[99]=c[99]||{},c[99][n]=e,n++}r={};for(const n in o){const e=n;let t=o[n];t.source||t._resourceType||(t=new a.k(t));const s=l[e];s&&(r[s.group]||(r[s.group]=new i.T,this._ownedBindGroups.push(r[s.group])),r[s.group].setResource(t,s.binding))}}this.groups=r,this._uniformBindMap=c,this.resources=this._buildResourceAccessor(r,l)}addResource(n,e,t){var r,o;(r=this._uniformBindMap)[e]||(r[e]={}),(o=this._uniformBindMap[e])[t]||(o[t]=n),this.groups[e]||(this.groups[e]=new i.T,this._ownedBindGroups.push(this.groups[e]))}_buildResourceAccessor(n,e){const t={};for(const r in e){const o=e[r];Object.defineProperty(t,o.name,{get(){return n[o.group].getResource(o.binding)},set(e){n[o.group].setResource(e,o.binding)}})}return t}destroy(n=!1){this.emit("destroy",this),n&&(this.gpuProgram?.destroy(),this.glProgram?.destroy()),this.gpuProgram=null,this.glProgram=null,this.removeAllListeners(),this._uniformBindMap=null,this._ownedBindGroups.forEach((n=>{n.destroy()})),this._ownedBindGroups=null,this.resources=null,this.groups=null}static from(n){const{gpu:e,gl:t,...r}=n;let i,u;return e&&(i=s.B.from(e)),t&&(u=o.M.from(t)),new c({gpuProgram:i,glProgram:u,...r})}}},1852:function(n,e,t){t.d(e,{k:function(){return u}});var r=t(9778),o=t(3929);t(6573),t(8100),t(7936),t(7467),t(4732),t(9577);function i(n,e){switch(n){case"f32":return 0;case"vec2<f32>":return new Float32Array(2*e);case"vec3<f32>":return new Float32Array(3*e);case"vec4<f32>":return new Float32Array(4*e);case"mat2x2<f32>":return new Float32Array([1,0,0,1]);case"mat3x3<f32>":return new Float32Array([1,0,0,0,1,0,0,0,1]);case"mat4x4<f32>":return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}return null}const s=class n{constructor(e,t){this._touched=0,this.uid=(0,r.L)("uniform"),this._resourceType="uniformGroup",this._resourceId=(0,r.L)("resource"),this.isUniformGroup=!0,this._dirtyId=0,t={...n.defaultOptions,...t},this.uniformStructures=e;const s={};for(const n in e){const t=e[n];t.name=n,t.size=t.size??1,t.value??(t.value=i(t.type,t.size)),s[n]=t.value}this.uniforms=s,this._dirtyId=1,this.ubo=t.ubo,this.isStatic=t.isStatic,this._signature=(0,o.X)(Object.keys(s).map((n=>`${n}-${e[n].type}`)).join("-"),"uniform-group")}update(){this._dirtyId++}};s.defaultOptions={ubo:!1,isStatic:!1};let u=s},3688:function(n,e,t){t.d(e,{U:function(){return d}});const r={normal:0,add:1,multiply:2,screen:3,overlay:4,erase:5,"normal-npm":6,"add-npm":7,"screen-npm":8},o=0,i=1,s=2,u=3,a=4,c=5,l=class n{constructor(){this.data=0,this.blendMode="normal",this.polygonOffset=0,this.blend=!0,this.depthMask=!0}get blend(){return!!(this.data&1<<o)}set blend(n){!!(this.data&1<<o)!==n&&(this.data^=1<<o)}get offsets(){return!!(this.data&1<<i)}set offsets(n){!!(this.data&1<<i)!==n&&(this.data^=1<<i)}set cullMode(n){"none"!==n?(this.culling=!0,this.clockwiseFrontFace="front"===n):this.culling=!1}get cullMode(){return this.culling?this.clockwiseFrontFace?"front":"back":"none"}get culling(){return!!(this.data&1<<s)}set culling(n){!!(this.data&1<<s)!==n&&(this.data^=1<<s)}get depthTest(){return!!(this.data&1<<u)}set depthTest(n){!!(this.data&1<<u)!==n&&(this.data^=1<<u)}get depthMask(){return!!(this.data&1<<c)}set depthMask(n){!!(this.data&1<<c)!==n&&(this.data^=1<<c)}get clockwiseFrontFace(){return!!(this.data&1<<a)}set clockwiseFrontFace(n){!!(this.data&1<<a)!==n&&(this.data^=1<<a)}get blendMode(){return this._blendMode}set blendMode(n){this.blend="none"!==n,this._blendMode=n,this._blendModeId=r[n]||0}get polygonOffset(){return this._polygonOffset}set polygonOffset(n){this.offsets=!!n,this._polygonOffset=n}toString(){return`[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`}static for2d(){const e=new n;return e.depthTest=!1,e.blend=!0,e}};l.default2d=l.for2d();let d=l},2298:function(n,e,t){t.d(e,{W:function(){return a}});t(4114);var r=t(9858),o=t(749),i=t(2251);let s=0;class u{constructor(n){this._poolKeyHash=Object.create(null),this._texturePool={},this.textureOptions=n||{},this.enableFullScreen=!1}createTexture(n,e,t){const r=new o.v({...this.textureOptions,width:n,height:e,resolution:1,antialias:t,autoGarbageCollect:!0});return new i.g({source:r,label:"texturePool_"+s++})}getOptimalTexture(n,e,t=1,o){let i=Math.ceil(n*t-1e-6),s=Math.ceil(e*t-1e-6);i=(0,r.U5)(i),s=(0,r.U5)(s);const u=(i<<17)+(s<<1)+(o?1:0);this._texturePool[u]||(this._texturePool[u]=[]);let a=this._texturePool[u].pop();return a||(a=this.createTexture(i,s,o)),a.source._resolution=t,a.source.width=i/t,a.source.height=s/t,a.source.pixelWidth=i,a.source.pixelHeight=s,a.frame.x=0,a.frame.y=0,a.frame.width=n,a.frame.height=e,a.updateUvs(),this._poolKeyHash[a.uid]=u,a}getSameSizeTexture(n,e=!1){const t=n.source;return this.getOptimalTexture(n.width,n.height,t._resolution,e)}returnTexture(n){const e=this._poolKeyHash[n.uid];this._texturePool[e].push(n)}clear(n){if(n=!1!==n,n)for(const e in this._texturePool){const n=this._texturePool[e];if(n)for(let e=0;e<n.length;e++)n[e].destroy(!0)}this._texturePool={}}}const a=new u},3929:function(n,e,t){t.d(e,{X:function(){return i}});const r=Object.create(null),o=Object.create(null);function i(n,e){let t=o[n];return void 0===t&&(void 0===r[e]&&(r[e]=1),o[n]=t=r[e]++),t}},3074:function(n,e,t){t.d(e,{W:function(){return r}});var r=(n=>(n[n["WEBGL"]=1]="WEBGL",n[n["WEBGPU"]=2]="WEBGPU",n[n["BOTH"]=3]="BOTH",n))(r||{})},4865:function(n,e,t){function r(n,e,t){const r=(n>>24&255)/255;e[t++]=(255&n)/255*r,e[t++]=(n>>8&255)/255*r,e[t++]=(n>>16&255)/255*r,e[t++]=r}t.d(e,{V:function(){return r}})},9389:function(n,e,t){t.d(e,{K:function(){return r}});class r{constructor(){this.vertexSize=4,this.indexSize=6,this.location=0,this.batcher=null,this.batch=null,this.roundPixels=0}get blendMode(){return this.renderable.groupBlendMode}packAttributes(n,e,t,r){const o=this.renderable,i=this.texture,s=o.groupTransform,u=s.a,a=s.b,c=s.c,l=s.d,d=s.tx,f=s.ty,m=this.bounds,h=m.maxX,p=m.minX,g=m.maxY,x=m.minY,v=i.uvs,b=o.groupColorAlpha,y=r<<16|65535&this.roundPixels;n[t+0]=u*p+c*x+d,n[t+1]=l*x+a*p+f,n[t+2]=v.x0,n[t+3]=v.y0,e[t+4]=b,e[t+5]=y,n[t+6]=u*h+c*x+d,n[t+7]=l*x+a*h+f,n[t+8]=v.x1,n[t+9]=v.y1,e[t+10]=b,e[t+11]=y,n[t+12]=u*h+c*g+d,n[t+13]=l*g+a*h+f,n[t+14]=v.x2,n[t+15]=v.y2,e[t+16]=b,e[t+17]=y,n[t+18]=u*p+c*g+d,n[t+19]=l*g+a*p+f,n[t+20]=v.x3,n[t+21]=v.y3,e[t+22]=b,e[t+23]=y}packIndex(n,e,t){n[e]=t+0,n[e+1]=t+1,n[e+2]=t+2,n[e+3]=t+0,n[e+4]=t+2,n[e+5]=t+3}reset(){this.renderable=null,this.texture=null,this.batcher=null,this.batch=null,this.bounds=null}}}}]);
//# sourceMappingURL=174.87937959.js.map