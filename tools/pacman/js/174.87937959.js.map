{"version":3,"file":"js/174.87937959.js","mappings":"0MAQgB,SAAAA,EAAQC,EAAkCC,EAAiCC,GAEvF,GAAIF,EAEA,IAAK,MAAMG,KAAKH,EAChB,CACU,MAAAI,EAAKD,EAAEE,oBAEPC,EAAOL,EAAMG,GAEnB,GAAIE,EACJ,CACQ,IAAAC,EAAgBP,EAASG,GAEnB,WAANA,IAEAI,EAAgBA,EACXC,QAAQ,mBAAoB,IAC5BA,QAAQ,oBAAqB,KAGlCN,GAEKI,EAAAG,KAAc,SAAAP,WAEvBI,EAAKG,KAAKF,EAAa,MAMlBG,EAAAA,EAAAA,GAAA,GAAGP,4CAEZ,CAGZ,CC5CO,MAAMQ,EAAc,iBAMpB,SAASC,EAAaC,GAEzB,MAAMZ,EAAkC,CAAC,EAEnCa,EAAcD,EACfE,MAAMJ,IACLK,KAAKC,GAASA,EAAKT,QAAQ,UAAW,OAAQ,GAO7C,OALKM,EAAAI,SAASD,IAEXhB,EAAAgB,GAAQ,EAAC,IAGZhB,CACX,CCpBA,SAASkB,EAAcC,EAAwBC,GAEvC,IAAAN,EACJ,MAAMO,EAAQ,kBAEd,MAAgD,QAAxCP,EAAQO,EAAMC,KAAKH,IAEnBC,EAAAZ,KAAKM,EAAM,GAEvB,CAEO,SAASS,EAAcC,EAAkBC,EAAkBC,GAAO,GAGrE,MAAMC,EAAoB,GAE1BT,EAAcO,EAAUE,GAEdH,EAAAP,SAASW,IAEXA,EAASC,QAEKX,EAAAU,EAASC,OAAQF,EAAO,IAK9C,MAAMG,EAAYH,EAEdD,GAEAI,EAAUJ,OAGd,MAAMK,EAAcD,EACff,KAAK,CAAAiB,EAAS9B,IAA0B,oBAAAA,MAAM8B,OAC9CC,KAAK,MAGV,IAAIC,EAAgBT,EAASlB,QAAQ,mBAAoB,IAIlD,OAFS2B,EAAAA,EAAc3B,QAAQ,SAAU,KAAKwB,OAE9CG,CACX,CC5CA,SAASC,EAAehB,EAAwBC,GAExC,IAAAN,EACJ,MAAMO,EAAQ,mBAEd,MAAgD,QAAxCP,EAAQO,EAAMC,KAAKH,IAEnBC,EAAAZ,KAAKM,EAAM,GAEvB,CAEA,SAASsB,EAAoBC,GAEzB,MAAMhB,EAAQ,eAERP,EAAQO,EAAMC,KAAKe,GAElB,OAAAvB,EAAQA,EAAM,GAAK,EAC9B,CAEA,SAASwB,EAAcD,GAEnB,MAAMhB,EAAQ,WAEP,OAAAgB,EAAM9B,QAAQc,EAAO,GAChC,CAEgB,SAAAkB,EAAef,EAAkBC,GAG7C,MAAME,EAAoB,GAE1BQ,EAAeV,EAAUE,GAEfH,EAAAP,SAASW,IAEXA,EAASC,QAEMM,EAAAP,EAASC,OAAQF,EAAO,IAI/C,IAAIa,EAAQ,EAGZ,MAAMC,EAAad,EACdD,OACAX,KAAKiB,GAEEA,EAAQU,QAAQ,YACpB,EACWV,EAGJ,aAAaQ,QAAYR,MAEnCC,KAAK,OAGJU,EAAYhB,EACbD,OACAX,KAAKiB,GAA0B,cAAAM,EAAcN,QAC7CC,KAAK,MAGJW,EAAU,qCACFjB,EACTD,OACAX,KAAKiB,GAAY,IAAII,EAAoBJ,OACzCC,KAAK,WAGV,IAAIY,EAAepB,EAASlB,QAAQ,oBAAqB,IAMlD,OAJQsC,EAAAA,EAAatC,QAAQ,aAAc,KAAKkC,OACxCI,EAAAA,EAAatC,QAAQ,YAAa,KAAKoC,OACvCE,EAAAA,EAAatC,QAAQ,aAAc,KAAKqC,OAEhDC,CACX,CC1EgB,SAAAC,EAAWC,EAAqBC,GAE5C,IAAI5B,EAAM2B,EAEV,IAAK,MAAM7C,KAAK8C,EAChB,CACU,MAAAhD,EAAQgD,EAAc9C,GAEtB+C,EAAWjD,EAAMiC,KAAK,MAIxBb,EAFA6B,EAASC,OAEH9B,EAAIb,QAAQ,KAAKL,MAAO,UAAUA,mBAAmBF,EAAMiC,KAAK,gBAAgB/B,kBAKhFkB,EAAIb,QAAa,KAAAL,MAAO,GAClC,CAGG,OAAAkB,CACX,CCLA,MAAM+B,EAAqDC,OAAAC,OAAO,MAC5DC,EAAA,IAA8CC,IAEpD,IAAIC,EAAY,EAQT,SAASC,GAAkB,SAC9BhC,EAAA,KACAiC,IAGM,MAAAC,EAAUC,EAAgBnC,EAAUiC,GAE1C,GAAIP,EAASQ,GAAU,OAAOR,EAASQ,GAEvC,MAAM,OAAEE,EAAQjC,SAAAA,GAAakC,EAAwBrC,EAAUiC,GAI/D,OAFAP,EAASQ,GAAWI,EAAYF,EAAQjC,EAAU8B,GAE3CP,EAASQ,EACpB,CAEO,SAASK,GAAoB,SAChCvC,EAAA,KACAiC,IAGM,MAAAC,EAAUC,EAAgBnC,EAAUiC,GAE1C,OAAIP,EAASQ,KAEbR,EAASQ,GAAWI,EAAYtC,EAASoC,OAAQpC,EAASG,SAAU8B,IAFtCP,EAASQ,EAK3C,CAEA,SAASG,EAAwBrC,EAA8BiC,GAE3D,MAAMO,EAAkBP,EAAK3C,KAAKmD,GAAcA,EAAUL,SAAQM,QAAQC,KAAQA,IAC5EC,EAAoBX,EAAK3C,KAAKmD,GAAcA,EAAUtC,WAAUuC,QAAQC,KAAQA,IAGtF,IAAIE,EAAiB/C,EAAc0C,EAAiBxC,EAASoC,QAAQ,GAEpDS,EAAA/B,EAAe0B,EAAiBK,GAEjD,MAAMC,EAAmBhD,EAAc8C,EAAmB5C,EAASG,UAAU,GAEtE,OACHiC,OAAQS,EACR1C,SAAU2C,EAElB,CAEA,SAASX,EAAgBnC,EAA8BiC,GAE5C,OAAAA,EACF3C,KAAKyD,IAEGlB,EAAYmB,IAAID,IAELlB,EAAAoB,IAAIF,EAAchB,KAG3BF,EAAYqB,IAAIH,MAE1B9C,MAAM,CAAAkD,EAAGC,IAAMD,EAAIC,IACnB5C,KAAK,KAAOR,EAASoC,OAASpC,EAASG,QAChD,CAEA,SAASmC,EAAYF,EAAgBjC,EAAkB8B,GAE7C,MAAAoB,EAAcnE,EAAakD,GAC3Bb,EAAgBrC,EAAaiB,GAQ5B,OANF8B,EAAAzC,SAASiD,IAEVpE,EAAQoE,EAAUL,OAAQiB,EAAaZ,EAAUjE,MACjDH,EAAQoE,EAAUtC,SAAUoB,EAAekB,EAAUjE,KAAK,IAGvD,CACH4D,OAAQf,EAAWe,EAAQiB,GAC3BlD,SAAUkB,EAAWlB,EAAUoB,GAEvC,CChHM,MAAA+B,EAA8B,m/BA8C9BC,EAAgC,sTAqBhCC,EAA6B,ywBAsC7BC,EAA+B,mQCzGxBC,EAAoB,CAC7BlF,KAAM,sBACN4D,OAAQ,CACJhC,OAAkB,qTA2BbuD,EAAsB,CAC/BnF,KAAM,sBACN4D,OAAQ,CACJhC,OAAkB,wLCzBnB,SAASwD,GAA4B,KAAE3B,EAAMzD,KAAAA,IAEhD,MAAMqF,EAAS7B,EAAkB,CAC7BhC,SAAU,CACNG,SAAUoD,EACVnB,OAAQkB,GAEZrB,KAAM,CACFyB,KACGzB,KAIX,OAAO6B,EAAAA,EAAWC,KAAK,CACnBvF,OACA4D,OAAQ,CACJyB,OAAQA,EAAOzB,OACf4B,WAAY,QAEhB7D,SAAU,CACN0D,OAAQA,EAAO1D,SACf6D,WAAY,SAGxB,CAEO,SAASC,GAA2B,KAAEhC,EAAMzD,KAAAA,IAE/C,OAAO,IAAI0F,EAAAA,EAAU,CACjB1F,UACG+D,EAAoB,CACnBvC,SAAU,CACNoC,OAAQoB,EACRrD,SAAUsD,GAEdxB,KAAM,CACF0B,KACG1B,MAInB,C,8ECjDO,MAAMkC,EAAW,CACpB3F,KAAM,YACN4D,OAAQ,CACJhC,OAAkB,iDAGlBgE,KAAgB,kFAMXC,EAAa,CACtB7F,KAAM,YACN4D,OAAQ,CACJhC,OAAkB,0CAGlBgE,KAAgB,4E,qFChBxB,MAAME,EAAyD,CAAC,EAOhE,SAASC,EAAmBC,GAExB,MAAMC,EAAM,GAEZ,GAAoB,IAAhBD,EAEAC,EAAI1F,KAAK,8DACT0F,EAAI1F,KAAK,2DAGb,CACI,IAAI2F,EAAe,EAEnB,IAAK,IAAIjG,EAAI,EAAGA,EAAI+F,EAAa/F,IAE7BgG,EAAI1F,KAA2B,sBAAA2F,yBAAoCjG,EAAI,uBACvEgG,EAAI1F,KAA2B,sBAAA2F,0BAAqCjG,EAAI,cAC5E,CAGG,OAAAgG,EAAIjE,KAAK,KACpB,CAEA,SAASmE,EAAkBH,GAEvB,MAAMC,EAAM,GAEZ,GAAoB,IAAhBD,EAEAC,EAAI1F,KAAK,uFAGb,CACI0F,EAAI1F,KAAK,uBAET,IAAK,IAAIN,EAAI,EAAGA,EAAI+F,EAAa/F,IAEzBA,IAAM+F,EAAc,EAEpBC,EAAI1F,KAAkB,eAIlB0F,EAAA1F,KAAe,UAAAN,OAEvBgG,EAAI1F,KAAwD,mDAAAN,EAAI,oBAAoBA,EAAI,wBACxFgG,EAAI1F,KAAoB,iBAG5B0F,EAAI1F,KAAQ,KAGT,OAAA0F,EAAIjE,KAAK,KACpB,CAEO,SAASoE,EAAwBJ,GAqCpC,OAnCKF,EAAwBE,KAEzBF,EAAwBE,GAAe,CACnChG,KAAM,oBACN4D,OAAQ,CACJhC,OAAQ,gIAIRgE,KAAM,qEAGNS,IAAK,wNAOT1E,SAAU,CACNC,OAAQ,oFAGNmE,EAAmB,oBAErBH,KAAM,yGAIJO,EAAkB,uBAMzBL,EAAwBE,EACnC,CAEA,MAAMM,EAAwD,CAAC,EAO/D,SAASC,EAAoBP,GAEzB,MAAMC,EAAM,GAEZ,IAAK,IAAIhG,EAAI,EAAGA,EAAI+F,EAAa/F,IAEzBA,EAAI,GAEJgG,EAAI1F,KAAK,QAGTN,EAAI+F,EAAc,GAEdC,EAAA1F,KAAwB,mBAAAN,QAGhCgG,EAAI1F,KAAK,KACL0F,EAAA1F,KAAuC,kCAAAN,aAC3CgG,EAAI1F,KAAK,KAGN,OAAA0F,EAAIjE,KAAK,KACpB,CAEO,SAASwE,EAA0BR,GAqCtC,OAnCKM,EAAuBN,KAExBM,EAAuBN,GAAe,CAClChG,KAAM,oBACN4D,OAAQ,CACJhC,OAAQ,qHAKRgE,KAAM,qEAGNS,IAAK,wLAOT1E,SAAU,CACNC,OAAQ,6FAGsBoE,oCAG9BJ,KAAM,2BAEJW,EAAoB,uBAM3BD,EAAuBN,EAClC,C,wGC7KO,MAAMS,EAAkB,CAC3BzG,KAAM,oBACN4D,OAAQ,CACJhC,OAAkB,kQAUlBgE,KAAgB,sHAIhBS,IAAe,gMAUVK,EAAwB,IAC9BD,EACH7C,OAAQ,IACD6C,EAAgB7C,OAEnBhC,OAAQ6E,EAAgB7C,OAAOhC,OAAOtB,QAAQ,WAAY,cAIrDqG,EAAoB,CAC7B3G,KAAM,oBACN4D,OAAQ,CACJhC,OAAkB,gIAMlBgE,KAAgB,yFAIhBS,IAAe,sJ,8ECjDhB,MAAMO,EAAiB,CAC1B5G,KAAM,mBACN4D,OAAQ,CACJhC,OAAkB,kOASbiF,EAAmB,CAC5B7G,KAAM,mBACN4D,OAAQ,CACJhC,OAAkB,mN,8ECX1B,IAAIkF,ECAAC,EDQG,SAASC,IAEZ,IAAKF,GAAWA,GAASG,gBACzB,CACI,MAAMC,EAASC,EAAAA,EAAWzC,MAAM0C,eAEhCN,EAAUI,EAAOG,WAAW,QAAS,GAAE,CAGpC,OAAAP,CACX,CChBO,SAASQ,IAEZ,IAAKP,EACL,CAC2BA,EAAA,UACvB,MAAMQ,EAAKP,IAEX,GAAIO,GAEIA,EAAGC,yBACP,CACI,MAAMC,EAAiBF,EAAGC,yBAAyBD,EAAGG,gBAAiBH,EAAGI,YAEnDZ,EAAAU,EAAeG,UAAY,QAAU,UAEpE,CAGG,OAAAb,CACX,CCzBgB,SAAAc,EAAkB5B,EAAa6B,EAAkBC,GAEzD,OAAAD,EAAgB7B,EAEhB8B,GAEM9B,EAAAA,EAAI3F,QAAQ,uBAAwB,IAEnC,oMAOL2F,eAIC,uJAMDA,aAEV,CCLgB,SAAA+B,EACZ/B,EACAgC,EACAF,GAGA,MAAMG,EAAwBH,EAAaE,EAAQE,8BAAgCF,EAAQG,4BAE3F,GAA4B,cAAxBnC,EAAIoC,UAAU,EAAG,GACrB,CAEI,IAAIT,EAAYG,EAAaE,EAAQK,2BAA6BL,EAAQM,yBAQ1E,MALkB,UAAdX,GAAmD,UAA1BM,IAEbN,EAAA,WAGT,aAAaA,aAAqB3B,GAAG,CAChD,MACmC,UAA1BiC,GAA8D,oBAAzBjC,EAAIoC,UAAU,EAAG,IAGpDpC,EAAI3F,QAAQ,kBAAmB,qBAGnC2F,CACX,CClDgB,SAAAuC,EAAcvC,EAAa6B,GAEvC,OAAKA,EAEE,oBAAoB7B,IAFNA,CAGzB,CCLA,MAAMwC,EAA+C,CAAC,EAChDC,EAA6C,CAAC,EAE7C,SAASC,EAAe1C,GAAa,KAAEjG,EAAsB,gBAAsB+H,GAAa,GAE5F/H,EAAAA,EAAKM,QAAQ,OAAQ,KAE5BN,GAAQ+H,EAAa,YAAc,UAE7B,MAAAa,EAAYb,EAAaU,EAAoBC,EAa/C,GAXAE,EAAU5I,IAEV4I,EAAU5I,KACFA,GAAA,IAAI4I,EAAU5I,MAItB4I,EAAU5I,GAAQ,GAIqB,IAAvCiG,EAAIxD,QAAQ,uBAAsC,OAAAwD,EAEhD,MAAA4C,EAAa,uBAAuB7I,IAE1C,MAAO,GAAG6I,MAAe5C,GAC7B,CC3BgB,SAAA6C,EAAa7C,EAAa6B,GAEtC,OAAKA,EAEE7B,EAAI3F,QAAQ,kBAAmB,IAFjB2F,CAGzB,CCkDA,MAAM8C,EAA8F,CAEhGD,aAAAA,EAEAd,gBAAAA,EAEAH,kBAAAA,EAEAc,eAAAA,EAEAH,cAAaA,GAGXQ,EAAiD7F,OAAAC,OAAO,MAgCjD6F,EAAN,MAAMA,EA2CTC,WAAAA,CAAYjB,GAERA,EAAU,IAAKgB,EAAUE,kBAAmBlB,GAI5C,MAAMH,GAA0D,IAAhDG,EAAQtG,SAASc,QAAQ,mBAEnC2G,EAAsB,CACxBN,aAAchB,EACdE,gBAAiB,CACbM,2BAA4BL,EAAQoB,2BACpCd,yBAA0BN,EAAQqB,yBAClClB,4BAA6B,QAC7BD,8BAA+Bb,KAEnCqB,eAAgB,CACZ3I,KAAMiI,EAAQjI,MAElB6H,kBAAmBC,EACnBU,cAAeV,GAGnB,IAAInG,EAAWsG,EAAQtG,SACnBiC,EAASqE,EAAQrE,OAErBT,OAAOoG,KAAKR,GAAW/H,SAASwI,IAEtB,MAAAC,EAAiBL,EAAoBI,GAE3C7H,EAAWoH,EAAUS,GAAY7H,EAAU8H,GAAgB,GAC3D7F,EAASmF,EAAUS,GAAY5F,EAAQ6F,GAAgB,EAAM,IAGjEC,KAAK/H,SAAWA,EAChB+H,KAAK9F,OAASA,EAET,KAAA+F,MAAOC,EAAAA,EAAAA,GAAsB,GAAAF,KAAK9F,UAAU8F,KAAK/H,WAAY,aAAY,CAI3EkI,OAAAA,GAEFH,KAAK/H,SAAoB,KACzB+H,KAAK9F,OAAkB,KAExB8F,KAAKI,eAAiB,KACtBJ,KAAKK,aAAe,KACpBL,KAAKM,kBAAoB,KAEzBN,KAAKO,0BAA4B,KAUrC,WAAc1E,CAAK0C,GAEf,MAAMiC,EAAS,GAAAjC,EAAQrE,UAAUqE,EAAQtG,WAOzC,OALKqH,EAAakB,KAEdlB,EAAakB,GAAO,IAAIjB,EAAUhB,IAG/Be,EAAakB,EAAG,GAhHlBjB,EAGKE,eAA4C,CACtDG,yBAA0B,QAC1BD,2BAA4B,WAL7B,IAAM3D,EAANuD,C,8EC9FP,MAAMkB,EAAqD,CAEvDC,IAAM,UACN,YAAa,YACb,YAAa,YACb,YAAa,YACbC,MAAO,YACPC,MAAO,YACPC,MAAO,YAEPC,IAAK,SACL,YAAa,WACb,YAAa,WACb,YAAa,WAEbC,IAAK,SACL,YAAa,WACb,YAAa,WACb,YAAa,WAEbC,KAAM,SACN,aAAc,WACd,aAAc,WACd,aAAc,YAGX,SAASC,GACZ,OAAEtF,EAAQG,WAAAA,IAGV,MAAM9D,EAAkD,CAAC,EAGnDkJ,EAAgBvF,EAAO5C,QAAQ,MAAM+C,KAE3C,IACA,IADIoF,EACJ,CAEI,MAAMC,EAAqBxF,EAAO5C,QAAQ,KAAMmI,GAEhD,IACA,IADIC,EACJ,CACI,MAAMC,EAAwBzF,EAAOgD,UAAUuC,EAAeC,GAGxDE,EAAc,0EAChB,IAAAlK,EAEJ,MAA6D,QAArDA,EAAQkK,EAAY1J,KAAKyJ,IACjC,CACI,MAAME,EAASb,EAAqBtJ,EAAM,KAAuB,UAEzDa,EAAAb,EAAM,IAAM,CAChBoK,SAAUC,SAASrK,EAAM,GAAI,IAC7BmK,SACAG,QAAQC,EAAAA,EAAAA,GAA2BJ,GAAQG,OAC3CE,OAAQ,EACRC,UAAU,EACVC,MAAO,EACX,CACJ,CACJ,CAGG,OAAA7J,CACX,CCxDO,SAAS8J,EAAuBC,GAGnC,MAAMC,EAAc,yCACdC,EAAe,kBACfC,EAAiB,oBACjBC,EAAc,sBACdC,EAAc,YACdC,EAAgB,8BAChBC,EAAsB,2BACtBC,EAAa,iBAGbC,EAAST,EAAK5K,MAAM6K,IAAc5K,KAAKqL,IAAU,CACnDC,MAAOlB,SAASiB,EAAKtL,MAAM8K,GAAc,GAAI,IAC7CU,QAASnB,SAASiB,EAAKtL,MAAM+K,GAAgB,GAAI,IACjD5L,KAAMmM,EAAKtL,MAAMgL,GAAa,GAC9BS,UAA0C,cAA/BH,EAAKtL,MAAMgL,GAAa,GACnCU,KAAMJ,EAAKtL,MAAMiL,GAAa,OAGlC,IAAKI,EAEM,OACHA,OAAQ,GACRM,QAAS,IAKjB,MAAMA,EAAUf,EACX5K,MAAMkL,IACLjL,KAAK2L,IAEH,MAAMzM,EAAOyM,EAAO5L,MAAMoL,GAAY,GAChCS,EAAUD,EAAO5L,MAAMmL,GAAqBW,QAAQ,CAAAC,EAA6BC,KAEnF,MAAOC,EAAMP,GAAQM,EAAOE,MAAM,KAI3B,OAFPH,EAAIE,EAAKE,QAAUT,EAAKS,OAEjBJ,CAAA,GACR,CAAC,GAEJ,OAAKF,EAKE,CAAE1M,OAAM0M,WAHJ,IAGa,IAG3BxI,QAAO,EAAGlE,UAAWkM,EAAOe,MAAMb,GAAUA,EAAMG,OAASvM,OAAU,GAEnE,OACHkM,SACAM,UAER,C,YCzEYU,EAAA,CAAAC,IAERA,EAAAA,EAAA,UAAS,GAAT,SACAA,EAAAA,EAAA,YAAW,GAAX,WACAA,EAAAA,EAAA,WAAU,GAAV,UAJQA,GAAA,CAAAD,GAAA,ICKI,SAAAE,GAAwB,OAAElB,IAEtC,MAAMmB,EAA2C,GAEjD,IAAK,IAAIpN,EAAI,EAAGA,EAAIiM,EAAOjJ,OAAQhD,IACnC,CACU,MAAAmM,EAAQF,EAAOjM,GAEhBoN,EAAOjB,EAAMA,SAEPiB,EAAAjB,EAAMA,OAAS,IAGtBA,EAAME,UAECe,EAAAjB,EAAMA,OAAO7L,KAAK,CACrB8L,QAASD,EAAMC,QACfiB,WAAYJ,EAAYK,OAASL,EAAYM,SAC7CC,OAAQ,CACJlB,KAAM,aAIM,YAAfH,EAAMG,KAEJc,EAAAjB,EAAMA,OAAO7L,KAAK,CACrB8L,QAASD,EAAMC,QACfiB,WAAYJ,EAAYM,SACxBE,QAAS,CACLnB,KAAM,eAIM,eAAfH,EAAMG,MAEJc,EAAAjB,EAAMA,OAAO7L,KAAK,CACrB8L,QAASD,EAAMC,QACfiB,WAAYJ,EAAYM,SACxBG,QAAS,CACLC,WAAY,QACZC,cAAe,KACfC,cAAc,IAG1B,CAGG,OAAAT,CACX,CClDgB,SAAAU,GAAmB,OAAE7B,IAEjC,MAAMmB,EAAwB,GAE9B,IAAK,IAAIpN,EAAI,EAAGA,EAAIiM,EAAOjJ,OAAQhD,IACnC,CACU,MAAAmM,EAAQF,EAAOjM,GAEhBoN,EAAOjB,EAAMA,SAEPiB,EAAAjB,EAAMA,OAAS,CAAC,GAG3BiB,EAAOjB,EAAMA,OAAOA,EAAMpM,MAAQoM,EAAMC,OAAA,CAGrC,OAAAgB,CACX,CClBgB,SAAAW,EACZC,EACAC,GAGM,MAAAC,EAAA,IAAoBC,IACpBC,EAAA,IAAsBD,IAEtB5B,EAAU,IAAIyB,EAAuBzB,WAAY0B,EAAyB1B,SAC3EtI,QAAQuI,IAED0B,EAAc3J,IAAIiI,EAAOzM,QAIfmO,EAAAG,IAAI7B,EAAOzM,OAElB,KAGTkM,EAAS,IAAI+B,EAAuB/B,UAAWgC,EAAyBhC,QACzEhI,QAAQkI,IAEL,MAAMlC,EAAS,GAAAkC,EAAMpM,QAAQoM,EAAMC,UAE/B,OAAAgC,EAAgB7J,IAAI0F,KAIxBmE,EAAgBC,IAAIpE,IAEb,MAGR,OAAEsC,UAASN,SACtB,CCkBA,MAAMlD,EAAkD7F,OAAAC,OAAO,MAqCxD,MAAMkC,EA0DT4D,WAAAA,CAAYjB,GApBZ,KAAOsG,WAAa,EAsBhB,MAAM,SAAE5M,EAAUiC,OAAAA,EAAA,OAAQyJ,EAAQmB,UAAAA,EAAA,KAAWxO,GAASiI,EAQlD,GANJyB,KAAK1J,KAAOA,EAEZ0J,KAAK/H,SAAWA,EAChB+H,KAAK9F,OAASA,EAGVjC,EAAS0D,SAAWzB,EAAOyB,OAC/B,CACU,MAAAoJ,EAAmBjD,EAAuB7J,EAAS0D,QAEzDqE,KAAK+E,iBAAmBA,CAAA,KAG5B,CACU,MAAAR,EAAyBzC,EAAuB5H,EAAOyB,QACvD6I,EAA2B1C,EAAuB7J,EAAS0D,QAE5D,KAAAoJ,iBAAmBT,EAA+BC,EAAwBC,EAAwB,CAI3GxE,KAAK2D,OAASA,GAAUU,EAAmBrE,KAAK+E,kBAIhD/E,KAAK8E,UAAYA,GAAapB,EAAwB1D,KAAK+E,kBAE3D/E,KAAKgF,gCAAiE,IAAnChF,KAAK2D,OAAO,IAAIsB,gBACnDjF,KAAKkF,+BAA+D,IAAlClF,KAAK2D,OAAO,IAAIwB,eAElDnF,KAAKoF,qBAAoB,CAIrBA,mBAAAA,GAEE,aAAElL,EAAQjC,SAAAA,GAAa+H,KAEvBqF,EAASnL,EAAOyB,OAAS1D,EAAS0D,OAASzB,EAAO4B,WAAa7D,EAAS6D,WAEzE,KAAA+I,YAAa3E,EAAAA,EAAAA,GAAmBmF,EAAQ,UAAS,CAG1D,iBAAIC,GAIA,OAFAtF,KAAKI,iBAALJ,KAAKI,eAAmBa,EAAgCjB,KAAK9F,SAEtD8F,KAAKI,cAAA,CAGTD,OAAAA,GAEFH,KAAK8E,UAAqB,KAC1B9E,KAAK2D,OAAkB,KACvB3D,KAAK+E,iBAA4B,KACjC/E,KAAK/H,SAAoB,KACzB+H,KAAK9F,OAAkB,KAU5B,WAAc2B,CAAK0C,GAGf,MAAMiC,EAAS,GAAAjC,EAAQrE,OAAOyB,UAAU4C,EAAQtG,SAAS0D,UAAU4C,EAAQtG,SAAS6D,cAAcyC,EAAQrE,OAAO4B,aAOjH,OALKwD,EAAakB,KAEdlB,EAAakB,GAAO,IAAI5E,EAAW2C,IAGhCe,EAAakB,EAAG,E,uDCpO/B,MAAM+E,EAAsB,CACxBC,QAAS,CAAEC,KAAM,EAAGhE,OAAQ,EAAGiE,YAAY,GAC3CC,QAAS,CAAEF,KAAM,EAAGhE,OAAQ,EAAGiE,YAAY,GAC3CE,QAAS,CAAEH,KAAM,EAAGhE,OAAQ,EAAGiE,YAAY,GAC3CG,QAAS,CAAEJ,KAAM,EAAGhE,OAAQ,EAAGiE,YAAY,GAC3CI,SAAU,CAAEL,KAAM,EAAGhE,OAAQ,EAAGiE,YAAY,GAC5CK,SAAU,CAAEN,KAAM,EAAGhE,OAAQ,EAAGiE,YAAY,GAC5CM,SAAU,CAAEP,KAAM,EAAGhE,OAAQ,EAAGiE,YAAY,GAC5CO,SAAU,CAAER,KAAM,EAAGhE,OAAQ,EAAGiE,YAAY,GAC5CQ,SAAU,CAAET,KAAM,EAAGhE,OAAQ,EAAGiE,YAAY,GAC5CS,SAAU,CAAEV,KAAM,EAAGhE,OAAQ,EAAGiE,YAAY,GAC5CU,SAAU,CAAEX,KAAM,EAAGhE,OAAQ,EAAGiE,YAAY,GAC5CW,SAAU,CAAEZ,KAAM,EAAGhE,OAAQ,EAAGiE,YAAY,GAC5CY,UAAW,CAAEb,KAAM,EAAGhE,OAAQ,EAAGiE,YAAY,GAC7Ca,UAAW,CAAEd,KAAM,EAAGhE,OAAQ,EAAGiE,YAAY,GAC7Cc,UAAW,CAAEf,KAAM,EAAGhE,OAAQ,EAAGiE,YAAY,GAC7Ce,UAAW,CAAEhB,KAAM,EAAGhE,OAAQ,EAAGiE,YAAY,GAC7CgB,UAAW,CAAEjB,KAAM,EAAGhE,OAAQ,EAAGiE,YAAY,GAC7CiB,UAAW,CAAElB,KAAM,EAAGhE,OAAQ,EAAGiE,YAAY,GAC7CkB,QAAS,CAAEnB,KAAM,EAAGhE,OAAQ,EAAGiE,YAAY,GAC3CmB,UAAW,CAAEpB,KAAM,EAAGhE,OAAQ,EAAGiE,YAAY,GAC7CoB,UAAW,CAAErB,KAAM,EAAGhE,OAAQ,GAAIiE,YAAY,GAC9CqB,UAAW,CAAEtB,KAAM,EAAGhE,OAAQ,GAAIiE,YAAY,GAC9CsB,OAAQ,CAAEvB,KAAM,EAAGhE,OAAQ,EAAGiE,YAAY,GAC1CuB,SAAU,CAAExB,KAAM,EAAGhE,OAAQ,EAAGiE,YAAY,GAC5CwB,SAAU,CAAEzB,KAAM,EAAGhE,OAAQ,GAAIiE,YAAY,GAC7CyB,SAAU,CAAE1B,KAAM,EAAGhE,OAAQ,GAAIiE,YAAY,GAC7C0B,OAAQ,CAAE3B,KAAM,EAAGhE,OAAQ,EAAGiE,YAAY,GAC1C2B,SAAU,CAAE5B,KAAM,EAAGhE,OAAQ,EAAGiE,YAAY,GAC5C4B,SAAU,CAAE7B,KAAM,EAAGhE,OAAQ,GAAIiE,YAAY,GAC7C6B,SAAU,CAAE9B,KAAM,EAAGhE,OAAQ,GAAIiE,YAAY,IAG1C,SAAShE,EAA2BJ,GAEhC,OAAAiE,EAAoBjE,IAAWiE,EAAoBqB,OAC9D,C,6HC2GO,MAAMY,UAAeC,EAAAA,EA4CxBjI,WAAAA,CAAYjB,GAEF,QAtBH,KAAAmJ,gBAAiEjO,OAAAC,OAAO,MAC/E,KAAiBiO,iBAAgC,GAwBzC,eACAC,EAAA,UACAC,EAAA,OACArF,EAAA,UACAsF,EAAA,oBACAC,EAAA,SACAC,GACAzJ,EAGJyB,KAAK4H,WAAaA,EAClB5H,KAAK6H,UAAYA,OAEW,IAAxBE,IAEsBA,EAAA,EAElBH,IAAWG,GAAuBE,EAAAA,EAAaC,QAC/CL,IAAUE,GAAuBE,EAAAA,EAAaE,QAGtDnI,KAAK+H,oBAAsBA,EAE3B,MAAMK,EAAuC,CAAC,EAO9C,GALKN,GAActF,IAEfsF,EAAY,CAAC,GAGbA,GAAatF,EAEP,UAAI6F,MAAM,kDAEX,IAACT,GAAcpF,IAAWwF,EAEzB,UAAIK,MAAM,uFAEX,IAACT,GAAcpF,GAAUwF,EAE9B,IAAK,MAAMzR,KAAKyR,EAED,UAAAM,KAAKN,EAASzR,GACzB,CACI,MAAMgS,EAAcP,EAASzR,GAAG+R,GAEhCF,EAASG,GAAe,CACpB7F,MAAOnM,EACPoM,QAAS2F,EACThS,KAAMiS,EACV,MAIH,GAAAX,GAAcpF,IAAWwF,EAClC,CACU,MAAAQ,EAAYZ,EAAW7C,iBAAiBvC,OAE9CwF,EAAW,CAAC,EAEFQ,EAAAlR,SAASmR,IAEfT,EAASS,EAAK/F,OAASsF,EAASS,EAAK/F,QAAU,CAAC,EAChDsF,EAASS,EAAK/F,OAAO+F,EAAK9F,SAAW8F,EAAKnS,KAEjC8R,EAAAK,EAAKnS,MAAQmS,CAAA,GACzB,SAEIX,EACT,CACI,GAAKF,EA0BL,CACU,MAAAY,EAAYZ,EAAW7C,iBAAiBvC,OAE9CwF,EAAW,CAAC,EAEFQ,EAAAlR,SAASmR,IAEfT,EAASS,EAAK/F,OAASsF,EAASS,EAAK/F,QAAU,CAAC,EAChDsF,EAASS,EAAK/F,OAAO+F,EAAK9F,SAAW8F,EAAKnS,KAEjC8R,EAAAK,EAAKnS,MAAQmS,CAAA,GACzB,KApCL,CAEIT,EAAW,CAAC,EACHxF,EAAA,CACL,GAAI,IAAIkG,EAAAA,GAGZ1I,KAAK2H,iBAAiB9Q,KAAK2L,EAAO,KAElC,IAAImG,EAAW,EAEf,IAAK,MAAMpS,KAAKuR,EAKHM,EAAA7R,GAAK,CAAEmM,MAAO,GAAIC,QAASgG,EAAUrS,KAAMC,GAEpDyR,EAAS,IAAMA,EAAS,KAAO,CAAC,EACvBA,EAAA,IAAIW,GAAYpS,EAEzBoS,GACJ,CAiBJnG,EAAS,CAAC,EAEV,IAAK,MAAMjM,KAAKuR,EAChB,CACI,MAAMxR,EAAOC,EACT,IAAAmC,EAAQoP,EAAUvR,GAEhBmC,EAAMiD,QAAajD,EAAuBkQ,gBAEpClQ,EAAA,IAAImQ,EAAAA,EAAanQ,IAGvB,MAAA+P,EAAOL,EAAS9R,GAElBmS,IAEKjG,EAAOiG,EAAK/F,SAEbF,EAAOiG,EAAK/F,OAAS,IAAIgG,EAAAA,EAEzB1I,KAAK2H,iBAAiB9Q,KAAK2L,EAAOiG,EAAK/F,SAG3CF,EAAOiG,EAAK/F,OAAOoG,YAAYpQ,EAAO+P,EAAK9F,SAC/C,CACJ,CAGJ3C,KAAKwC,OAASA,EACdxC,KAAK0H,gBAAkBM,EAEvBhI,KAAK8H,UAAY9H,KAAK+I,uBAAuBvG,EAAQ4F,EAAQ,CAU1DY,WAAAA,CAAY1S,EAAc2S,EAAoBC,GAzVzD,IAAAC,EAAAC,GA2VaD,EAAA,KAAAzB,iBAALuB,KAAAE,EAAAF,GAAqC,CAAC,IAEjCG,EAAA,KAAA1B,gBAAgBuB,IAArBC,KAAgDE,EAAAF,GAAA5S,GAE3C0J,KAAKwC,OAAOyG,KAEbjJ,KAAKwC,OAAOyG,GAAc,IAAIP,EAAAA,EAC9B1I,KAAK2H,iBAAiB9Q,KAAKmJ,KAAKwC,OAAOyG,IAC3C,CAGIF,sBAAAA,CAAuBvG,EAAsB4F,GAEjD,MAAMiB,EAAc,CAAC,EAErB,IAAK,MAAM9S,KAAK6R,EAChB,CACU,MAAAK,EAAOL,EAAS7R,GAGfkD,OAAA6P,eAAeD,EAAaZ,EAAKnS,KAAM,CAC1C0E,GAAAA,GAEI,OAAOwH,EAAOiG,EAAK/F,OAAO6G,YAAYd,EAAK9F,QAAO,EAEtD5H,GAAAA,CAAIrC,GAEA8J,EAAOiG,EAAK/F,OAAOoG,YAAYpQ,EAAO+P,EAAK9F,QAAO,GAEzD,CAGE,OAAA0G,CAAA,CASJlJ,OAAAA,CAAQqJ,GAAkB,GAExB,KAAAC,KAAK,UAAWzJ,MAEjBwJ,IAEAxJ,KAAK4H,YAAYzH,UACjBH,KAAK6H,WAAW1H,WAGpBH,KAAK4H,WAAa,KAClB5H,KAAK6H,UAAY,KAEjB7H,KAAK0J,qBAEL1J,KAAK0H,gBAAkB,KAElB,KAAAC,iBAAiBrQ,SAASqS,IAE3BA,EAAUxJ,SAAQ,IAGrBH,KAAK2H,iBAA4B,KAElC3H,KAAK8H,UAAY,KACjB9H,KAAKwC,OAAS,KAUlB,WAAc3G,CAAK0C,GAEf,MAAM,IAAEqL,EAAA,GAAK/L,KAAOgM,GAAStL,EAEzB,IAAAqJ,EACAC,EAYJ,OAVI+B,IAEahC,EAAAhM,EAAAA,EAAWC,KAAK+N,IAG7B/L,IAEYgK,EAAA7L,EAAAA,EAAUH,KAAKgC,IAGxB,IAAI2J,EAAO,CACdI,aACAC,eACGgC,GACN,E,+HCtbO,SAAAC,EACZjH,EACA4C,GAGA,OAAQ5C,GAEJ,IAAK,MACM,SAEX,IAAK,YACM,WAAIkH,aAAa,EAAItE,GAEhC,IAAK,YACM,WAAIsE,aAAa,EAAItE,GAEhC,IAAK,YACM,WAAIsE,aAAa,EAAItE,GAChC,IAAK,cACD,OAAO,IAAIsE,aAAa,CAAC,EAAG,EACxB,EAAG,IAEX,IAAK,cACD,OAAO,IAAIA,aAAa,CAAC,EAAG,EAAG,EAC3B,EAAG,EAAG,EACN,EAAG,EAAG,IAEd,IAAK,cACD,OAAO,IAAIA,aAAa,CAAC,EAAG,EAAG,EAAG,EAC9B,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,IAGd,WACX,CC2CO,MAAMC,EAAN,MAAMA,EAoDTxK,WAAAA,CAAYyK,EAA6B1L,GAzCzC,KAAO2L,SAAW,EAGF,KAAAC,KAAMA,EAAAA,EAAAA,GAAI,WAE1B,KAAOvB,cAAgB,eAEhB,KAAAwB,aAAcD,EAAAA,EAAAA,GAAI,YAezB,KAAgBE,gBAAiB,EAMjC,KAAOC,SAAW,EAed/L,EAAU,IAAKyL,EAAavK,kBAAmBlB,GAE/CyB,KAAKiK,kBAAoBA,EAEzB,MAAMM,EAAW,CAAC,EAElB,IAAK,MAAMhU,KAAK0T,EAChB,CACU,MAAAO,EAAcP,EAAkB1T,GAEtCiU,EAAYlU,KAAOC,EACPiU,EAAA/E,KAAO+E,EAAY/E,MAAQ,EACvC+E,EAAY9R,QAAZ8R,EAAY9R,MAAUoR,EAAuBU,EAAY3H,KAAM2H,EAAY/E,OAElE8E,EAAAhU,GAAKiU,EAAY9R,KAAA,CAG9BsH,KAAKuK,SAAWA,EAEhBvK,KAAKsK,SAAW,EAChBtK,KAAKyK,IAAMlM,EAAQkM,IACnBzK,KAAK0K,SAAWnM,EAAQmM,SAExB1K,KAAK2K,YAAazK,EAAAA,EAAAA,GAAmBzG,OAAOoG,KAAK0K,GAAUnT,KACtDb,GAAS,GAAAA,KAAM0T,EAAkB1T,GAAqDsM,SACzFvK,KAAK,KAAM,gBAAe,CAIzBsS,MAAAA,GAEE,KAAAN,UAAA,GArFAN,EAGKvK,eAAsC,CAEhDgL,KAAK,EAELC,UAAU,GAPX,IAAM7B,EAANmB,C,uDCjFP,MAAMa,EAAe,CACjBC,OAAQ,EACRlG,IAAK,EACLmG,SAAU,EACVC,OAAQ,EACRC,QAAS,EACTC,MAAO,EACP,aAAc,EACd,UAAW,EACX,aAAc,GAEZC,EAAQ,EACRC,EAAS,EACTC,EAAU,EACVC,EAAa,EACbC,EAAU,EACVC,EAAa,EASNC,EAAN,MAAMA,EAYTjM,WAAAA,GAEIQ,KAAKyI,KAAO,EAEZzI,KAAK0L,UAAY,SACjB1L,KAAK2L,cAAgB,EAErB3L,KAAK4L,OAAQ,EACb5L,KAAK6L,WAAY,EAOrB,SAAID,GAEA,SAAU5L,KAAKyI,KAAQ,GAAK0C,EAAA,CAGhC,SAAIS,CAAMlT,MAECsH,KAAKyI,KAAQ,GAAK0C,KAAYzS,IAEjCsH,KAAKyI,MAAS,GAAK0C,EACvB,CAOJ,WAAIW,GAEA,SAAU9L,KAAKyI,KAAQ,GAAK2C,EAAA,CAGhC,WAAIU,CAAQpT,MAEDsH,KAAKyI,KAAQ,GAAK2C,KAAa1S,IAElCsH,KAAKyI,MAAS,GAAK2C,EACvB,CAIJ,YAAIW,CAASrT,GAEK,SAAVA,GAOJsH,KAAKgM,SAAU,EACfhM,KAAKiM,mBAA+B,UAAVvT,GANtBsH,KAAKgM,SAAU,CAMiB,CAGxC,YAAID,GAEI,OAAC/L,KAAKgM,QAKHhM,KAAKiM,mBAAqB,QAAU,OAHhC,MAGgC,CAO/C,WAAID,GAEA,SAAUhM,KAAKyI,KAAQ,GAAK4C,EAAA,CAGhC,WAAIW,CAAQtT,MAEDsH,KAAKyI,KAAQ,GAAK4C,KAAc3S,IAEnCsH,KAAKyI,MAAS,GAAK4C,EACvB,CAOJ,aAAIa,GAEA,SAAUlM,KAAKyI,KAAQ,GAAK6C,EAAA,CAGhC,aAAIY,CAAUxT,MAEHsH,KAAKyI,KAAQ,GAAK6C,KAAiB5S,IAEtCsH,KAAKyI,MAAS,GAAK6C,EACvB,CAOJ,aAAIO,GAEA,SAAU7L,KAAKyI,KAAQ,GAAK+C,EAAA,CAGhC,aAAIK,CAAUnT,MAEHsH,KAAKyI,KAAQ,GAAK+C,KAAiB9S,IAEtCsH,KAAKyI,MAAS,GAAK+C,EACvB,CAOJ,sBAAIS,GAEA,SAAUjM,KAAKyI,KAAQ,GAAK8C,EAAA,CAGhC,sBAAIU,CAAmBvT,MAEZsH,KAAKyI,KAAQ,GAAK8C,KAAc7S,IAEnCsH,KAAKyI,MAAS,GAAK8C,EACvB,CAQJ,aAAIG,GAEA,OAAO1L,KAAKmM,UAAA,CAGhB,aAAIT,CAAUhT,GAEVsH,KAAK4L,MAAmB,SAAVlT,EACdsH,KAAKmM,WAAazT,EACb,KAAA0T,aAAevB,EAAanS,IAAuC,EAO5E,iBAAIiT,GAEA,OAAO3L,KAAKqM,cAAA,CAGhB,iBAAIV,CAAcjT,GAET,KAAAoT,UAAYpT,EACjBsH,KAAKqM,eAAiB3T,CAAA,CAInB4T,QAAAA,GAEH,MACmB,iCAAAtM,KAAK0L,gCACI1L,KAAKiM,8BAChBjM,KAAKgM,qBACHhM,KAAK6L,2BACD7L,KAAK2L,gBAAa,CAS7C,YAAcY,GAEJ,MAAAC,EAAQ,IAAIf,EAKX,OAHPe,EAAMN,WAAY,EAClBM,EAAMZ,OAAQ,EAEPY,CAAA,GA7MFf,EAgNKgB,UAAYhB,EAAMc,QAhN7B,IAAMG,EAANjB,C,gGCtBP,IAAIkB,EAAQ,EAYL,MAAMC,EAoBTpN,WAAAA,CAAYqN,GANJ,KAAAC,aAA8CrT,OAAAC,OAAO,MAQzDsG,KAAK+M,aAAe,CAAC,EAChB,KAAAF,eAAiBA,GAAkB,CAAC,EACzC7M,KAAKgN,kBAAmB,EASrBC,aAAAA,CAAcC,EAAoBC,EAAqBC,GAEpD,MAAAC,EAAgB,IAAIC,EAAAA,EAAc,IACjCtN,KAAK6M,eAERU,MAAOL,EACPM,OAAQL,EACRM,WAAY,EACZL,YACAM,oBAAoB,IAGxB,OAAO,IAAIC,EAAAA,EAAQ,CACfhS,OAAQ0R,EACRO,MAAO,eAAejB,KACzB,CAWEkB,iBAAAA,CAAkBC,EAAoBC,EAAqBN,EAAa,EAAGL,GAE9E,IAAIY,EAAWC,KAAKC,KAAMJ,EAAaL,EAAc,MACjDU,EAAYF,KAAKC,KAAMH,EAAcN,EAAc,MAEvDO,GAAWI,EAAAA,EAAAA,IAASJ,GACpBG,GAAYC,EAAAA,EAAAA,IAASD,GAErB,MAAM3N,GAAOwN,GAAY,KAAOG,GAAa,IAAMf,EAAY,EAAI,GAE9DpN,KAAK+M,aAAavM,KAEd,KAAAuM,aAAavM,GAAO,IAG7B,IAAIyD,EAAUjE,KAAK+M,aAAavM,GAAK6N,MAuB9B,OArBFpK,IAEDA,EAAUjE,KAAKiN,cAAce,EAAUG,EAAWf,IAGtDnJ,EAAQtI,OAAO2S,YAAcb,EACrBxJ,EAAAtI,OAAO4R,MAAQS,EAAWP,EAC1BxJ,EAAAtI,OAAO6R,OAASW,EAAYV,EACpCxJ,EAAQtI,OAAOuR,WAAac,EAC5B/J,EAAQtI,OAAOwR,YAAcgB,EAG7BlK,EAAQsK,MAAMC,EAAI,EAClBvK,EAAQsK,MAAME,EAAI,EAClBxK,EAAQsK,MAAMhB,MAAQO,EACtB7J,EAAQsK,MAAMf,OAASO,EAEvB9J,EAAQyK,YAEH,KAAA5B,aAAa7I,EAAQkG,KAAO3J,EAE1ByD,CAAA,CASJ0K,kBAAAA,CAAmB1K,EAAkBmJ,GAAY,GAEpD,MAAMzR,EAASsI,EAAQtI,OAEhB,OAAAqE,KAAK6N,kBAAkB5J,EAAQsJ,MAAOtJ,EAAQuJ,OAAQ7R,EAAO2S,YAAalB,EAAS,CAOvFwB,aAAAA,CAAcC,GAEjB,MAAMrO,EAAMR,KAAK8M,aAAa+B,EAAc1E,KAE5CnK,KAAK+M,aAAavM,GAAK3J,KAAKgY,EAAa,CAOtCC,KAAAA,CAAMC,GAGT,GADAA,GAAsC,IAApBA,EACdA,EAEW,UAAAxY,KAAKyJ,KAAK+M,aACrB,CACU,MAAAiC,EAAWhP,KAAK+M,aAAaxW,GAEnC,GAAIyY,EAEA,IAAK,IAAI1G,EAAI,EAAGA,EAAI0G,EAASzV,OAAQ+O,IAExB0G,EAAA1G,GAAGnI,SAAQ,EAE5B,CAIRH,KAAK+M,aAAe,CAAC,GAIhB,MAAAkC,EAAc,IAAIrC,C,uDCzK/B,MAAMsC,EAA0CzV,OAAAC,OAAO,MACjDyV,EAAwC1V,OAAAC,OAAO,MAErC,SAAAwG,EAAmBxH,EAAe0W,GAE1C,IAAA5Y,EAAK2Y,EAAOzW,GAYT,YAVI,IAAPlC,SAE0B,IAAtB0Y,EAASE,KAETF,EAASE,GAAW,GAGxBD,EAAOzW,GAASlC,EAAK0Y,EAASE,MAG3B5Y,CACX,C,uDCAY,IAAAyR,EAAA,CAAAoH,IAERA,EAAAA,EAAA,SAAQ,GAAR,QACAA,EAAAA,EAAA,UAAS,GAAT,SACAA,EAAAA,EAAA,QAAO,GAAP,OAJQA,GAAA,CAAApH,GAAA,G,uBCTI,SAAAqH,EAAoBC,EAAc9X,EAAmBkK,GAE3D,MAAA6N,GAAUD,GAAQ,GAAM,KAAQ,IAEtC9X,EAAIkK,MAAqB,IAAP4N,GAAe,IAAOC,EACxC/X,EAAIkK,MAAe4N,GAAQ,EAAK,KAAQ,IAAOC,EAC/C/X,EAAIkK,MAAe4N,GAAQ,GAAM,KAAQ,IAAOC,EAChD/X,EAAIkK,KAAY6N,CACpB,C,sFCPO,MAAMC,EAANjQ,WAAAA,GAMH,KAAOkQ,WAAa,EACpB,KAAOC,UAAY,EAInB,KAAOpO,SAAW,EAClB,KAAOqO,QAAmB,KAC1B,KAAOC,MAAe,KAEtB,KAAOC,YAAqB,EAE5B,aAAIpE,GAAc,OAAO1L,KAAK+P,WAAWC,cAAA,CAElCC,cAAAA,CACHC,EACAC,EACAtX,EACAuX,GAGA,MAAMC,EAASrQ,KAAK+P,WACd9L,EAAUjE,KAAKiE,QAEfqM,EAAKD,EAAOE,eAEZtV,EAAIqV,EAAGrV,EACPC,EAAIoV,EAAGpV,EACPsV,EAAIF,EAAGE,EACPC,EAAIH,EAAGG,EACPC,EAAKJ,EAAGI,GACRC,EAAKL,EAAGK,GAERC,EAAS5Q,KAAK4Q,OAEdC,EAAKD,EAAOE,KACZC,EAAKH,EAAOI,KACZC,EAAKL,EAAOM,KACZC,EAAKP,EAAOQ,KAEZC,EAAMpN,EAAQoN,IAIdC,EAAOjB,EAAOkB,gBAEdC,EAAqBpB,GAAa,GAA0B,MAAnBpQ,KAAK8P,YAEpDI,EAAYrX,EAAQ,GAAMoC,EAAI8V,EAAOP,EAAIW,EAAMT,EAC/CR,EAAYrX,EAAQ,GAAM4X,EAAIU,EAAOjW,EAAI6V,EAAMJ,EAEnCT,EAAArX,EAAQ,GAAKwY,EAAII,GACjBvB,EAAArX,EAAQ,GAAKwY,EAAIK,GAElBvB,EAAAtX,EAAQ,GAAKyY,EACbnB,EAAAtX,EAAQ,GAAK2Y,EAGxBtB,EAAYrX,EAAQ,GAAMoC,EAAI4V,EAAOL,EAAIW,EAAMT,EAC/CR,EAAYrX,EAAQ,GAAM4X,EAAIU,EAAOjW,EAAI2V,EAAMF,EAEnCT,EAAArX,EAAQ,GAAKwY,EAAIM,GACjBzB,EAAArX,EAAQ,GAAKwY,EAAIO,GAElBzB,EAAAtX,EAAQ,IAAMyY,EACdnB,EAAAtX,EAAQ,IAAM2Y,EAGzBtB,EAAYrX,EAAQ,IAAOoC,EAAI4V,EAAOL,EAAIS,EAAMP,EAChDR,EAAYrX,EAAQ,IAAO4X,EAAIQ,EAAO/V,EAAI2V,EAAMF,EAEpCT,EAAArX,EAAQ,IAAMwY,EAAIQ,GAClB3B,EAAArX,EAAQ,IAAMwY,EAAIS,GAEnB3B,EAAAtX,EAAQ,IAAMyY,EACdnB,EAAAtX,EAAQ,IAAM2Y,EAGzBtB,EAAYrX,EAAQ,IAAOoC,EAAI8V,EAAOP,EAAIS,EAAMP,EAChDR,EAAYrX,EAAQ,IAAO4X,EAAIQ,EAAO/V,EAAI6V,EAAMJ,EAEpCT,EAAArX,EAAQ,IAAMwY,EAAIU,GAClB7B,EAAArX,EAAQ,IAAMwY,EAAIW,GAEnB7B,EAAAtX,EAAQ,IAAMyY,EACdnB,EAAAtX,EAAQ,IAAM2Y,CAAA,CAGtBS,SAAAA,CAAUC,EAA+BrZ,EAAesZ,GAE/CD,EAAArZ,GAASsZ,EAAgB,EACzBD,EAAArZ,EAAQ,GAAKsZ,EAAgB,EAC7BD,EAAArZ,EAAQ,GAAKsZ,EAAgB,EAE7BD,EAAArZ,EAAQ,GAAKsZ,EAAgB,EAC7BD,EAAArZ,EAAQ,GAAKsZ,EAAgB,EAC7BD,EAAArZ,EAAQ,GAAKsZ,EAAgB,EAGtCC,KAAAA,GAEHpS,KAAK+P,WAAa,KAClB/P,KAAKiE,QAAU,KACfjE,KAAK4P,QAAU,KACf5P,KAAK6P,MAAQ,KACb7P,KAAK4Q,OAAS,M","sources":["webpack://astar/../../../../../src/rendering/high-shader/compiler/utils/addBits.ts","webpack://astar/../../../../../src/rendering/high-shader/compiler/utils/compileHooks.ts","webpack://astar/../../../../../src/rendering/high-shader/compiler/utils/compileInputs.ts","webpack://astar/../../../../../src/rendering/high-shader/compiler/utils/compileOutputs.ts","webpack://astar/../../../../../src/rendering/high-shader/compiler/utils/injectBits.ts","webpack://astar/../../../../src/rendering/high-shader/compiler/compileHighShader.ts","webpack://astar/../../../src/rendering/high-shader/defaultProgramTemplate.ts","webpack://astar/../../../../src/rendering/high-shader/shader-bits/globalUniformsBit.ts","webpack://astar/../../../src/rendering/high-shader/compileHighShaderToProgram.ts","webpack://astar/../../../../src/rendering/high-shader/shader-bits/colorBit.ts","webpack://astar/../../../../src/rendering/high-shader/shader-bits/generateTextureBatchBit.ts","webpack://astar/../../../../src/rendering/high-shader/shader-bits/localUniformBit.ts","webpack://astar/../../../../src/rendering/high-shader/shader-bits/roundPixelsBit.ts","webpack://astar/../../../../../../src/rendering/renderers/gl/shader/program/getTestContext.ts","webpack://astar/../../../../../../src/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.ts","webpack://astar/../../../../../../src/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.ts","webpack://astar/../../../../../../src/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.ts","webpack://astar/../../../../../../src/rendering/renderers/gl/shader/program/preprocessors/insertVersion.ts","webpack://astar/../../../../../../src/rendering/renderers/gl/shader/program/preprocessors/setProgramName.ts","webpack://astar/../../../../../../src/rendering/renderers/gl/shader/program/preprocessors/stripVersion.ts","webpack://astar/../../../../../src/rendering/renderers/gl/shader/GlProgram.ts","webpack://astar/../../../../../../src/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.ts","webpack://astar/../../../../../../src/rendering/renderers/gpu/shader/utils/extractStructAndGroups.ts","webpack://astar/../../../../../src/rendering/renderers/shared/shader/const.ts","webpack://astar/../../../../../../src/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.ts","webpack://astar/../../../../../../src/rendering/renderers/gpu/shader/utils/generateLayoutHash.ts","webpack://astar/../../../../../../src/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.ts","webpack://astar/../../../../../src/rendering/renderers/gpu/shader/GpuProgram.ts","webpack://astar/../../../../../../src/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.ts","webpack://astar/../../../../../src/rendering/renderers/shared/shader/Shader.ts","webpack://astar/../../../../../../src/rendering/renderers/shared/shader/utils/getDefaultUniformValue.ts","webpack://astar/../../../../../src/rendering/renderers/shared/shader/UniformGroup.ts","webpack://astar/../../../../../src/rendering/renderers/shared/state/State.ts","webpack://astar/../../../../../src/rendering/renderers/shared/texture/TexturePool.ts","webpack://astar/../../../../../src/rendering/renderers/shared/utils/createIdFromString.ts","webpack://astar/../../../src/rendering/renderers/types.ts","webpack://astar/../../../../src/scene/graphics/gpu/colorToUniform.ts","webpack://astar/../../../src/scene/sprite/BatchableSprite.ts"],"sourcesContent":["import { warn } from '../../../../utils/logging/warn';\n\n/**\n * takes the HighFragment source parts and adds them to the hook hash\n * @param srcParts - the hash of hook arrays\n * @param parts - the code to inject into the hooks\n * @param name - optional the name of the part to add\n */\nexport function addBits(srcParts: Record<string, string>, parts: Record<string, string[]>, name?: string)\n{\n    if (srcParts)\n    {\n        for (const i in srcParts)\n        {\n            const id = i.toLocaleLowerCase();\n\n            const part = parts[id];\n\n            if (part)\n            {\n                let sanitisedPart = srcParts[i];\n\n                if (i === 'header')\n                {\n                    sanitisedPart = sanitisedPart\n                        .replace(/@in\\s+[^;]+;\\s*/g, '')\n                        .replace(/@out\\s+[^;]+;\\s*/g, '');\n                }\n\n                if (name)\n                {\n                    part.push(`//----${name}----//`);\n                }\n                part.push(sanitisedPart);\n            }\n\n            else\n            {\n                // #if _DEBUG\n                warn(`${i} placement hook does not exist in shader`);\n                // #endif\n            }\n        }\n    }\n}\n","export const findHooksRx = /\\{\\{(.*?)\\}\\}/g;\n\n/**\n * takes a program string and returns an hash mapping the hooks to empty arrays\n * @param programSrc - the program containing hooks\n */\nexport function compileHooks(programSrc: string): Record<string, string[]>\n{\n    const parts: Record<string, string[]> = {};\n\n    const partMatches = programSrc\n        .match(findHooksRx)\n        ?.map((hook) => hook.replace(/[{()}]/g, '')) ?? [];\n\n    partMatches.forEach((hook) =>\n    {\n        parts[hook] = [];\n    });\n\n    return parts;\n}\n","function extractInputs(fragmentSource: string, out: string[])\n{\n    let match;\n    const regex = /@in\\s+([^;]+);/g;\n\n    while ((match = regex.exec(fragmentSource)) !== null)\n    {\n        out.push(match[1]);\n    }\n}\n\nexport function compileInputs(fragments: any[], template: string, sort = false)\n{\n    // get all the inputs from the fragments..\n    const results: string[] = [];\n\n    extractInputs(template, results);\n\n    fragments.forEach((fragment) =>\n    {\n        if (fragment.header)\n        {\n            extractInputs(fragment.header, results);\n        }\n    });\n\n    // build the input:\n    const mainInput = results;\n\n    if (sort)\n    {\n        mainInput.sort();\n    }\n\n    const finalString = mainInput\n        .map((inValue, i) => `       @location(${i}) ${inValue},`)\n        .join('\\n');\n\n    // Remove lines from original string\n    let cleanedString = template.replace(/@in\\s+[^;]+;\\s*/g, '');\n\n    cleanedString = cleanedString.replace('{{in}}', `\\n${finalString}\\n`);\n\n    return cleanedString;\n}\n","function extractOutputs(fragmentSource: string, out: string[])\n{\n    let match;\n    const regex = /@out\\s+([^;]+);/g;\n\n    while ((match = regex.exec(fragmentSource)) !== null)\n    {\n        out.push(match[1]);\n    }\n}\n\nfunction extractVariableName(value: string)\n{\n    const regex = /\\b(\\w+)\\s*:/g;\n\n    const match = regex.exec(value);\n\n    return match ? match[1] : '';\n}\n\nfunction stripVariable(value: string)\n{\n    const regex = /@.*?\\s+/g;\n\n    return value.replace(regex, '');\n}\n\nexport function compileOutputs(fragments: any[], template: string)\n{\n    // get all the inputs from the fragments..\n    const results: string[] = [];\n\n    extractOutputs(template, results);\n\n    fragments.forEach((fragment) =>\n    {\n        if (fragment.header)\n        {\n            extractOutputs(fragment.header, results);\n        }\n    });\n\n    let index = 0;\n\n    // generate the output struct\n    const mainStruct = results\n        .sort()\n        .map((inValue) =>\n        {\n            if (inValue.indexOf('builtin') > -1)\n            {\n                return inValue;\n            }\n\n            return `@location(${index++}) ${inValue}`;\n        })\n        .join(',\\n');\n\n    // generate the variables we will set:\n    const mainStart = results\n        .sort()\n        .map((inValue) => `       var ${stripVariable(inValue)};`)\n        .join('\\n');\n\n    // generate the return object\n    const mainEnd = `return VSOutput(\n                ${results\n        .sort()\n        .map((inValue) => ` ${extractVariableName(inValue)}`)\n        .join(',\\n')});`;\n\n    // Remove lines from original string\n    let compiledCode = template.replace(/@out\\s+[^;]+;\\s*/g, '');\n\n    compiledCode = compiledCode.replace('{{struct}}', `\\n${mainStruct}\\n`);\n    compiledCode = compiledCode.replace('{{start}}', `\\n${mainStart}\\n`);\n    compiledCode = compiledCode.replace('{{return}}', `\\n${mainEnd}\\n`);\n\n    return compiledCode;\n}\n","/**\n * takes a shader src and replaces any hooks with the HighFragment code.\n * @param templateSrc - the program src template\n * @param fragmentParts - the fragments to inject\n */\nexport function injectBits(templateSrc: string, fragmentParts: Record<string, string[]>): string\n{\n    let out = templateSrc;\n\n    for (const i in fragmentParts)\n    {\n        const parts = fragmentParts[i];\n\n        const toInject = parts.join('\\n');\n\n        if (toInject.length)\n        {\n            out = out.replace(`{{${i}}}`, `//-----${i} START-----//\\n${parts.join('\\n')}\\n//----${i} FINISH----//`);\n        }\n\n        else\n        {\n            out = out.replace(`{{${i}}}`, '');\n        }\n    }\n\n    return out;\n}\n","import { addBits } from './utils/addBits';\nimport { compileHooks } from './utils/compileHooks';\nimport { compileInputs } from './utils/compileInputs';\nimport { compileOutputs } from './utils/compileOutputs';\nimport { injectBits } from './utils/injectBits';\n\nimport type { HighShaderBit, HighShaderSource } from './types';\n\n/** A high template consists of vertex and fragment source */\nexport interface HighShaderTemplate\n{\n    name?: string;\n    fragment: string;\n    vertex: string;\n}\n\nexport interface CompileHighShaderOptions\n{\n    template: HighShaderTemplate;\n    bits: HighShaderBit[];\n}\n\nconst cacheMap: {[key: string]: HighShaderSource} = Object.create(null);\nconst bitCacheMap: Map<HighShaderBit, number> = new Map();\n\nlet CACHE_UID = 0;\n\n/**\n * This function will take a HighShader template, some High fragments and then merge them in to a shader source.\n * @param options\n * @param options.template\n * @param options.bits\n */\nexport function compileHighShader({\n    template,\n    bits\n}: CompileHighShaderOptions): HighShaderSource\n{\n    const cacheId = generateCacheId(template, bits);\n\n    if (cacheMap[cacheId]) return cacheMap[cacheId];\n\n    const { vertex, fragment } = compileInputsAndOutputs(template, bits);\n\n    cacheMap[cacheId] = compileBits(vertex, fragment, bits);\n\n    return cacheMap[cacheId];\n}\n\nexport function compileHighShaderGl({\n    template,\n    bits\n}: CompileHighShaderOptions): HighShaderSource\n{\n    const cacheId = generateCacheId(template, bits);\n\n    if (cacheMap[cacheId]) return cacheMap[cacheId];\n\n    cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);\n\n    return cacheMap[cacheId];\n}\n\nfunction compileInputsAndOutputs(template: HighShaderTemplate, bits: HighShaderBit[])\n{\n    const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v) => !!v);\n    const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v) => !!v);\n\n    // WebGPU compile inputs and outputs..\n    let compiledVertex = compileInputs(vertexFragments, template.vertex, true);\n\n    compiledVertex = compileOutputs(vertexFragments, compiledVertex);\n\n    const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);\n\n    return {\n        vertex: compiledVertex,\n        fragment: compiledFragment,\n    };\n}\n\nfunction generateCacheId(template: HighShaderTemplate, bits: HighShaderBit[]): string\n{\n    return bits\n        .map((highFragment) =>\n        {\n            if (!bitCacheMap.has(highFragment))\n            {\n                bitCacheMap.set(highFragment, CACHE_UID++);\n            }\n\n            return bitCacheMap.get(highFragment);\n        })\n        .sort((a, b) => a - b)\n        .join('-') + template.vertex + template.fragment;\n}\n\nfunction compileBits(vertex: string, fragment: string, bits: HighShaderBit[])\n{\n    const vertexParts = compileHooks(vertex);\n    const fragmentParts = compileHooks(fragment);\n\n    bits.forEach((shaderBit) =>\n    {\n        addBits(shaderBit.vertex, vertexParts, shaderBit.name);\n        addBits(shaderBit.fragment, fragmentParts, shaderBit.name);\n    });\n\n    return {\n        vertex: injectBits(vertex, vertexParts),\n        fragment: injectBits(fragment, fragmentParts),\n    };\n}\n","const vertexGPUTemplate = /* wgsl */`\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n        \n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n       \n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n`;\n\nconst fragmentGPUTemplate = /* wgsl */`\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n   \n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n        \n        {{start}}\n\n        var outColor:vec4<f32>;\n      \n        {{main}}\n        \n        return outColor * vColor;\n      };\n`;\n\nconst vertexGlTemplate = /* glsl */`\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n        \n        {{start}}\n        \n        vColor = vec4(1.);\n        \n        {{main}}\n        \n        vUV = uv;\n        \n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n`;\n\nconst fragmentGlTemplate = /* glsl */`\n   \n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n        \n        {{start}}\n\n        vec4 outColor;\n      \n        {{main}}\n        \n        finalColor = outColor * vColor;\n    }\n`;\n\nexport {\n    fragmentGlTemplate,\n    fragmentGPUTemplate,\n    vertexGlTemplate,\n    vertexGPUTemplate\n};\n","export const globalUniformsBit = {\n    name: 'global-uniforms-bit',\n    vertex: {\n        header: /* wgsl */`\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        `\n    }\n};\n\nexport const globalUniformsUBOBitGl = {\n    name: 'global-uniforms-ubo-bit',\n    vertex: {\n        header: /* glsl */`\n          uniform globalUniforms {\n            mat3 uProjectionMatrix;\n            mat3 uWorldTransformMatrix;\n            vec4 uWorldColorAlpha;\n            vec2 uResolution;\n          };\n        `\n    }\n};\n\nexport const globalUniformsBitGl = {\n    name: 'global-uniforms-bit',\n    vertex: {\n        header: /* glsl */`\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        `\n    }\n\n};\n","import { GlProgram } from '../renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../renderers/gpu/shader/GpuProgram';\nimport { compileHighShader, compileHighShaderGl } from './compiler/compileHighShader';\nimport { fragmentGlTemplate, fragmentGPUTemplate, vertexGlTemplate, vertexGPUTemplate } from './defaultProgramTemplate';\nimport { globalUniformsBit, globalUniformsBitGl } from './shader-bits/globalUniformsBit';\n\nimport type { HighShaderBit } from './compiler/types';\n\nexport function compileHighShaderGpuProgram({ bits, name }: {bits: HighShaderBit[], name: string}): GpuProgram\n{\n    const source = compileHighShader({\n        template: {\n            fragment: fragmentGPUTemplate,\n            vertex: vertexGPUTemplate,\n        },\n        bits: [\n            globalUniformsBit,\n            ...bits,\n        ]\n    });\n\n    return GpuProgram.from({\n        name,\n        vertex: {\n            source: source.vertex,\n            entryPoint: 'main',\n        },\n        fragment: {\n            source: source.fragment,\n            entryPoint: 'main',\n        },\n    });\n}\n\nexport function compileHighShaderGlProgram({ bits, name }: {bits: HighShaderBit[], name: string}): GlProgram\n{\n    return new GlProgram({\n        name,\n        ...compileHighShaderGl({\n            template: {\n                vertex: vertexGlTemplate,\n                fragment: fragmentGlTemplate,\n            },\n            bits: [\n                globalUniformsBitGl,\n                ...bits,\n            ]\n        })\n    });\n}\n","export const colorBit = {\n    name: 'color-bit',\n    vertex: {\n        header: /* wgsl */`\n            @in aColor: vec4<f32>;\n        `,\n        main: /* wgsl */`\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\n\nexport const colorBitGl = {\n    name: 'color-bit',\n    vertex: {\n        header: /* glsl */`\n            in vec4 aColor;\n        `,\n        main: /* glsl */`\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\n","import type { HighShaderBit } from '../compiler/types';\n\nconst textureBatchBitGpuCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateBindingSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('@group(1) @binding(0) var textureSource1: texture_2d<f32>;');\n        src.push('@group(1) @binding(1) var textureSampler1: sampler;');\n    }\n    else\n    {\n        let bindingIndex = 0;\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n        }\n    }\n\n    return src.join('\\n');\n}\n\nfunction generateSampleSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);');\n    }\n    else\n    {\n        src.push('switch vTextureId {');\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            if (i === maxTextures - 1)\n            {\n                src.push(`  default:{`);\n            }\n            else\n            {\n                src.push(`  case ${i}:{`);\n            }\n            src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n            src.push(`      break;}`);\n        }\n\n        src.push(`}`);\n    }\n\n    return src.join('\\n');\n}\n\nexport function generateTextureBatchBit(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGpuCache[maxTextures])\n    {\n        textureBatchBitGpuCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                @in @interpolate(flat) vTextureId: u32;\n    \n                ${generateBindingSrc(16)}\n            `,\n                main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n    \n                ${generateSampleSrc(16)}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGpuCache[maxTextures];\n}\n\nconst textureBatchBitGlCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateSampleGlSrc(maxTextures: number): string\n{\n    const src = [];\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        if (i > 0)\n        {\n            src.push('else');\n        }\n\n        if (i < maxTextures - 1)\n        {\n            src.push(`if(vTextureId < ${i}.5)`);\n        }\n\n        src.push('{');\n        src.push(`\\toutColor = texture(uTextures[${i}], vUV);`);\n        src.push('}');\n    }\n\n    return src.join('\\n');\n}\n\nexport function generateTextureBatchBitGl(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGlCache[maxTextures])\n    {\n        textureBatchBitGlCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n              \n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                in float vTextureId;\n    \n                uniform sampler2D uTextures[${maxTextures}];\n              \n            `,\n                main: `\n    \n                ${generateSampleGlSrc(16)}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGlCache[maxTextures];\n}\n","export const localUniformBit = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* wgsl */`\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n};\n\n// TODO this works, but i think down the road it will be better to manage groups automatically if there are clashes\nexport const localUniformBitGroup2 = {\n    ...localUniformBit,\n    vertex: {\n        ...localUniformBit.vertex,\n        // replace the group!\n        header: localUniformBit.vertex.header.replace('group(1)', 'group(2)'),\n    }\n};\n\nexport const localUniformBitGl = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* glsl */`\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n};\n","export const roundPixelsBit = {\n    name: 'round-pixels-bit',\n    vertex: {\n        header: /* wgsl */`\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> \n            {\n                return (floor((position * 0.5 + 0.5) * targetSize) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\n\nexport const roundPixelsBitGl = {\n    name: 'round-pixels-bit',\n    vertex: {\n        header: /* glsl */`   \n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {       \n                return (floor((position * 0.5 + 0.5) * targetSize) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\n\n","import { DOMAdapter } from '../../../../../environment/adapter';\n\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\n\nlet context: GlRenderingContext;\n\n/**\n * returns a little WebGL context to use for program inspection.\n * @static\n * @private\n * @returns {WebGLRenderingContext} a gl context to test with\n */\nexport function getTestContext(): GlRenderingContext\n{\n    if (!context || context?.isContextLost())\n    {\n        const canvas = DOMAdapter.get().createCanvas();\n\n        context = canvas.getContext('webgl', {}) as GlRenderingContext;\n    }\n\n    return context;\n}\n","import { getTestContext } from './getTestContext';\n\nimport type { PRECISION } from '../const';\n\nlet maxFragmentPrecision: PRECISION;\n\nexport function getMaxFragmentPrecision(): PRECISION\n{\n    if (!maxFragmentPrecision)\n    {\n        maxFragmentPrecision = 'mediump';\n        const gl = getTestContext();\n\n        if (gl)\n        {\n            if (gl.getShaderPrecisionFormat)\n            {\n                const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n\n                maxFragmentPrecision = shaderFragment.precision ? 'highp' : 'mediump';\n            }\n        }\n    }\n\n    return maxFragmentPrecision;\n}\n","export function addProgramDefines(src: string, isES300: boolean, isFragment?: boolean)\n{\n    if (isES300) return src;\n\n    if (isFragment)\n    {\n        src = src.replace('out vec4 finalColor;', '');\n\n        return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in varying\n        #define finalColor gl_FragColor\n        #define texture texture2D\n        #endif\n        ${src}\n        `;\n    }\n\n    return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in attribute\n        #define out varying\n        #endif\n        ${src}\n        `;\n}\n","import type { PRECISION } from '../../const';\n\ninterface EnsurePrecisionOptions\n{\n    requestedVertexPrecision: PRECISION;\n    requestedFragmentPrecision: PRECISION;\n    maxSupportedVertexPrecision: PRECISION;\n    maxSupportedFragmentPrecision: PRECISION;\n}\n\n/**\n * Sets the float precision on the shader, ensuring the device supports the request precision.\n * If the precision is already present, it just ensures that the device is able to handle it.\n * @param src\n * @param options\n * @param options.requestedVertexPrecision\n * @param options.requestedFragmentPrecision\n * @param options.maxSupportedVertexPrecision\n * @param options.maxSupportedFragmentPrecision\n * @param isFragment\n * @private\n */\nexport function ensurePrecision(\n    src: string,\n    options: EnsurePrecisionOptions,\n    isFragment: boolean,\n): string\n{\n    const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;\n\n    if (src.substring(0, 9) !== 'precision')\n    {\n        // no precision supplied, so PixiJS will add the requested level.\n        let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;\n\n        // If highp is requested but not supported, downgrade precision to a level all devices support.\n        if (precision === 'highp' && maxSupportedPrecision !== 'highp')\n        {\n            precision = 'mediump';\n        }\n\n        return `precision ${precision} float;\\n${src}`;\n    }\n    else if (maxSupportedPrecision !== 'highp' && src.substring(0, 15) === 'precision highp')\n    {\n        // precision was supplied, but at a level this device does not support, so downgrading to mediump.\n        return src.replace('precision highp', 'precision mediump');\n    }\n\n    return src;\n}\n","export function insertVersion(src: string, isES300: boolean): string\n{\n    if (!isES300) return src;\n\n    return `#version 300 es\\n${src}`;\n}\n","const fragmentNameCache: { [key: string]: number } = {};\nconst VertexNameCache: { [key: string]: number } = {};\n\nexport function setProgramName(src: string, { name = `pixi-program` }: { name: string; }, isFragment = true)\n{\n    name = name.replace(/\\s+/g, '-');\n\n    name += isFragment ? '-fragment' : '-vertex';\n\n    const nameCache = isFragment ? fragmentNameCache : VertexNameCache;\n\n    if (nameCache[name])\n    {\n        nameCache[name]++;\n        name += `-${nameCache[name]}`;\n    }\n    else\n    {\n        nameCache[name] = 1;\n    }\n\n    // if it already contains the define return\n    if (src.indexOf('#define SHADER_NAME') !== -1) return src;\n\n    const shaderName = `#define SHADER_NAME ${name}`;\n\n    return `${shaderName}\\n${src}`;\n}\n","export function stripVersion(src: string, isES300: boolean): string\n{\n    if (!isES300) return src;\n\n    return src.replace('#version 300 es', '');\n}\n","import { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { getMaxFragmentPrecision } from './program/getMaxFragmentPrecision';\nimport { addProgramDefines } from './program/preprocessors/addProgramDefines';\nimport { ensurePrecision } from './program/preprocessors/ensurePrecision';\nimport { insertVersion } from './program/preprocessors/insertVersion';\nimport { setProgramName } from './program/preprocessors/setProgramName';\nimport { stripVersion } from './program/preprocessors/stripVersion';\n\nimport type { TypedArray } from '../../shared/buffer/Buffer';\nimport type { ExtractedAttributeData } from './program/extractAttributesFromGlProgram';\n\nexport interface GlAttributeData\n{\n    type: string;\n    size: number;\n    location: number;\n    name: string;\n}\n\nexport interface GlUniformData\n{\n    name: string;\n    index: number;\n    type: string;\n    size: number;\n    isArray: boolean;\n    value: any;\n}\n\nexport interface GlUniformBlockData\n{\n    index: number;\n    name: string;\n    size: number;\n    value?: TypedArray;\n}\n\n/**\n * The options for the gl program\n * @memberof rendering\n */\nexport interface GlProgramOptions\n{\n    /** The fragment glsl shader source. */\n    fragment: string;\n    /** The vertex glsl shader source. */\n    vertex: string;\n    /** the name of the program, defaults to 'pixi-program' */\n    name?: string;\n    /** the preferred vertex precision for the shader, this may not be used if the device does not support it  */\n    preferredVertexPrecision?: string;\n    /** the preferred fragment precision for the shader, this may not be used if the device does not support it  */\n    preferredFragmentPrecision?: string;\n}\n\nconst processes: Record<string, ((source: string, options: any, isFragment?: boolean) => string)> = {\n    // strips any version headers..\n    stripVersion,\n    // adds precision string if not already present\n    ensurePrecision,\n    // add some defines if WebGL1 to make it more compatible with WebGL2 shaders\n    addProgramDefines,\n    // add the program name to the shader\n    setProgramName,\n    // add the version string to the shader header\n    insertVersion,\n};\n\nconst programCache: Record<string, GlProgram> = Object.create(null);\n\n/**\n * A wrapper for a WebGL Program. You can create one and then pass it to a shader.\n * This will manage the WebGL program that is compiled and uploaded to the GPU.\n *\n * To get the most out of this class, you should be familiar with glsl shaders and how they work.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLProgram\n * @example\n *\n * // Create a new program\n * const program = new GlProgram({\n *   vertex: '...',\n *   fragment: '...',\n * });\n *\n *\n * There are a few key things that pixi shader will do for you automatically:\n * <br>\n * - If no precision is provided in the shader, it will be injected into the program source for you.\n * This precision will be taken form the options provided, if none is provided,\n * then the program will default to the defaultOptions.\n * <br>\n * - It will inject the program name into the shader source if none is provided.\n * <br>\n *  - It will set the program version to 300 es.\n *\n * For optimal usage and best performance, its best to reuse programs as much as possible.\n * You should use the {@link GlProgram.from} helper function to create programs.\n * @class\n * @memberof rendering\n */\nexport class GlProgram\n{\n    /** The default options used by the program. */\n    public static defaultOptions: Partial<GlProgramOptions> = {\n        preferredVertexPrecision: 'highp',\n        preferredFragmentPrecision: 'mediump',\n    };\n\n    /** the fragment glsl shader source. */\n    public readonly fragment?: string;\n    /** the vertex glsl shader source */\n    public readonly vertex?: string;\n    /**\n     * attribute data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     * @ignore\n     */\n    public _attributeData: Record<string, ExtractedAttributeData>;\n    /**\n     * uniform data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     * @ignore\n     */\n    public _uniformData: Record<string, GlUniformData>;\n    /**\n     * uniform data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     * @ignore\n     */\n    public _uniformBlockData: Record<string, GlUniformBlockData>;\n    /** details on how to use this program with transform feedback */\n    public transformFeedbackVaryings?: {names: string[], bufferMode: 'separate' | 'interleaved'};\n    /**\n     * the key that identifies the program via its source vertex + fragment\n     * @internal\n     * @ignore\n     */\n    public readonly _key: number;\n\n    /**\n     * Creates a shiny new GlProgram. Used by WebGL renderer.\n     * @param options - The options for the program.\n     */\n    constructor(options: GlProgramOptions)\n    {\n        options = { ...GlProgram.defaultOptions, ...options };\n\n        // only need to check one as they both need to be the same or\n        // errors ensue!\n        const isES300 = options.fragment.indexOf('#version 300 es') !== -1;\n\n        const preprocessorOptions = {\n            stripVersion: isES300,\n            ensurePrecision: {\n                requestedFragmentPrecision: options.preferredFragmentPrecision,\n                requestedVertexPrecision: options.preferredVertexPrecision,\n                maxSupportedVertexPrecision: 'highp',\n                maxSupportedFragmentPrecision: getMaxFragmentPrecision(),\n            },\n            setProgramName: {\n                name: options.name,\n            },\n            addProgramDefines: isES300,\n            insertVersion: isES300\n        };\n\n        let fragment = options.fragment;\n        let vertex = options.vertex;\n\n        Object.keys(processes).forEach((processKey) =>\n        {\n            const processOptions = preprocessorOptions[processKey as keyof typeof preprocessorOptions];\n\n            fragment = processes[processKey](fragment, processOptions, true);\n            vertex = processes[processKey](vertex, processOptions, false);\n        });\n\n        this.fragment = fragment;\n        this.vertex = vertex;\n\n        this._key = createIdFromString(`${this.vertex}:${this.fragment}`, 'gl-program');\n    }\n\n    /** destroys the program */\n    public destroy(): void\n    {\n        (this.fragment as null) = null;\n        (this.vertex as null) = null;\n\n        this._attributeData = null;\n        this._uniformData = null;\n        this._uniformBlockData = null;\n\n        this.transformFeedbackVaryings = null;\n    }\n\n    /**\n     * Helper function that creates a program for a given source.\n     * It will check the program cache if the program has already been created.\n     * If it has that one will be returned, if not a new one will be created and cached.\n     * @param options - The options for the program.\n     * @returns A program using the same source\n     */\n    public static from(options: GlProgramOptions): GlProgram\n    {\n        const key = `${options.vertex}:${options.fragment}`;\n\n        if (!programCache[key])\n        {\n            programCache[key] = new GlProgram(options);\n        }\n\n        return programCache[key];\n    }\n}\n","import { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { ExtractedAttributeData } from '../../../gl/shader/program/extractAttributesFromGlProgram';\nimport type { VertexFormat } from '../../../shared/geometry/const';\nimport type { ProgramSource } from '../GpuProgram';\n\nconst WGSL_TO_VERTEX_TYPES: Record<string, VertexFormat> = {\n\n    f32:  'float32',\n    'vec2<f32>': 'float32x2',\n    'vec3<f32>': 'float32x3',\n    'vec4<f32>': 'float32x4',\n    vec2f: 'float32x2',\n    vec3f: 'float32x3',\n    vec4f: 'float32x4',\n\n    i32: 'sint32',\n    'vec2<i32>': 'sint32x2',\n    'vec3<i32>': 'sint32x3',\n    'vec4<i32>': 'sint32x4',\n\n    u32: 'uint32',\n    'vec2<u32>': 'uint32x2',\n    'vec3<u32>': 'uint32x3',\n    'vec4<u32>': 'uint32x4',\n\n    bool: 'uint32',\n    'vec2<bool>': 'uint32x2',\n    'vec3<bool>': 'uint32x3',\n    'vec4<bool>': 'uint32x4',\n};\n\nexport function extractAttributesFromGpuProgram(\n    { source, entryPoint }: ProgramSource\n): Record<string, ExtractedAttributeData>\n{\n    const results: Record<string, ExtractedAttributeData> = {};\n\n    // Step 1: Find the start of the mainVert function using string methods\n    const mainVertStart = source.indexOf(`fn ${entryPoint}`);\n\n    if (mainVertStart !== -1)\n    {\n        // Step 2: Find the index of the next '->' after the start of the mainVert function\n        const arrowFunctionStart = source.indexOf('->', mainVertStart);\n\n        if (arrowFunctionStart !== -1)\n        {\n            const functionArgsSubstring = source.substring(mainVertStart, arrowFunctionStart);\n\n            // Apply the inputs regex directly to the trimmed string\n            const inputsRegex = /@location\\((\\d+)\\)\\s+([a-zA-Z0-9_]+)\\s*:\\s*([a-zA-Z0-9_<>]+)(?:,|\\s|$)/g;\n            let match;\n\n            while ((match = inputsRegex.exec(functionArgsSubstring)) !== null)\n            {\n                const format = WGSL_TO_VERTEX_TYPES[match[3] as VertexFormat] ?? 'float32';\n\n                results[match[2]] = {\n                    location: parseInt(match[1], 10),\n                    format,\n                    stride: getAttributeInfoFromFormat(format).stride,\n                    offset: 0,\n                    instance: false,\n                    start: 0,\n                };\n            }\n        }\n    }\n\n    return results;\n}\n","export interface StructsAndGroups\n{\n    groups: {\n        group: number;\n        binding: number;\n        name: string;\n        isUniform: boolean;\n        type: string;\n    }[];\n    structs: {\n        name: string;\n        members: Record<string, string>;\n    }[];\n}\n\nexport function extractStructAndGroups(wgsl: string): StructsAndGroups\n{\n    // Patterns for parsing the WGSL file\n    const linePattern = /(^|[^/])@(group|binding)\\(\\d+\\)[^;]+;/g;\n    const groupPattern = /@group\\((\\d+)\\)/;\n    const bindingPattern = /@binding\\((\\d+)\\)/;\n    const namePattern = /var(<[^>]+>)? (\\w+)/;\n    const typePattern = /:\\s*(\\w+)/;\n    const structPattern = /struct\\s+(\\w+)\\s*{([^}]+)}/g;\n    const structMemberPattern = /(\\w+)\\s*:\\s*([\\w\\<\\>]+)/g;\n    const structName = /struct\\s+(\\w+)/;\n\n    // Find the @group and @binding annotations\n    const groups = wgsl.match(linePattern)?.map((item) => ({\n        group: parseInt(item.match(groupPattern)[1], 10),\n        binding: parseInt(item.match(bindingPattern)[1], 10),\n        name: item.match(namePattern)[2],\n        isUniform: item.match(namePattern)[1] === '<uniform>',\n        type: item.match(typePattern)[1],\n    }));\n\n    if (!groups)\n    {\n        return {\n            groups: [],\n            structs: [],\n        };\n    }\n\n    // Find the structs\n    const structs = wgsl\n        .match(structPattern)\n        ?.map((struct) =>\n        {\n            const name = struct.match(structName)[1];\n            const members = struct.match(structMemberPattern).reduce((acc: Record<string, string>, member) =>\n            {\n                const [name, type] = member.split(':');\n\n                acc[name.trim()] = type.trim();\n\n                return acc;\n            }, {});\n\n            if (!members)\n            {\n                return null;\n            }\n\n            return { name, members };\n            // Only include the structs mentioned in the @group/@binding annotations\n        })\n        .filter(({ name }) => groups.some((group) => group.type === name)) ?? [];\n\n    return {\n        groups,\n        structs,\n    };\n}\n","export enum ShaderStage\n    {\n    VERTEX = 1,\n    FRAGMENT = 2,\n    COMPUTE = 4\n}\n","import { ShaderStage } from '../../../shared/shader/const';\n\nimport type { ProgramPipelineLayoutDescription } from '../GpuProgram';\nimport type { StructsAndGroups } from './extractStructAndGroups';\n\nexport function generateGpuLayoutGroups({ groups }: StructsAndGroups): ProgramPipelineLayoutDescription\n{\n    const layout: ProgramPipelineLayoutDescription = [];\n\n    for (let i = 0; i < groups.length; i++)\n    {\n        const group = groups[i];\n\n        if (!layout[group.group])\n        {\n            layout[group.group] = [];\n        }\n\n        if (group.isUniform)\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,\n                buffer: {\n                    type: 'uniform'\n                }\n            });\n        }\n        else if (group.type === 'sampler')\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.FRAGMENT,\n                sampler: {\n                    type: 'filtering'\n                }\n            });\n        }\n        else if (group.type === 'texture_2d')\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.FRAGMENT,\n                texture: {\n                    sampleType: 'float',\n                    viewDimension: '2d',\n                    multisampled: false,\n                }\n            });\n        }\n    }\n\n    return layout;\n}\n","import type { ProgramLayout } from '../GpuProgram';\nimport type { StructsAndGroups } from './extractStructAndGroups';\n\nexport function generateLayoutHash({ groups }: StructsAndGroups): ProgramLayout\n{\n    const layout: ProgramLayout = [];\n\n    for (let i = 0; i < groups.length; i++)\n    {\n        const group = groups[i];\n\n        if (!layout[group.group])\n        {\n            layout[group.group] = {};\n        }\n\n        layout[group.group][group.name] = group.binding;\n    }\n\n    return layout;\n}\n","import type { StructsAndGroups } from './extractStructAndGroups';\n\nexport function removeStructAndGroupDuplicates(\n    vertexStructsAndGroups: StructsAndGroups,\n    fragmentStructsAndGroups: StructsAndGroups\n)\n{\n    const structNameSet = new Set();\n    const dupeGroupKeySet = new Set();\n\n    const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs]\n        .filter((struct) =>\n        {\n            if (structNameSet.has(struct.name))\n            {\n                return false;\n            }\n            structNameSet.add(struct.name);\n\n            return true;\n        });\n\n    const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups]\n        .filter((group) =>\n        {\n            const key = `${group.name}-${group.binding}`;\n\n            if (dupeGroupKeySet.has(key))\n            {\n                return false;\n            }\n            dupeGroupKeySet.add(key);\n\n            return true;\n        });\n\n    return { structs, groups };\n}\n","import { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { extractAttributesFromGpuProgram } from './utils/extractAttributesFromGpuProgram';\nimport { extractStructAndGroups } from './utils/extractStructAndGroups';\nimport { generateGpuLayoutGroups } from './utils/generateGpuLayoutGroups';\nimport { generateLayoutHash } from './utils/generateLayoutHash';\nimport { removeStructAndGroupDuplicates } from './utils/removeStructAndGroupDuplicates';\n\nimport type { ExtractedAttributeData } from '../../gl/shader/program/extractAttributesFromGlProgram';\nimport type { StructsAndGroups } from './utils/extractStructAndGroups';\n\n/**\n * a WebGPU descriptions of how the program is layed out\n * @see https://gpuweb.github.io/gpuweb/#gpupipelinelayout\n * @memberof rendering\n */\nexport type ProgramPipelineLayoutDescription = GPUBindGroupLayoutEntry[][];\n/**\n * a map the maps names of uniforms to group indexes\n * @memberof rendering\n */\nexport type ProgramLayout = Record<string, number>[];\n\n/**\n * the program source\n * @memberof rendering\n */\nexport interface ProgramSource\n{\n    /** The wgsl source code of the shader. */\n    source: string;\n    /** The main function to run in this shader */\n    entryPoint?: string;\n}\n\n/**\n * The options for the gpu program\n * @memberof rendering\n */\nexport interface GpuProgramOptions\n{\n    /**\n     * the name of the program, this is added to the label of the GPU Program created\n     * under the hood. Makes it much easier to debug!\n     */\n    name?: string;\n    /** The fragment glsl shader source. */\n    fragment?: ProgramSource;\n    /** The vertex glsl shader source. */\n    vertex?: ProgramSource;\n    /** The layout of the program. If not provided, it will be generated from the shader sources. */\n    layout?: ProgramLayout;\n    /** The gpu layout of the program. If not provided, it will be generated from the shader sources. */\n    gpuLayout?: ProgramPipelineLayoutDescription;\n}\n\nconst programCache: Record<string, GpuProgram> = Object.create(null);\n\n/**\n * A wrapper for a WebGPU Program, specifically designed for the WebGPU renderer.\n * This class facilitates the creation and management of shader code that integrates with the WebGPU pipeline.\n *\n * To leverage the full capabilities of this class, familiarity with WGSL shaders is recommended.\n * @see https://gpuweb.github.io/gpuweb/#index\n * @example\n *\n * // Create a new program\n * const program = new GpuProgram({\n *   vertex: {\n *    source: '...',\n *    entryPoint: 'main',\n *   },\n *   fragment:{\n *    source: '...',\n *    entryPoint: 'main',\n *   },\n * });\n *\n *\n * Note: Both fragment and vertex shader sources can coexist within a single WGSL source file\n * this can make things a bit simpler.\n *\n * For optimal usage and best performance, it help to reuse programs whenever possible.\n * The {@link GpuProgram.from} helper function is designed for this purpose, utilizing an\n * internal cache to efficiently manage and retrieve program instances.\n * By leveraging this function, you can significantly reduce overhead and enhance the performance of your rendering pipeline.\n *\n * An important distinction between WebGL and WebGPU regarding program data retrieval:\n * While WebGL allows extraction of program information directly from its compiled state,\n * WebGPU does not offer such a capability. Therefore, in the context of WebGPU, we're required\n * to manually extract the program layout information from the source code itself.\n * @memberof rendering\n */\nexport class GpuProgram\n{\n    /** The fragment glsl shader source. */\n    public readonly fragment?: ProgramSource;\n    /** The vertex glsl shader source */\n    public readonly vertex?: ProgramSource;\n\n    /**\n     * Mapping of uniform names to group indexes for organizing shader program uniforms.\n     * Automatically generated from shader sources if not provided.\n     * @example\n     * // Assuming a shader with two uniforms, `u_time` and `u_resolution`, grouped respectively:\n     * [\n     *   { \"u_time\": 0 },\n     *   { \"u_resolution\": 1 }\n     * ]\n     */\n    public readonly layout: ProgramLayout;\n\n    /**\n     * Configuration for the WebGPU bind group layouts, detailing resource organization for the shader.\n     * Generated from shader sources if not explicitly provided.\n     * @example\n     * // Assuming a shader program that requires two bind groups:\n     * [\n     *   // First bind group layout entries\n     *   [{ binding: 0, visibility: GPUShaderStage.VERTEX, type: \"uniform-buffer\" }],\n     *   // Second bind group layout entries\n     *   [{ binding: 1, visibility: GPUShaderStage.FRAGMENT, type: \"sampler\" },\n     *    { binding: 2, visibility: GPUShaderStage.FRAGMENT, type: \"sampled-texture\" }]\n     * ]\n     */\n    public readonly gpuLayout: ProgramPipelineLayoutDescription;\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public _layoutKey = 0;\n\n    /** the structs and groups extracted from the shader sources */\n    public readonly structsAndGroups: StructsAndGroups;\n    /**\n     * the name of the program, this is added to the label of the GPU Program created under the hood.\n     * Makes it much easier to debug!\n     */\n    public readonly name: string;\n    private _attributeData: Record<string, ExtractedAttributeData>;\n\n    /** if true, the program will automatically assign global uniforms to group[0] */\n    public autoAssignGlobalUniforms: boolean;\n    /** if true, the program will automatically assign local uniforms to group[1] */\n    public autoAssignLocalUniforms: boolean;\n\n    /**\n     * Create a new GpuProgram\n     * @param options - The options for the gpu program\n     */\n    constructor(options: GpuProgramOptions)\n    {\n        const { fragment, vertex, layout, gpuLayout, name } = options;\n\n        this.name = name;\n\n        this.fragment = fragment;\n        this.vertex = vertex;\n\n        // TODO this should be cached - or dealt with at a system level.\n        if (fragment.source === vertex.source)\n        {\n            const structsAndGroups = extractStructAndGroups(fragment.source);\n\n            this.structsAndGroups = structsAndGroups;\n        }\n        else\n        {\n            const vertexStructsAndGroups = extractStructAndGroups(vertex.source);\n            const fragmentStructsAndGroups = extractStructAndGroups(fragment.source);\n\n            this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);\n        }\n\n        // todo layout\n        this.layout = layout ?? generateLayoutHash(this.structsAndGroups);\n\n        // struct properties!\n\n        this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(this.structsAndGroups);\n\n        this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== undefined);\n        this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== undefined);\n\n        this._generateProgramKey();\n    }\n\n    // TODO maker this pure\n    private _generateProgramKey()\n    {\n        const { vertex, fragment } = this;\n\n        const bigKey = vertex.source + fragment.source + vertex.entryPoint + fragment.entryPoint;\n\n        this._layoutKey = createIdFromString(bigKey, 'program');\n    }\n\n    get attributeData()\n    {\n        this._attributeData ??= extractAttributesFromGpuProgram(this.vertex);\n\n        return this._attributeData;\n    }\n    /** destroys the program */\n    public destroy(): void\n    {\n        (this.gpuLayout as null) = null;\n        (this.layout as null) = null;\n        (this.structsAndGroups as null) = null;\n        (this.fragment as null) = null;\n        (this.vertex as null) = null;\n    }\n\n    /**\n     * Helper function that creates a program for a given source.\n     * It will check the program cache if the program has already been created.\n     * If it has that one will be returned, if not a new one will be created and cached.\n     * @param options - The options for the program.\n     * @returns A program using the same source\n     */\n    public static from(options: GpuProgramOptions): GpuProgram\n    {\n        // eslint-disable-next-line max-len\n        const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;\n\n        if (!programCache[key])\n        {\n            programCache[key] = new GpuProgram(options);\n        }\n\n        return programCache[key];\n    }\n}\n\n","import type { VertexFormat } from '../const';\n\nconst attributeFormatData = {\n    uint8x2: { size: 2, stride: 2, normalised: false },\n    uint8x4: { size: 4, stride: 4, normalised: false },\n    sint8x2: { size: 2, stride: 2, normalised: false },\n    sint8x4: { size: 4, stride: 4, normalised: false },\n    unorm8x2: { size: 2, stride: 2, normalised: true },\n    unorm8x4: { size: 4, stride: 4, normalised: true },\n    snorm8x2: { size: 2, stride: 2, normalised: true },\n    snorm8x4: { size: 4, stride: 4, normalised: true },\n    uint16x2: { size: 2, stride: 4, normalised: false },\n    uint16x4: { size: 4, stride: 8, normalised: false },\n    sint16x2: { size: 2, stride: 4, normalised: false },\n    sint16x4: { size: 4, stride: 8, normalised: false },\n    unorm16x2: { size: 2, stride: 4, normalised: true },\n    unorm16x4: { size: 4, stride: 8, normalised: true },\n    snorm16x2: { size: 2, stride: 4, normalised: true },\n    snorm16x4: { size: 4, stride: 8, normalised: true },\n    float16x2: { size: 2, stride: 4, normalised: false },\n    float16x4: { size: 4, stride: 8, normalised: false },\n    float32: { size: 1, stride: 4, normalised: false },\n    float32x2: { size: 2, stride: 8, normalised: false },\n    float32x3: { size: 3, stride: 12, normalised: false },\n    float32x4: { size: 4, stride: 16, normalised: false },\n    uint32: { size: 1, stride: 4, normalised: false },\n    uint32x2: { size: 2, stride: 8, normalised: false },\n    uint32x3: { size: 3, stride: 12, normalised: false },\n    uint32x4: { size: 4, stride: 16, normalised: false },\n    sint32: { size: 1, stride: 4, normalised: false },\n    sint32x2: { size: 2, stride: 8, normalised: false },\n    sint32x3: { size: 3, stride: 12, normalised: false },\n    sint32x4: { size: 4, stride: 16, normalised: false },\n};\n\nexport function getAttributeInfoFromFormat(format: VertexFormat): { size: number; stride: number; normalised: boolean }\n{\n    return attributeFormatData[format] ?? attributeFormatData.float32;\n}\n","/* eslint-disable no-new */\nimport EventEmitter from 'eventemitter3';\nimport { GlProgram } from '../../gl/shader/GlProgram';\nimport { BindGroup } from '../../gpu/shader/BindGroup';\nimport { GpuProgram } from '../../gpu/shader/GpuProgram';\nimport { RendererType } from '../../types';\nimport { UniformGroup } from './UniformGroup';\n\nimport type { GlProgramOptions } from '../../gl/shader/GlProgram';\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { GpuProgramOptions } from '../../gpu/shader/GpuProgram';\n\n/**\n * A record of {@link BindGroup}'s used by the shader.\n *\n * `Record<number, BindGroup>`\n * @memberof rendering\n */\nexport type ShaderGroups = Record<number, BindGroup>;\n\ninterface ShaderBase\n{\n    /** The WebGL program used by the WebGL renderer. */\n    glProgram?: GlProgram\n    /** The WebGPU program used by the WebGPU renderer. */\n    gpuProgram?: GpuProgram\n    /**\n     * A number that uses two bits on whether the shader is compatible with the WebGL renderer and/or the WebGPU renderer.\n     * 0b00 - not compatible with either\n     * 0b01 - compatible with WebGL\n     * 0b10 - compatible with WebGPU\n     * This is automatically set based on if a {@link GlProgram} or {@link GpuProgram} is provided.\n     */\n    compatibleRenderers?: number\n}\n\ninterface GlShaderWith extends ShaderBase\n{\n    /** The WebGL program used by the WebGL renderer. */\n    glProgram: GlProgram\n}\n\ninterface GpuShaderWith extends ShaderBase\n{\n    /** The WebGPU program used by the WebGPU renderer. */\n    gpuProgram: GpuProgram\n}\n\ninterface ShaderWithGroupsDescriptor\n{\n    /** A record of {@link BindGroup}'s used by the shader. */\n    groups: ShaderGroups;\n    /** an optional map of how to bind the groups. This is automatically generated by reading the WebGPU program */\n    groupMap?: Record<string, Record<string, any>>;\n}\n\ninterface ShaderWithResourcesDescriptor\n{\n    /**\n     * A key value of uniform resources used by the shader.\n     * Under the hood pixi will look at the provided shaders and figure out where\n     * the resources are mapped. Its up to you to make sure the resource key\n     * matches the uniform name in the webGPU program. WebGL is a little more forgiving!\n     */\n    resources?: Record<string, any>;\n}\n\ninterface GroupsData\n{\n    group: number\n    binding: number\n    name: string\n}\n\n/**\n * A descriptor for a shader\n * @memberof rendering\n */\nexport type ShaderWith = GlShaderWith | GpuShaderWith;\n\n/**\n * A descriptor for a shader with groups.\n * @memberof rendering\n */\nexport type ShaderWithGroups = ShaderWithGroupsDescriptor & ShaderWith;\nexport interface IShaderWithGroups extends ShaderWithGroupsDescriptor, ShaderBase {}\n\n/**\n * A descriptor for a shader with resources. This is an easier way to work with uniforms.\n * especially when you are not working with bind groups\n * @memberof rendering\n */\nexport type ShaderWithResources = ShaderWithResourcesDescriptor & ShaderWith;\nexport interface IShaderWithResources extends ShaderWithResourcesDescriptor, ShaderBase {}\n\nexport type ShaderDescriptor = ShaderWithGroups & ShaderWithResources;\n\ntype GlShaderFromWith = {\n    gpu?: GpuProgramOptions,\n    gl: GlProgramOptions\n};\ntype GpuShaderFromWith = {\n    gpu: GpuProgramOptions,\n    gl?: GlProgramOptions\n};\nexport type ShaderFromGroups = (GlShaderFromWith | GpuShaderFromWith) & Omit<ShaderWithGroups, 'glProgram' | 'gpuProgram'>;\nexport type ShaderFromResources = (GlShaderFromWith | GpuShaderFromWith)\n& Omit<ShaderWithResources, 'glProgram' | 'gpuProgram'>;\n\n/**\n * The Shader class is an integral part of the PixiJS graphics pipeline.\n * Central to rendering in PixiJS are two key elements: A [shader] and a [geometry].\n * The shader incorporates a {@link GlProgram} for WebGL or a {@link GpuProgram} for WebGPU,\n * instructing the respective technology on how to render the geometry.\n *\n * The primary goal of the Shader class is to offer a unified interface compatible with both WebGL and WebGPU.\n * When constructing a shader, you need to provide both a WebGL program and a WebGPU program due to the distinctions\n * between the two rendering engines. If only one is provided, the shader won't function with the omitted renderer.\n *\n * Both WebGL and WebGPU utilize the same resource object when passed into the shader.\n * Post-creation, the shader's interface remains consistent across both WebGL and WebGPU.\n * The sole distinction lies in whether a glProgram or a gpuProgram is employed.\n *\n * Modifying shader uniforms, which can encompass:\n *  - TextureSampler {@link TextureStyle}\n *  - TextureSource {@link TextureSource}\n *  - UniformsGroups {@link UniformGroup}\n * @example\n *\n * const shader = new Shader({\n *     glProgram: glProgram,\n *     gpuProgram: gpuProgram,\n *     resources: {\n *         uTexture: texture.source,\n *         uSampler: texture.sampler,\n *         uColor: [1, 0, 0, 1],\n *     },\n * });\n *\n * // update the uniforms\n * shader.resources.uColor[1] = 1;\n * shader.resources.uTexture = texture2.source;\n * @class\n * @memberof rendering\n */\nexport class Shader extends EventEmitter<{'destroy': Shader}>\n{\n    /** An instance of the GPU program used by the WebGPU renderer */\n    public gpuProgram: GpuProgram;\n    /** An instance of the GL program used by the WebGL renderer */\n    public glProgram: GlProgram;\n    /**\n     * A number that uses two bits on whether the shader is compatible with the WebGL renderer and/or the WebGPU renderer.\n     * 0b00 - not compatible with either\n     * 0b01 - compatible with WebGL\n     * 0b10 - compatible with WebGPU\n     * This is automatically set based on if a {@link GlProgram} or {@link GpuProgram} is provided.\n     */\n    public readonly compatibleRenderers: number;\n    /** */\n    public groups: Record<number, BindGroup>;\n    /** A record of the resources used by the shader. */\n    public resources: Record<string, any>;\n    /**\n     * A record of the uniform groups and resources used by the shader.\n     * This is used by WebGL renderer to sync uniform data.\n     * @internal\n     * @ignore\n     */\n    public _uniformBindMap: Record<number, Record<number, string>> = Object.create(null);\n    private readonly _ownedBindGroups: BindGroup[] = [];\n\n    /**\n     * Fired after rendering finishes.\n     * @event rendering.Shader#destroy\n     */\n\n    /**\n     * There are two ways to create a shader.\n     * one is to pass in resources which is a record of uniform groups and resources.\n     * another is to pass in groups which is a record of {@link BindGroup}s.\n     * this second method is really to make use of shared {@link BindGroup}s.\n     * For most cases you will want to use resources as they are easier to work with.\n     * USe Groups if you want to share {@link BindGroup}s between shaders.\n     * you cannot mix and match - either use resources or groups.\n     * @param {ShaderWithResourcesDescriptor} options - The options for the shader using ShaderWithResourcesDescriptor.\n     */\n    constructor(options: ShaderWithResources);\n    constructor(options: ShaderWithGroups);\n    constructor(options: ShaderDescriptor)\n    {\n        super();\n\n        /* eslint-disable prefer-const */\n        let {\n            gpuProgram,\n            glProgram,\n            groups,\n            resources,\n            compatibleRenderers,\n            groupMap\n        } = options;\n        /* eslint-enable prefer-const */\n\n        this.gpuProgram = gpuProgram;\n        this.glProgram = glProgram;\n\n        if (compatibleRenderers === undefined)\n        {\n            compatibleRenderers = 0;\n\n            if (gpuProgram)compatibleRenderers |= RendererType.WEBGPU;\n            if (glProgram)compatibleRenderers |= RendererType.WEBGL;\n        }\n\n        this.compatibleRenderers = compatibleRenderers;\n\n        const nameHash: Record<string, GroupsData> = {};\n\n        if (!resources && !groups)\n        {\n            resources = {};\n        }\n\n        if (resources && groups)\n        {\n            throw new Error('[Shader] Cannot have both resources and groups');\n        }\n        else if (!gpuProgram && groups && !groupMap)\n        {\n            throw new Error('[Shader] No group map or WebGPU shader provided - consider using resources instead.');\n        }\n        else if (!gpuProgram && groups && groupMap)\n        {\n            for (const i in groupMap)\n            {\n                for (const j in groupMap[i])\n                {\n                    const uniformName = groupMap[i][j];\n\n                    nameHash[uniformName] = {\n                        group: i as unknown as number,\n                        binding: j as unknown as number,\n                        name: uniformName\n                    };\n                }\n            }\n        }\n        else if (gpuProgram && groups && !groupMap)\n        {\n            const groupData = gpuProgram.structsAndGroups.groups;\n\n            groupMap = {};\n\n            groupData.forEach((data) =>\n            {\n                groupMap[data.group] = groupMap[data.group] || {};\n                groupMap[data.group][data.binding] = data.name;\n\n                nameHash[data.name] = data;\n            });\n        }\n        else if (resources)\n        {\n            if (!gpuProgram)\n            {\n                // build out a dummy bind group..\n                groupMap = {};\n                groups = {\n                    99: new BindGroup(),\n                };\n\n                this._ownedBindGroups.push(groups[99]);\n\n                let bindTick = 0;\n\n                for (const i in resources)\n                {\n                    // Yes i know this is a little strange, but wil line up the shaders neatly\n                    // basically we want to be driven by how webGPU does things.\n                    // so making a fake group will work and not affect gpu as it means no gpu shader was provided..\n                    nameHash[i] = { group: 99, binding: bindTick, name: i };\n\n                    groupMap[99] = groupMap[99] || {};\n                    groupMap[99][bindTick] = i;\n\n                    bindTick++;\n                }\n            }\n            else\n            {\n                const groupData = gpuProgram.structsAndGroups.groups;\n\n                groupMap = {};\n\n                groupData.forEach((data) =>\n                {\n                    groupMap[data.group] = groupMap[data.group] || {};\n                    groupMap[data.group][data.binding] = data.name;\n\n                    nameHash[data.name] = data;\n                });\n            }\n\n            groups = {};\n\n            for (const i in resources)\n            {\n                const name = i;\n                let value = resources[i];\n\n                if (!(value.source) && !(value as BindResource)._resourceType)\n                {\n                    value = new UniformGroup(value);\n                }\n\n                const data = nameHash[name];\n\n                if (data)\n                {\n                    if (!groups[data.group])\n                    {\n                        groups[data.group] = new BindGroup();\n\n                        this._ownedBindGroups.push(groups[data.group]);\n                    }\n\n                    groups[data.group].setResource(value, data.binding);\n                }\n            }\n        }\n\n        this.groups = groups;\n        this._uniformBindMap = groupMap;\n\n        this.resources = this._buildResourceAccessor(groups, nameHash);\n    }\n\n    /**\n     * Sometimes a resource group will be provided later (for example global uniforms)\n     * In such cases, this method can be used to let the shader know about the group.\n     * @param name - the name of the resource group\n     * @param groupIndex - the index of the group (should match the webGPU shader group location)\n     * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)\n     */\n    public addResource(name: string, groupIndex: number, bindIndex: number): void\n    {\n        this._uniformBindMap[groupIndex] ||= {};\n\n        this._uniformBindMap[groupIndex][bindIndex] ||= name;\n\n        if (!this.groups[groupIndex])\n        {\n            this.groups[groupIndex] = new BindGroup();\n            this._ownedBindGroups.push(this.groups[groupIndex]);\n        }\n    }\n\n    private _buildResourceAccessor(groups: ShaderGroups, nameHash: Record<string, GroupsData>)\n    {\n        const uniformsOut = {};\n\n        for (const i in nameHash)\n        {\n            const data = nameHash[i];\n\n            // add getter setter for uniforms\n            Object.defineProperty(uniformsOut, data.name, {\n                get()\n                {\n                    return groups[data.group].getResource(data.binding);\n                },\n                set(value)\n                {\n                    groups[data.group].setResource(value, data.binding);\n                }\n            });\n        }\n\n        return uniformsOut;\n    }\n\n    /**\n     * Use to destroy the shader when its not longer needed.\n     * It will destroy the resources and remove listeners.\n     * @param destroyPrograms - if the programs should be destroyed as well.\n     * Make sure its not being used by other shaders!\n     */\n    public destroy(destroyPrograms = false): void\n    {\n        this.emit('destroy', this);\n\n        if (destroyPrograms)\n        {\n            this.gpuProgram?.destroy();\n            this.glProgram?.destroy();\n        }\n\n        this.gpuProgram = null;\n        this.glProgram = null;\n\n        this.removeAllListeners();\n\n        this._uniformBindMap = null;\n\n        this._ownedBindGroups.forEach((bindGroup) =>\n        {\n            bindGroup.destroy();\n        });\n\n        (this._ownedBindGroups as null) = null;\n\n        this.resources = null;\n        this.groups = null;\n    }\n\n    /**\n     * A short hand function to create a shader based of a vertex and fragment shader.\n     * @param options\n     * @returns A shiny new PixiJS shader!\n     */\n    public static from(options: ShaderFromGroups): Shader;\n    public static from(options: ShaderFromResources): Shader;\n    public static from(options: ShaderFromGroups & ShaderFromResources): Shader\n    {\n        const { gpu, gl, ...rest } = options;\n\n        let gpuProgram: GpuProgram;\n        let glProgram: GlProgram;\n\n        if (gpu)\n        {\n            gpuProgram = GpuProgram.from(gpu);\n        }\n\n        if (gl)\n        {\n            glProgram = GlProgram.from(gl);\n        }\n\n        return new Shader({\n            gpuProgram,\n            glProgram,\n            ...rest\n        });\n    }\n}\n","/**\n * @method defaultValue\n * @param {string} type - Type of value\n * @param {number} size\n * @private\n */\nexport function getDefaultUniformValue(\n    type: string,\n    size: number\n): number | Float32Array | Int32Array | Uint32Array | boolean | boolean[]\n{\n    switch (type)\n    {\n        case 'f32':\n            return 0;\n\n        case 'vec2<f32>':\n            return new Float32Array(2 * size);\n\n        case 'vec3<f32>':\n            return new Float32Array(3 * size);\n\n        case 'vec4<f32>':\n            return new Float32Array(4 * size);\n        case 'mat2x2<f32>':\n            return new Float32Array([1, 0,\n                0, 1]);\n\n        case 'mat3x3<f32>':\n            return new Float32Array([1, 0, 0,\n                0, 1, 0,\n                0, 0, 1]);\n\n        case 'mat4x4<f32>':\n            return new Float32Array([1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1]);\n    }\n\n    return null;\n}\n","import { uid } from '../../../../utils/data/uid';\nimport { createIdFromString } from '../utils/createIdFromString';\nimport { getDefaultUniformValue } from './utils/getDefaultUniformValue';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { Buffer } from '../buffer/Buffer';\nimport type { UniformData } from './types';\n\ntype FLOPS<T = UniformData> = T extends { value: infer V } ? V : never;\n\n// TODO replace..T['value']\ntype ExtractUniformObject<T = Record<string, UniformData>> = {\n    [K in keyof T]: FLOPS<T[K]>;\n};\n\n/**\n * Uniform group options\n * @memberof rendering\n */\nexport type UniformGroupOptions = {\n    /**\n     * if true the UniformGroup is handled as an Uniform buffer object.\n     * This is the only way WebGPU can work with uniforms. WebGL2 can also use this.\n     * So don't set to true if you want to use WebGPU :D\n     */\n    ubo?: boolean;\n    /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n    isStatic?: boolean;\n};\n\n/**\n * Uniform group holds uniform map and some ID's for work\n *\n * `UniformGroup` has two modes:\n *\n * 1: Normal mode\n * Normal mode will upload the uniforms with individual function calls as required. This is the default mode\n * for WebGL rendering.\n *\n * 2: Uniform buffer mode\n * This mode will treat the uniforms as a uniform buffer. You can pass in either a buffer that you manually handle, or\n * or a generic object that PixiJS will automatically map to a buffer for you.\n * For maximum benefits, make Ubo UniformGroups static, and only update them each frame.\n * This is the only way uniforms can be used with WebGPU.\n *\n * Rules of UBOs:\n * - UBOs only work with WebGL2, so make sure you have a fallback!\n * - Only floats are supported (including vec[2,3,4], mat[2,3,4])\n * - Samplers cannot be used in ubo's (a GPU limitation)\n * - You must ensure that the object you pass in exactly matches in the shader ubo structure.\n * Otherwise, weirdness will ensue!\n * - The name of the ubo object added to the group must match exactly the name of the ubo in the shader.\n *\n * When declaring your uniform options, you ust parse in the value and the type of the uniform.\n * The types correspond to the WebGPU types {@link UNIFORM_TYPES}\n *\n Uniforms can be modified via the classes 'uniforms' property. It will contain all the uniforms declared in the constructor.\n *\n * ```glsl\n * // UBO in shader:\n * uniform myCoolData { // Declaring a UBO...\n *     mat4 uCoolMatrix;\n *     float uFloatyMcFloatFace;\n * };\n * ```\n *\n * ```js\n * // A new Uniform Buffer Object...\n * const myCoolData = new UniformGroup({\n *     uCoolMatrix: {value:new Matrix(), type: 'mat4<f32>'},\n *     uFloatyMcFloatFace: {value:23, type: 'f32'},\n * }}\n *\n * // modify the data\n * myCoolData.uniforms.uFloatyMcFloatFace = 42;\n * // Build a shader...\n * const shader = Shader.from(srcVert, srcFrag, {\n *     myCoolData // Name matches the UBO name in the shader. Will be processed accordingly.\n * })\n *\n *\n *  ```\n * @memberof rendering\n */\nexport class UniformGroup<UNIFORMS extends { [key: string]: UniformData } = any> implements BindResource\n{\n    /** The default options used by the uniform group. */\n    public static defaultOptions: UniformGroupOptions = {\n        /** if true the UniformGroup is handled as an Uniform buffer object. */\n        ubo: false,\n        /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n        isStatic: false,\n    };\n\n    /** used internally to know if a uniform group was used in the last render pass */\n    public _touched = 0;\n\n    /** a unique id for this uniform group used through the renderer */\n    public readonly uid = uid('uniform');\n    /** a resource type, used to identify how to handle it when its in a bind group / shader resource */\n    public _resourceType = 'uniformGroup';\n    /** the resource id used internally by the renderer to build bind group keys */\n    public _resourceId = uid('resource');\n    /** the structures of the uniform group */\n    public uniformStructures: UNIFORMS;\n    /** the uniforms as an easily accessible map of properties */\n    public uniforms: ExtractUniformObject<UNIFORMS>;\n    /** true if it should be used as a uniform buffer object */\n    public ubo: boolean;\n    /** an underlying buffer that will be uploaded to the GPU when using this UniformGroup */\n    public buffer?: Buffer;\n    /**\n     * if true, then you are responsible for when the data is uploaded to the GPU.\n     * otherwise, the data is reuploaded each frame.\n     */\n    public isStatic: boolean;\n    /** used ito identify if this is a uniform group */\n    public readonly isUniformGroup = true;\n    /**\n     * used to flag if this Uniform groups data is different from what it has stored in its buffer / on the GPU\n     * @internal\n     * @ignore\n     */\n    public _dirtyId = 0;\n    /**\n     * a signature string generated for internal use\n     * @internal\n     * @ignore\n     */\n    public readonly _signature: number;\n\n    /**\n     * Create a new Uniform group\n     * @param uniformStructures - The structures of the uniform group\n     * @param options - The optional parameters of this uniform group\n     */\n    constructor(uniformStructures: UNIFORMS, options?: UniformGroupOptions)\n    {\n        options = { ...UniformGroup.defaultOptions, ...options };\n\n        this.uniformStructures = uniformStructures;\n\n        const uniforms = {} as ExtractUniformObject<UNIFORMS>;\n\n        for (const i in uniformStructures)\n        {\n            const uniformData = uniformStructures[i] as UniformData;\n\n            uniformData.name = i;\n            uniformData.size = uniformData.size ?? 1;\n            uniformData.value ??= getDefaultUniformValue(uniformData.type, uniformData.size);\n\n            uniforms[i] = uniformData.value as ExtractUniformObject<UNIFORMS>[keyof UNIFORMS];\n        }\n\n        this.uniforms = uniforms;\n\n        this._dirtyId = 1;\n        this.ubo = options.ubo;\n        this.isStatic = options.isStatic;\n\n        this._signature = createIdFromString(Object.keys(uniforms).map(\n            (i) => `${i}-${(uniformStructures[i as keyof typeof uniformStructures] as UniformData).type}`\n        ).join('-'), 'uniform-group');\n    }\n\n    /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */\n    public update(): void\n    {\n        this._dirtyId++;\n        // dispatch...\n    }\n}\n","/* eslint-disable max-len */\nimport type { BLEND_MODES, CULL_MODES } from './const';\n\nconst blendModeIds = {\n    normal: 0,\n    add: 1,\n    multiply: 2,\n    screen: 3,\n    overlay: 4,\n    erase: 5,\n    'normal-npm': 6,\n    'add-npm': 7,\n    'screen-npm': 8,\n};\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\n\n/**\n * This is a WebGL state, and is is passed to {@link StateSystem}.\n *\n * Each mesh rendered may require WebGL to be in a different state.\n * For example you may want different blend mode or to enable polygon offsets\n * @memberof rendering\n */\nexport class State\n{\n    /**\n     * The data is a unique number based on the states settings.\n     * This lets us quickly compare states with a single number rather than looking\n     * at all the individual settings.\n     */\n    public data: number;\n    public _blendModeId: number;\n    private _blendMode: BLEND_MODES;\n    private _polygonOffset: number;\n\n    constructor()\n    {\n        this.data = 0;\n\n        this.blendMode = 'normal';\n        this.polygonOffset = 0;\n\n        this.blend = true;\n        this.depthMask = true;\n    }\n\n    /**\n     * Activates blending of the computed fragment color values.\n     * @default true\n     */\n    get blend(): boolean\n    {\n        return !!(this.data & (1 << BLEND));\n    }\n\n    set blend(value: boolean)\n    {\n        if (!!(this.data & (1 << BLEND)) !== value)\n        {\n            this.data ^= (1 << BLEND);\n        }\n    }\n\n    /**\n     * Activates adding an offset to depth values of polygon's fragments\n     * @default false\n     */\n    get offsets(): boolean\n    {\n        return !!(this.data & (1 << OFFSET));\n    }\n\n    set offsets(value: boolean)\n    {\n        if (!!(this.data & (1 << OFFSET)) !== value)\n        {\n            this.data ^= (1 << OFFSET);\n        }\n    }\n\n    /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */\n    set cullMode(value: CULL_MODES)\n    {\n        if (value === 'none')\n        {\n            this.culling = false;\n\n            return;\n        }\n\n        this.culling = true;\n        this.clockwiseFrontFace = value === 'front';\n    }\n\n    get cullMode(): CULL_MODES\n    {\n        if (!this.culling)\n        {\n            return 'none';\n        }\n\n        return this.clockwiseFrontFace ? 'front' : 'back';\n    }\n\n    /**\n     * Activates culling of polygons.\n     * @default false\n     */\n    get culling(): boolean\n    {\n        return !!(this.data & (1 << CULLING));\n    }\n\n    set culling(value: boolean)\n    {\n        if (!!(this.data & (1 << CULLING)) !== value)\n        {\n            this.data ^= (1 << CULLING);\n        }\n    }\n\n    /**\n     * Activates depth comparisons and updates to the depth buffer.\n     * @default false\n     */\n    get depthTest(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_TEST));\n    }\n\n    set depthTest(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_TEST)) !== value)\n        {\n            this.data ^= (1 << DEPTH_TEST);\n        }\n    }\n\n    /**\n     * Enables or disables writing to the depth buffer.\n     * @default true\n     */\n    get depthMask(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_MASK));\n    }\n\n    set depthMask(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_MASK)) !== value)\n        {\n            this.data ^= (1 << DEPTH_MASK);\n        }\n    }\n\n    /**\n     * Specifies whether or not front or back-facing polygons can be culled.\n     * @default false\n     */\n    get clockwiseFrontFace(): boolean\n    {\n        return !!(this.data & (1 << WINDING));\n    }\n\n    set clockwiseFrontFace(value: boolean)\n    {\n        if (!!(this.data & (1 << WINDING)) !== value)\n        {\n            this.data ^= (1 << WINDING);\n        }\n    }\n\n    /**\n     * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n     * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n     * @default 'normal'\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this._blendMode;\n    }\n\n    set blendMode(value: BLEND_MODES)\n    {\n        this.blend = (value !== 'none');\n        this._blendMode = value;\n        this._blendModeId = blendModeIds[value as keyof typeof blendModeIds] || 0;\n    }\n\n    /**\n     * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n     * @default 0\n     */\n    get polygonOffset(): number\n    {\n        return this._polygonOffset;\n    }\n\n    set polygonOffset(value: number)\n    {\n        this.offsets = !!value;\n        this._polygonOffset = value;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/core:State `\n            + `blendMode=${this.blendMode} `\n            + `clockwiseFrontFace=${this.clockwiseFrontFace} `\n            + `culling=${this.culling} `\n            + `depthMask=${this.depthMask} `\n            + `polygonOffset=${this.polygonOffset}`\n            + `]`;\n    }\n    // #endif\n\n    /**\n     * A quickly getting an instance of a State that is configured for 2d rendering.\n     * @returns a new State with values set for 2d rendering\n     */\n    public static for2d(): State\n    {\n        const state = new State();\n\n        state.depthTest = false;\n        state.blend = true;\n\n        return state;\n    }\n\n    public static default2d = State.for2d();\n}\n\n","import { nextPow2 } from '../../../../maths/misc/pow2';\nimport { TextureSource } from './sources/TextureSource';\nimport { Texture } from './Texture';\n\nimport type { TextureSourceOptions } from './sources/TextureSource';\n\nlet count = 0;\n\n/**\n * Texture pool, used by FilterSystem and plugins.\n *\n * Stores collection of temporary pow2 or screen-sized renderTextures\n *\n * If you use custom RenderTexturePool for your filters, you can use methods\n * `getFilterTexture` and `returnFilterTexture` same as in default pool\n * @memberof rendering\n * @name TexturePool\n */\nexport class TexturePoolClass\n{\n    /** The default options for texture pool */\n    public textureOptions: TextureSourceOptions;\n\n    /**\n     * Allow renderTextures of the same size as screen, not just pow2\n     *\n     * Automatically sets to true after `setScreenSize`\n     * @default false\n     */\n    public enableFullScreen: boolean;\n\n    private _texturePool: {[x in string | number]: Texture[]};\n    private _poolKeyHash: Record<number, number> = Object.create(null);\n\n    /**\n     * @param textureOptions - options that will be passed to BaseRenderTexture constructor\n     * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.\n     */\n    constructor(textureOptions?: TextureSourceOptions)\n    {\n        this._texturePool = {};\n        this.textureOptions = textureOptions || {};\n        this.enableFullScreen = false;\n    }\n\n    /**\n     * Creates texture with params that were specified in pool constructor.\n     * @param pixelWidth - Width of texture in pixels.\n     * @param pixelHeight - Height of texture in pixels.\n     * @param antialias\n     */\n    public createTexture(pixelWidth: number, pixelHeight: number, antialias: boolean): Texture\n    {\n        const textureSource = new TextureSource({\n            ...this.textureOptions,\n\n            width: pixelWidth,\n            height: pixelHeight,\n            resolution: 1,\n            antialias,\n            autoGarbageCollect: true,\n        });\n\n        return new Texture({\n            source: textureSource,\n            label: `texturePool_${count++}`,\n        });\n    }\n\n    /**\n     * Gets a Power-of-Two render texture or fullScreen texture\n     * @param frameWidth - The minimum width of the render texture.\n     * @param frameHeight - The minimum height of the render texture.\n     * @param resolution - The resolution of the render texture.\n     * @param antialias\n     * @returns The new render texture.\n     */\n    public getOptimalTexture(frameWidth: number, frameHeight: number, resolution = 1, antialias: boolean): Texture\n    {\n        let po2Width = Math.ceil((frameWidth * resolution) - 1e-6);\n        let po2Height = Math.ceil((frameHeight * resolution) - 1e-6);\n\n        po2Width = nextPow2(po2Width);\n        po2Height = nextPow2(po2Height);\n\n        const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);\n\n        if (!this._texturePool[key])\n        {\n            this._texturePool[key] = [];\n        }\n\n        let texture = this._texturePool[key].pop();\n\n        if (!texture)\n        {\n            texture = this.createTexture(po2Width, po2Height, antialias);\n        }\n\n        texture.source._resolution = resolution;\n        texture.source.width = po2Width / resolution;\n        texture.source.height = po2Height / resolution;\n        texture.source.pixelWidth = po2Width;\n        texture.source.pixelHeight = po2Height;\n\n        // fit the layout to the requested original size\n        texture.frame.x = 0;\n        texture.frame.y = 0;\n        texture.frame.width = frameWidth;\n        texture.frame.height = frameHeight;\n\n        texture.updateUvs();\n\n        this._poolKeyHash[texture.uid] = key;\n\n        return texture;\n    }\n\n    /**\n     * Gets extra texture of the same size as input renderTexture\n     * @param texture - The texture to check what size it is.\n     * @param antialias - Whether to use antialias.\n     * @returns A texture that is a power of two\n     */\n    public getSameSizeTexture(texture: Texture, antialias = false)\n    {\n        const source = texture.source;\n\n        return this.getOptimalTexture(texture.width, texture.height, source._resolution, antialias);\n    }\n\n    /**\n     * Place a render texture back into the pool.\n     * @param renderTexture - The renderTexture to free\n     */\n    public returnTexture(renderTexture: Texture): void\n    {\n        const key = this._poolKeyHash[renderTexture.uid];\n\n        this._texturePool[key].push(renderTexture);\n    }\n\n    /**\n     * Clears the pool.\n     * @param destroyTextures - Destroy all stored textures.\n     */\n    public clear(destroyTextures?: boolean): void\n    {\n        destroyTextures = destroyTextures !== false;\n        if (destroyTextures)\n        {\n            for (const i in this._texturePool)\n            {\n                const textures = this._texturePool[i];\n\n                if (textures)\n                {\n                    for (let j = 0; j < textures.length; j++)\n                    {\n                        textures[j].destroy(true);\n                    }\n                }\n            }\n        }\n\n        this._texturePool = {};\n    }\n}\n\nexport const TexturePool = new TexturePoolClass();\n","const idCounts: Record<string, number> = Object.create(null);\nconst idHash: Record<string, number> = Object.create(null);\n\nexport function createIdFromString(value: string, groupId: string): number\n{\n    let id = idHash[value];\n\n    if (id === undefined)\n    {\n        if (idCounts[groupId] === undefined)\n        {\n            idCounts[groupId] = 1;\n        }\n\n        idHash[value] = id = idCounts[groupId]++;\n    }\n\n    return id;\n}\n","import type { ICanvas } from '../../environment/canvas/ICanvas';\nimport type { WebGLOptions, WebGLPipes, WebGLRenderer } from './gl/WebGLRenderer';\nimport type { WebGPUOptions, WebGPUPipes, WebGPURenderer } from './gpu/WebGPURenderer';\n\n/** A generic renderer. */\nexport type Renderer<T extends ICanvas = HTMLCanvasElement> = WebGLRenderer<T> | WebGPURenderer<T>;\nexport type RenderPipes = WebGLPipes | WebGPUPipes;\nexport interface RendererOptions extends WebGLOptions, WebGPUOptions {}\n\n/* eslint-disable @typescript-eslint/indent */\n/**\n * Ids for the different render types.\n * The idea is that you can use bitwise operations to filter weather or not you want to do somthing in a certain render type.\n * Filters for example can be compatible for both webGL or WebGPU but not compatible with canvas.\n * So internally if it works with both we set filter.compatibleRenderers = RendererType.WEBGL | RendererType.WEBGPU\n * if it only works with webgl we set filter.compatibleRenderers = RendererType.WEBGL\n *\n */\nexport enum RendererType\n{\n    WEBGL = 0b01,\n    WEBGPU = 0b10,\n    BOTH = 0b11\n}\n\nexport type GpuPowerPreference = 'low-power' | 'high-performance';\n","export function colorToUniform(rgb: number, alpha: number, out: Float32Array, offset: number)\n{\n    // TODO replace with Color..\n    out[offset++] = ((rgb >> 16) & 0xFF) / 255;\n    out[offset++] = ((rgb >> 8) & 0xFF) / 255;\n    out[offset++] = (rgb & 0xFF) / 255;\n    out[offset++] = alpha;\n}\n\nexport function color32BitToUniform(abgr: number, out: Float32Array, offset: number)\n{\n    const alpha = ((abgr >> 24) & 0xFF) / 255;\n\n    out[offset++] = ((abgr & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 8) & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 16) & 0xFF) / 255) * alpha;\n    out[offset++] = alpha;\n}\n","import type { Batch, BatchableObject, Batcher } from '../../rendering/batcher/shared/Batcher';\nimport type { IndexBufferArray } from '../../rendering/renderers/shared/geometry/Geometry';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../container/bounds/Bounds';\nimport type { Container } from '../container/Container';\n\n/**\n * A batchable sprite object.\n * @ignore\n */\nexport class BatchableSprite implements BatchableObject\n{\n    public indexStart: number;\n    public renderable: Container;\n\n    // batch specific..\n    public vertexSize = 4;\n    public indexSize = 6;\n    public texture: Texture;\n\n    public textureId: number;\n    public location = 0; // location in the buffer\n    public batcher: Batcher = null;\n    public batch: Batch = null;\n    public bounds: BoundsData;\n    public roundPixels: 0 | 1 = 0;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n\n    public packAttributes(\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number,\n    )\n    {\n        const sprite = this.renderable;\n        const texture = this.texture;\n\n        const wt = sprite.groupTransform;\n\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const bounds = this.bounds;\n\n        const w0 = bounds.maxX;\n        const w1 = bounds.minX;\n        const h0 = bounds.maxY;\n        const h1 = bounds.minY;\n\n        const uvs = texture.uvs;\n\n        // _ _ _ _\n        // a b g r\n        const argb = sprite.groupColorAlpha;\n\n        const textureIdAndRound = (textureId << 16) | (this.roundPixels & 0xFFFF);\n\n        float32View[index + 0] = (a * w1) + (c * h1) + tx;\n        float32View[index + 1] = (d * h1) + (b * w1) + ty;\n\n        float32View[index + 2] = uvs.x0;\n        float32View[index + 3] = uvs.y0;\n\n        uint32View[index + 4] = argb;\n        uint32View[index + 5] = textureIdAndRound;\n\n        // xy\n        float32View[index + 6] = (a * w0) + (c * h1) + tx;\n        float32View[index + 7] = (d * h1) + (b * w0) + ty;\n\n        float32View[index + 8] = uvs.x1;\n        float32View[index + 9] = uvs.y1;\n\n        uint32View[index + 10] = argb;\n        uint32View[index + 11] = textureIdAndRound;\n\n        // xy\n        float32View[index + 12] = (a * w0) + (c * h0) + tx;\n        float32View[index + 13] = (d * h0) + (b * w0) + ty;\n\n        float32View[index + 14] = uvs.x2;\n        float32View[index + 15] = uvs.y2;\n\n        uint32View[index + 16] = argb;\n        uint32View[index + 17] = textureIdAndRound;\n\n        // xy\n        float32View[index + 18] = (a * w1) + (c * h0) + tx;\n        float32View[index + 19] = (d * h0) + (b * w1) + ty;\n\n        float32View[index + 20] = uvs.x3;\n        float32View[index + 21] = uvs.y3;\n\n        uint32View[index + 22] = argb;\n        uint32View[index + 23] = textureIdAndRound;\n    }\n\n    public packIndex(indexBuffer: IndexBufferArray, index: number, indicesOffset: number)\n    {\n        indexBuffer[index] = indicesOffset + 0;\n        indexBuffer[index + 1] = indicesOffset + 1;\n        indexBuffer[index + 2] = indicesOffset + 2;\n\n        indexBuffer[index + 3] = indicesOffset + 0;\n        indexBuffer[index + 4] = indicesOffset + 2;\n        indexBuffer[index + 5] = indicesOffset + 3;\n    }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this.batcher = null;\n        this.batch = null;\n        this.bounds = null;\n    }\n}\n"],"names":["addBits","srcParts","parts","name","i","id","toLocaleLowerCase","part","sanitisedPart","replace","push","warn","findHooksRx","compileHooks","programSrc","partMatches","match","map","hook","forEach","extractInputs","fragmentSource","out","regex","exec","compileInputs","fragments","template","sort","results","fragment","header","mainInput","finalString","inValue","join","cleanedString","extractOutputs","extractVariableName","value","stripVariable","compileOutputs","index","mainStruct","indexOf","mainStart","mainEnd","compiledCode","injectBits","templateSrc","fragmentParts","toInject","length","cacheMap","Object","create","bitCacheMap","Map","CACHE_UID","compileHighShader","bits","cacheId","generateCacheId","vertex","compileInputsAndOutputs","compileBits","compileHighShaderGl","vertexFragments","shaderBit","filter","v","fragmentFragments","compiledVertex","compiledFragment","highFragment","has","set","get","a","b","vertexParts","vertexGPUTemplate","fragmentGPUTemplate","vertexGlTemplate","fragmentGlTemplate","globalUniformsBit","globalUniformsBitGl","compileHighShaderGpuProgram","source","GpuProgram","from","entryPoint","compileHighShaderGlProgram","GlProgram","colorBit","main","colorBitGl","textureBatchBitGpuCache","generateBindingSrc","maxTextures","src","bindingIndex","generateSampleSrc","generateTextureBatchBit","end","textureBatchBitGlCache","generateSampleGlSrc","generateTextureBatchBitGl","localUniformBit","localUniformBitGroup2","localUniformBitGl","roundPixelsBit","roundPixelsBitGl","context","maxFragmentPrecision","getTestContext","isContextLost","canvas","DOMAdapter","createCanvas","getContext","getMaxFragmentPrecision","gl","getShaderPrecisionFormat","shaderFragment","FRAGMENT_SHADER","HIGH_FLOAT","precision","addProgramDefines","isES300","isFragment","ensurePrecision","options","maxSupportedPrecision","maxSupportedFragmentPrecision","maxSupportedVertexPrecision","substring","requestedFragmentPrecision","requestedVertexPrecision","insertVersion","fragmentNameCache","VertexNameCache","setProgramName","nameCache","shaderName","stripVersion","processes","programCache","_GlProgram","constructor","defaultOptions","preprocessorOptions","preferredFragmentPrecision","preferredVertexPrecision","keys","processKey","processOptions","this","_key","createIdFromString","destroy","_attributeData","_uniformData","_uniformBlockData","transformFeedbackVaryings","key","WGSL_TO_VERTEX_TYPES","f32","vec2f","vec3f","vec4f","i32","u32","bool","extractAttributesFromGpuProgram","mainVertStart","arrowFunctionStart","functionArgsSubstring","inputsRegex","format","location","parseInt","stride","getAttributeInfoFromFormat","offset","instance","start","extractStructAndGroups","wgsl","linePattern","groupPattern","bindingPattern","namePattern","typePattern","structPattern","structMemberPattern","structName","groups","item","group","binding","isUniform","type","structs","struct","members","reduce","acc","member","name2","split","trim","some","ShaderStage","ShaderStage2","generateGpuLayoutGroups","layout","visibility","VERTEX","FRAGMENT","buffer","sampler","texture","sampleType","viewDimension","multisampled","generateLayoutHash","removeStructAndGroupDuplicates","vertexStructsAndGroups","fragmentStructsAndGroups","structNameSet","Set","dupeGroupKeySet","add","_layoutKey","gpuLayout","structsAndGroups","autoAssignGlobalUniforms","globalUniforms","autoAssignLocalUniforms","localUniforms","_generateProgramKey","bigKey","attributeData","attributeFormatData","uint8x2","size","normalised","uint8x4","sint8x2","sint8x4","unorm8x2","unorm8x4","snorm8x2","snorm8x4","uint16x2","uint16x4","sint16x2","sint16x4","unorm16x2","unorm16x4","snorm16x2","snorm16x4","float16x2","float16x4","float32","float32x2","float32x3","float32x4","uint32","uint32x2","uint32x3","uint32x4","sint32","sint32x2","sint32x3","sint32x4","Shader","EventEmitter","_uniformBindMap","_ownedBindGroups","gpuProgram","glProgram","resources","compatibleRenderers","groupMap","RendererType","WEBGPU","WEBGL","nameHash","Error","j","uniformName","groupData","data","BindGroup","bindTick","_resourceType","UniformGroup","setResource","_buildResourceAccessor","addResource","groupIndex","bindIndex","_a","_b","uniformsOut","defineProperty","getResource","destroyPrograms","emit","removeAllListeners","bindGroup","gpu","rest","getDefaultUniformValue","Float32Array","_UniformGroup","uniformStructures","_touched","uid","_resourceId","isUniformGroup","_dirtyId","uniforms","uniformData","ubo","isStatic","_signature","update","blendModeIds","normal","multiply","screen","overlay","erase","BLEND","OFFSET","CULLING","DEPTH_TEST","WINDING","DEPTH_MASK","_State","blendMode","polygonOffset","blend","depthMask","offsets","cullMode","culling","clockwiseFrontFace","depthTest","_blendMode","_blendModeId","_polygonOffset","toString","for2d","state","default2d","State","count","TexturePoolClass","textureOptions","_poolKeyHash","_texturePool","enableFullScreen","createTexture","pixelWidth","pixelHeight","antialias","textureSource","TextureSource","width","height","resolution","autoGarbageCollect","Texture","label","getOptimalTexture","frameWidth","frameHeight","po2Width","Math","ceil","po2Height","nextPow2","pop","_resolution","frame","x","y","updateUvs","getSameSizeTexture","returnTexture","renderTexture","clear","destroyTextures","textures","TexturePool","idCounts","idHash","groupId","RendererType2","color32BitToUniform","abgr","alpha","BatchableSprite","vertexSize","indexSize","batcher","batch","roundPixels","renderable","groupBlendMode","packAttributes","float32View","uint32View","textureId","sprite","wt","groupTransform","c","d","tx","ty","bounds","w0","maxX","w1","minX","h0","maxY","h1","minY","uvs","argb","groupColorAlpha","textureIdAndRound","x0","y0","x1","y1","x2","y2","x3","y3","packIndex","indexBuffer","indicesOffset","reset"],"sourceRoot":""}