{"version":3,"file":"js/816.51bfe72f.js","mappings":"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","sources":["webpack://astar/../../src/app/ResizePlugin.ts","webpack://astar/../../src/app/TickerPlugin.ts","webpack://astar/../../src/app/init.ts","webpack://astar/../../src/filters/FilterPipe.ts","webpack://astar/../../../../src/scene/container/bounds/getFastGlobalBounds.ts","webpack://astar/../../../../src/scene/container/bounds/getRenderableBounds.ts","webpack://astar/../../src/filters/FilterSystem.ts","webpack://astar/../../src/filters/init.ts","webpack://astar/../../../../../src/rendering/renderers/gl/shader/batchSamplersUniformGroup.ts","webpack://astar/../../../../../src/rendering/renderers/shared/texture/CanvasPool.ts","webpack://astar/../../../../src/scene/graphics/shared/GraphicsPipe.ts","webpack://astar/../../../src/scene/graphics/init.ts","webpack://astar/../../../../src/scene/mesh/shared/MeshPipe.ts","webpack://astar/../../../src/scene/mesh/init.ts","webpack://astar/../../../../src/scene/mesh/shared/BatchableMesh.ts","webpack://astar/../../../../src/scene/mesh/shared/MeshGeometry.ts","webpack://astar/../../../src/scene/mesh-plane/PlaneGeometry.ts","webpack://astar/../../../src/scene/sprite-nine-slice/NineSliceGeometry.ts","webpack://astar/../../../src/scene/sprite-nine-slice/NineSliceSpritePipe.ts","webpack://astar/../../../src/scene/sprite-nine-slice/init.ts","webpack://astar/../../../../src/scene/sprite-tiling/shader/tilingBit.ts","webpack://astar/../../../../src/scene/sprite-tiling/shader/TilingSpriteShader.ts","webpack://astar/../../../../src/scene/sprite-tiling/utils/QuadGeometry.ts","webpack://astar/../../../../src/scene/sprite-tiling/utils/setPositions.ts","webpack://astar/../../../../src/scene/sprite-tiling/utils/applyMatrix.ts","webpack://astar/../../../../src/scene/sprite-tiling/utils/setUvs.ts","webpack://astar/../../../src/scene/sprite-tiling/TilingSpritePipe.ts","webpack://astar/../../../src/scene/sprite-tiling/init.ts","webpack://astar/../../../src/scene/text-bitmap/AbstractBitmapFont.ts","webpack://astar/../../../../src/scene/text-bitmap/utils/resolveCharacters.ts","webpack://astar/../../../src/scene/text-bitmap/DynamicBitmapFont.ts","webpack://astar/../../../../src/scene/text-bitmap/utils/getBitmapTextLayout.ts","webpack://astar/../../../src/scene/text-bitmap/BitmapFontManager.ts","webpack://astar/../../../src/scene/text-bitmap/BitmapFont.ts","webpack://astar/../../../../src/scene/text-bitmap/asset/bitmapFontTextParser.ts","webpack://astar/../../../../src/scene/text-bitmap/asset/bitmapFontXMLParser.ts","webpack://astar/../../../../src/scene/text-bitmap/asset/bitmapFontXMLStringParser.ts","webpack://astar/../../../../src/scene/text-bitmap/asset/loadBitmapFont.ts","webpack://astar/../../../../src/scene/graphics/shared/Graphics.ts","webpack://astar/../../../../../src/scene/text/sdfShader/shader-bits/localUniformMSDFBit.ts","webpack://astar/../../../../../src/scene/text/sdfShader/shader-bits/mSDFBit.ts","webpack://astar/../../../../src/scene/text/sdfShader/SdfShader.ts","webpack://astar/../../../src/scene/text-bitmap/BitmapTextPipe.ts","webpack://astar/../../../src/scene/text-bitmap/init.ts","webpack://astar/../../../src/scene/text-html/HTMLTextPipe.ts","webpack://astar/../../../src/utils/browser/isSafari.ts","webpack://astar/../../../src/scene/text-html/HTMLTextRenderData.ts","webpack://astar/../../../../src/scene/text-html/utils/textStyleToCSS.ts","webpack://astar/../../../src/scene/text-html/HtmlTextStyle.ts","webpack://astar/../../../../src/scene/text-html/utils/extractFontFamilies.ts","webpack://astar/../../../../src/scene/text-html/utils/loadFontAsBase64.ts","webpack://astar/../../../../src/scene/text-html/utils/loadFontCSS.ts","webpack://astar/../../../../src/scene/text-html/utils/getFontCss.ts","webpack://astar/../../../../src/scene/text-html/utils/getSVGUrl.ts","webpack://astar/../../../../src/scene/text-html/utils/getTemporaryCanvasFromImage.ts","webpack://astar/../../../../src/scene/text-html/utils/loadSVGImage.ts","webpack://astar/../../../../src/scene/text-html/utils/measureHtmlText.ts","webpack://astar/../../../src/scene/text-html/HTMLTextSystem.ts","webpack://astar/../../../src/scene/text-html/init.ts","webpack://astar/../../../../../src/scene/text/canvas/utils/getCanvasFillStyle.ts","webpack://astar/../../../../src/scene/text/canvas/CanvasTextPipe.ts","webpack://astar/../../../src/utils/canvas/getCanvasBoundingBox.ts","webpack://astar/../../../../src/scene/text/canvas/CanvasTextSystem.ts","webpack://astar/../../../src/scene/text/init.ts","webpack://astar/../../../../src/scene/text/utils/getPo2TextureFromSource.ts"],"sourcesContent":["import { ExtensionType } from '../extensions/Extensions';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\nimport type { Renderer } from '../rendering/renderers/types';\n\ntype ResizeableRenderer = Pick<Renderer, 'resize'>;\n\n/**\n * Application options for the {@link app.ResizePlugin}.\n * @memberof app\n * @property {Window|HTMLElement} [resizeTo=window] - Element to automatically resize the renderer to.\n */\nexport interface ResizePluginOptions\n{\n    /**\n     * Element to automatically resize the renderer to.\n     * @memberof app.ApplicationOptions\n     */\n    resizeTo?: Window | HTMLElement;\n}\n\n/**\n * Middleware for Application's resize functionality.\n *\n * Adds the following methods to {@link app.Application}:\n * * {@link app.Application#resizeTo}\n * * {@link app.Application#resize}\n * * {@link app.Application#queueResize}\n * * {@link app.Application#cancelResize}\n * @example\n * import { extensions, ResizePlugin } from 'pixi.js';\n *\n * extensions.add(ResizePlugin);\n * @memberof app\n */\nexport class ResizePlugin\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n\n    public static resizeTo: Window | HTMLElement;\n    public static resize: () => void;\n    public static renderer: ResizeableRenderer;\n    public static queueResize: () => void;\n    public static render: () => void;\n    private static _resizeId: number;\n    private static _resizeTo: Window | HTMLElement;\n    private static _cancelResize: () => void;\n\n    /**\n     * Initialize the plugin with scope of application instance\n     * @static\n     * @private\n     * @param {object} [options] - See application options\n     */\n    public static init(options: ResizePluginOptions): void\n    {\n        Object.defineProperty(this, 'resizeTo',\n            /**\n             * The HTML element or window to automatically resize the\n             * renderer's view element to match width and height.\n             * @member {Window|HTMLElement}\n             * @name resizeTo\n             * @memberof app.Application#\n             */\n            {\n                set(dom: Window | HTMLElement)\n                {\n                    globalThis.removeEventListener('resize', this.queueResize);\n                    this._resizeTo = dom;\n                    if (dom)\n                    {\n                        globalThis.addEventListener('resize', this.queueResize);\n                        this.resize();\n                    }\n                },\n                get()\n                {\n                    return this._resizeTo;\n                },\n            });\n\n        /**\n         * Resize is throttled, so it's safe to call this multiple times per frame and it'll\n         * only be called once.\n         * @memberof app.Application#\n         * @method queueResize\n         * @private\n         */\n        this.queueResize = (): void =>\n        {\n            if (!this._resizeTo)\n            {\n                return;\n            }\n\n            this._cancelResize();\n\n            // // Throttle resize events per raf\n            this._resizeId = requestAnimationFrame(() => this.resize());\n        };\n\n        /**\n         * Cancel the resize queue.\n         * @memberof app.Application#\n         * @method cancelResize\n         * @private\n         */\n        this._cancelResize = (): void =>\n        {\n            if (this._resizeId)\n            {\n                cancelAnimationFrame(this._resizeId);\n                this._resizeId = null;\n            }\n        };\n\n        /**\n         * Execute an immediate resize on the renderer, this is not\n         * throttled and can be expensive to call many times in a row.\n         * Will resize only if `resizeTo` property is set.\n         * @memberof app.Application#\n         * @method resize\n         */\n        this.resize = (): void =>\n        {\n            if (!this._resizeTo)\n            {\n                return;\n            }\n\n            // clear queue resize\n            this._cancelResize();\n\n            let width: number;\n            let height: number;\n\n            // Resize to the window\n            if (this._resizeTo === globalThis.window)\n            {\n                width = globalThis.innerWidth;\n                height = globalThis.innerHeight;\n            }\n            // Resize to other HTML entities\n            else\n            {\n                const { clientWidth, clientHeight } = this._resizeTo as HTMLElement;\n\n                width = clientWidth;\n                height = clientHeight;\n            }\n\n            this.renderer.resize(width, height);\n            this.render();\n        };\n\n        // On resize\n        this._resizeId = null;\n        this._resizeTo = null;\n        this.resizeTo = options.resizeTo || null;\n    }\n\n    /**\n     * Clean up the ticker, scoped to application\n     * @static\n     * @private\n     */\n    public static destroy(): void\n    {\n        globalThis.removeEventListener('resize', this.queueResize);\n        this._cancelResize();\n        this._cancelResize = null;\n        this.queueResize = null;\n        this.resizeTo = null;\n        this.resize = null;\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\nimport { UPDATE_PRIORITY } from '../ticker/const';\nimport { Ticker } from '../ticker/Ticker';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Application options for the {@link app.TickerPluginOptions}.\n * @memberof app\n * @property {boolean} [autoStart=true] - Automatically starts the rendering after the construction.\n * **Note**: Setting this parameter to `false` does NOT stop the shared ticker even if you set\n * `options.sharedTicker` to `true` in case that it is already started. Stop it by your own.\n * @property {boolean} [sharedTicker=false] - Set`true` to use `Ticker.shared`, `false` to create new ticker.\n * If set to `false`, you cannot register a handler to occur before anything that runs on the shared ticker.\n * The system ticker will always run before both the shared ticker and the app ticker.\n */\nexport interface TickerPluginOptions\n{\n    /**\n     * Automatically starts the rendering after the construction.\n     *  **Note**: Setting this parameter to `false` does NOT stop the shared ticker even if you set\n     *  `options.sharedTicker` to `true` in case that it is already started. Stop it by your own.\n     * @memberof app.ApplicationOptions\n     * @default true\n     */\n    autoStart?: boolean;\n    /**\n     * Set`true` to use `Ticker.shared`, `false` to create new ticker.\n     *  If set to `false`, you cannot register a handler to occur before anything that runs on the shared ticker.\n     *  The system ticker will always run before both the shared ticker and the app ticker.\n     * @memberof app.ApplicationOptions\n     * @default false\n     */\n    sharedTicker?: boolean;\n}\n\n/**\n * Middleware for Application's {@link ticker.Ticker} functionality.\n *\n * Adds the following methods to {@link app.Application}:\n * * {@link app.Application#start}\n * * {@link app.Application#stop}\n * * {@link app.Application#ticker}\n * @example\n * import { extensions, TickerPlugin } from 'pixi.js';\n *\n * extensions.add(TickerPlugin);\n * @memberof app\n */\nexport class TickerPlugin\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n\n    public static start: () => void;\n    public static stop: () => void;\n    private static _ticker: Ticker;\n    public static ticker: Ticker;\n\n    /**\n     * Initialize the plugin with scope of application instance\n     * @static\n     * @private\n     * @param {object} [options] - See application options\n     */\n    public static init(options?: PixiMixins.ApplicationOptions): void\n    {\n        // Set default\n        options = Object.assign({\n            autoStart: true,\n            sharedTicker: false,\n        }, options);\n\n        // Create ticker setter\n        Object.defineProperty(this, 'ticker',\n            {\n                set(ticker)\n                {\n                    if (this._ticker)\n                    {\n                        this._ticker.remove(this.render, this);\n                    }\n                    this._ticker = ticker;\n                    if (ticker)\n                    {\n                        ticker.add(this.render, this, UPDATE_PRIORITY.LOW);\n                    }\n                },\n                get()\n                {\n                    return this._ticker;\n                },\n            });\n\n        /**\n         * Convenience method for stopping the render.\n         * @method\n         * @memberof app.Application\n         * @instance\n         */\n        this.stop = (): void =>\n        {\n            this._ticker.stop();\n        };\n\n        /**\n         * Convenience method for starting the render.\n         * @method\n         * @memberof app.Application\n         * @instance\n         */\n        this.start = (): void =>\n        {\n            this._ticker.start();\n        };\n\n        /**\n         * Internal reference to the ticker.\n         * @type {Ticker}\n         * @name _ticker\n         * @memberof app.Application#\n         * @private\n         */\n        this._ticker = null;\n\n        /**\n         * Ticker for doing render updates.\n         * @type {ticker.Ticker}\n         * @name ticker\n         * @memberof app.Application#\n         * @default Ticker.shared\n         */\n        this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();\n\n        // Start the rendering\n        if (options.autoStart)\n        {\n            this.start();\n        }\n    }\n\n    /**\n     * Clean up the ticker, scoped to application.\n     * @static\n     * @private\n     */\n    public static destroy(): void\n    {\n        if (this._ticker)\n        {\n            const oldTicker = this._ticker;\n\n            this.ticker = null;\n            oldTicker.destroy();\n        }\n    }\n}\n","import { extensions } from '../extensions/Extensions';\nimport { ResizePlugin } from './ResizePlugin';\nimport { TickerPlugin } from './TickerPlugin';\n\nextensions.add(ResizePlugin);\nextensions.add(TickerPlugin);\n","import { ExtensionType } from '../extensions/Extensions';\n\nimport type { InstructionSet } from '../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { Container } from '../scene/container/Container';\nimport type { Effect } from '../scene/container/Effect';\nimport type { FilterInstruction } from './FilterSystem';\n\n// eslint-disable-next-line max-len\nexport class FilterPipe implements InstructionPipe<FilterInstruction>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'filter',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(filterEffect: Effect, container: Container, instructionSet: InstructionSet): void\n    {\n        const renderPipes = this._renderer.renderPipes;\n\n        renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            canBundle: false,\n            action: 'pushFilter',\n            container,\n            filterEffect,\n        } as FilterInstruction);\n    }\n\n    public pop(_filterEffect: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            action: 'popFilter',\n            canBundle: false,\n        });\n    }\n\n    public execute(instruction: FilterInstruction)\n    {\n        if (instruction.action === 'pushFilter')\n        {\n            this._renderer.filter.push(instruction);\n        }\n        else if (instruction.action === 'popFilter')\n        {\n            this._renderer.filter.pop();\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n}\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { boundsPool } from './utils/matrixAndBoundsPool';\n\nimport type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Container } from '../Container';\nimport type { Bounds } from './Bounds';\n\n// TODO could we cache local bounds on the render groups?\n\nconst tempMatrix = new Matrix();\n\n/**\n * Does exactly the same as getGlobalBounds, but does instead makes use of transforming AABBs\n * of the various children within the scene graph. This is much faster, but less accurate.\n *\n * the result will never be smaller - only ever slightly larger (in most cases, it will be the same).\n * @param target - The target container to get the bounds from\n * @param bounds - The output bounds object.\n * @returns The bounds.\n */\nexport function getFastGlobalBounds(target: Container, bounds: Bounds): Bounds\n{\n    bounds.clear();\n\n    _getGlobalBoundsRecursive(target, bounds);\n\n    if (!bounds.isValid)\n    {\n        bounds.set(0, 0, 0, 0);\n    }\n\n    if (!target.isRenderGroupRoot)\n    {\n        bounds.applyMatrix(target.renderGroup.worldTransform);\n    }\n    else\n    {\n        bounds.applyMatrix(target.renderGroup.localTransform);\n    }\n\n    return bounds;\n}\n\nexport function _getGlobalBoundsRecursive(\n    target: Container,\n    bounds: Bounds,\n)\n{\n    if (target.localDisplayStatus !== 0b111 || !target.measurable)\n    {\n        return;\n    }\n\n    const manageEffects = !!target.effects.length;\n\n    let localBounds = bounds;\n\n    if (target.isRenderGroupRoot || manageEffects)\n    {\n        localBounds = boundsPool.get().clear();\n    }\n\n    if (target.boundsArea)\n    {\n        bounds.addRect(target.boundsArea, target.worldTransform);\n    }\n    else\n    {\n        if (target.renderPipeId)\n        {\n            const viewBounds = (target as Renderable).bounds;\n\n            localBounds.addFrame(\n                viewBounds.minX,\n                viewBounds.minY,\n                viewBounds.maxX,\n                viewBounds.maxY,\n                target.groupTransform\n            );\n        }\n\n        const children = target.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            _getGlobalBoundsRecursive(children[i], localBounds);\n        }\n    }\n\n    if (manageEffects)\n    {\n        let advanced = false;\n\n        for (let i = 0; i < target.effects.length; i++)\n        {\n            if (target.effects[i].addBounds)\n            {\n                if (!advanced)\n                {\n                    advanced = true;\n                    localBounds.applyMatrix(target.renderGroup.worldTransform);\n                }\n\n                target.effects[i].addBounds(localBounds, true);\n            }\n        }\n\n        if (advanced)\n        {\n            localBounds.applyMatrix(target.renderGroup.worldTransform.copyTo(tempMatrix).invert());\n            bounds.addBounds(localBounds, target.relativeGroupTransform);\n        }\n\n        bounds.addBounds(localBounds);\n        boundsPool.return(localBounds);\n    }\n    else if (target.isRenderGroupRoot)\n    {\n        bounds.addBounds(localBounds, target.relativeGroupTransform);\n        boundsPool.return(localBounds);\n    }\n}\n","import type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Bounds } from './Bounds';\n\nexport function getGlobalRenderableBounds(renderables: Renderable[], bounds: Bounds): Bounds\n{\n    bounds.clear();\n\n    // instead of copying the matrix each time we are assigning it in bounds\n    // this is a performance hack :D\n    // so we need to restore the matrix after we are done\n\n    const tempMatrix = bounds.matrix;\n\n    for (let i = 0; i < renderables.length; i++)\n    {\n        const renderable = renderables[i];\n\n        if (renderable.globalDisplayStatus < 0b111)\n        {\n            continue;\n        }\n\n        bounds.matrix = renderable.worldTransform;\n        renderable.addBounds(bounds);\n    }\n\n    bounds.matrix = tempMatrix;\n\n    return bounds;\n}\n","import { ExtensionType } from '../extensions/Extensions';\nimport { Matrix } from '../maths/matrix/Matrix';\nimport { Point } from '../maths/point/Point';\nimport { BindGroup } from '../rendering/renderers/gpu/shader/BindGroup';\nimport { Geometry } from '../rendering/renderers/shared/geometry/Geometry';\nimport { UniformGroup } from '../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport { TexturePool } from '../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer, RendererType } from '../rendering/renderers/types';\nimport { Bounds } from '../scene/container/bounds/Bounds';\nimport { getFastGlobalBounds } from '../scene/container/bounds/getFastGlobalBounds';\nimport { getGlobalRenderableBounds } from '../scene/container/bounds/getRenderableBounds';\nimport { warn } from '../utils/logging/warn';\n\nimport type { WebGLRenderer } from '../rendering/renderers/gl/WebGLRenderer';\nimport type { WebGPURenderer } from '../rendering/renderers/gpu/WebGPURenderer';\nimport type { Instruction } from '../rendering/renderers/shared/instructions/Instruction';\nimport type { Renderable } from '../rendering/renderers/shared/Renderable';\nimport type { RenderTarget } from '../rendering/renderers/shared/renderTarget/RenderTarget';\nimport type { RenderSurface } from '../rendering/renderers/shared/renderTarget/RenderTargetSystem';\nimport type { System } from '../rendering/renderers/shared/system/System';\nimport type { Container } from '../scene/container/Container';\nimport type { Sprite } from '../scene/sprite/Sprite';\nimport type { Filter } from './Filter';\nimport type { FilterEffect } from './FilterEffect';\n\ntype FilterAction = 'pushFilter' | 'popFilter';\n\n//\nconst quadGeometry = new Geometry({\n    attributes: {\n        aPosition: {\n            buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            location: 0,\n            format: 'float32x2',\n            stride: 2 * 4,\n            offset: 0,\n        },\n    },\n    indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3]),\n});\n\n/**\n * The filter pipeline is responsible for applying filters scene items!\n *\n * KNOWN BUGS:\n * 1. Global bounds calculation is incorrect if it is used when flip flopping filters. The maths can be found below\n * eg: filters [noiseFilter, blurFilter] noiseFilter will calculate the global bounds incorrectly.\n *\n * 2. RenderGroups do not work with filters. This is because the renderGroup matrix is not currently taken into account.\n *\n * Implementation notes:\n * 1. Gotcha - nesting filters that require blending will not work correctly. This creates a chicken and egg problem\n * the complexity and performance required to do this is not worth it i feel.. but lets see if others agree!\n *\n * 2. Filters are designed to be changed on the fly, this is means that changing filter information each frame will\n * not trigger an instruction rebuild. If you are constantly turning a filter on and off.. its therefore better to set\n * enabled to true or false on the filter. Or setting an empty array.\n *\n * 3. Need to look at perhaps aliasing when flip flopping filters. Really we should only need to antialias the FIRST\n * Texture we render too. The rest can be non aliased. This might help performance.\n * Currently we flip flop with an antialiased texture if antialiasing is enabled on the filter.\n */\nexport interface FilterInstruction extends Instruction\n{\n    renderPipeId: 'filter',\n    action: FilterAction,\n    container?: Container,\n    renderables?: Renderable[],\n    filterEffect: FilterEffect,\n}\n\nexport interface FilterData\n{\n    skip: boolean;\n    enabledLength?: number;\n    inputTexture: Texture\n    bounds: Bounds,\n    blendRequired: boolean,\n    container: Container,\n    filterEffect: FilterEffect,\n    previousRenderSurface: RenderSurface,\n    backTexture?: Texture,\n}\n\n/**\n * System that manages the filter pipeline\n * @memberof rendering\n */\nexport class FilterSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'filter',\n    } as const;\n\n    public readonly renderer: Renderer;\n\n    private _filterStackIndex = 0;\n    private _filterStack: FilterData[] = [];\n\n    private readonly _filterGlobalUniforms = new UniformGroup({\n        uInputSize: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputPixel: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputClamp: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uGlobalFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputTexture: { value: new Float32Array(4), type: 'vec4<f32>' },\n    });\n\n    private readonly _globalFilterBindGroup: BindGroup = new BindGroup({});\n    private _activeFilterData: FilterData;\n\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n     * @readonly\n     */\n    public get activeBackTexture(): Texture | undefined\n    {\n        return this._activeFilterData?.backTexture;\n    }\n\n    public push(instruction: FilterInstruction)\n    {\n        const renderer = this.renderer;\n\n        const filters = instruction.filterEffect.filters;\n\n        if (!this._filterStack[this._filterStackIndex])\n        {\n            this._filterStack[this._filterStackIndex] = this._getFilterData();\n        }\n\n        // get a filter data from the stack. They can be reused multiple times each frame,\n        // so we don't need to worry about overwriting them in a single pass.\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        this._filterStackIndex++;\n\n        // if there are no filters, we skip the pass\n        if (filters.length === 0)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        const bounds: Bounds = filterData.bounds;\n\n        // this path is used by the blend modes mostly!\n        // they collect all renderables and push them into a list.\n        // this list is then used to calculate the bounds of the filter area\n        if (instruction.renderables)\n        {\n            getGlobalRenderableBounds(instruction.renderables, bounds);\n        }\n        // if a filterArea is provided, we save our selves some measuring and just use that area supplied\n        else if (instruction.filterEffect.filterArea)\n        {\n            bounds.clear();\n\n            // transform the filterArea into global space..\n            bounds.addRect(instruction.filterEffect.filterArea);\n\n            // new for v8, we transform the bounds into the space of the container\n            bounds.applyMatrix(instruction.container.worldTransform);\n        }\n        // classic filter path, we get the bounds of the container and use it by recursively\n        // measuring.\n        else\n        {\n            getFastGlobalBounds(instruction.container, bounds);\n        }\n        // get GLOBAL bounds of the item we are going to apply the filter to\n\n        const colorTextureSource = renderer.renderTarget.rootRenderTarget.colorTexture.source;\n\n        // next we get the settings for the filter\n        // we need to find the LOWEST resolution for the filter list\n        let resolution = colorTextureSource._resolution;\n\n        // Padding is additive to add padding to our padding\n        let padding = 0;\n        // if this is true for any filter, it should be true\n        let antialias = colorTextureSource.antialias;\n        // true if any filter requires the previous render target\n        let blendRequired = false;\n        // true if any filter in the list is enabled\n        let enabled = false;\n\n        for (let i = 0; i < filters.length; i++)\n        {\n            const filter = filters[i];\n\n            resolution = Math.min(resolution, filter.resolution);\n            padding += filter.padding;\n\n            if (filter.antialias !== 'inherit')\n            {\n                if (filter.antialias === 'on')\n                {\n                    antialias = true;\n                }\n                else\n                {\n                    antialias = false;\n                }\n            }\n\n            const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n\n            if (!isCompatible)\n            {\n                enabled = false;\n                break;\n            }\n\n            if (filter.blendRequired && !((renderer as WebGLRenderer).backBuffer?.useBackBuffer ?? true))\n            {\n                // #if _DEBUG\n                // eslint-disable-next-line max-len\n                warn('Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.');\n                // #endif\n\n                enabled = false;\n                break;\n            }\n\n            enabled = filter.enabled || enabled;\n            blendRequired = blendRequired || filter.blendRequired;\n        }\n\n        // if no filters are enabled lets skip!\n        if (!enabled)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // her we constrain the bounds to the viewport we will render too\n        // need to factor in resolutions also..\n        bounds.scale(resolution)\n            .fit(renderer.renderTarget.rootViewPort)\n            .scale(1 / resolution)\n            .pad(padding)\n            .ceil();\n\n        // skip if the bounds are negative or zero as this means they are\n        // not visible on the screen\n        if (!bounds.isPositive)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // set all the filter data\n        filterData.skip = false;\n\n        filterData.bounds = bounds;\n        filterData.blendRequired = blendRequired;\n        filterData.container = instruction.container;\n        filterData.filterEffect = instruction.filterEffect;\n\n        filterData.previousRenderSurface = renderer.renderTarget.renderSurface;\n\n        // bind...\n        // get a P02 texture from our pool...\n        filterData.inputTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            resolution,\n            antialias,\n        );\n\n        renderer.renderTarget.bind(filterData.inputTexture, true);\n        // set the global uniforms to take into account the bounds offset required\n\n        renderer.globalUniforms.push({\n            offset: bounds,\n        });\n    }\n\n    public pop()\n    {\n        const renderer = this.renderer;\n\n        this._filterStackIndex--;\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        // if we are skipping this filter then we just do nothing :D\n        if (filterData.skip)\n        {\n            return;\n        }\n\n        this._activeFilterData = filterData;\n\n        const inputTexture = filterData.inputTexture;\n\n        const bounds = filterData.bounds;\n\n        let backTexture = Texture.EMPTY;\n\n        renderer.renderTarget.finishRenderPass();\n\n        if (filterData.blendRequired)\n        {\n            // this actually forces the current commandQueue to render everything so far.\n            // if we don't do this, we won't be able to copy pixels for the background\n            const previousBounds = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null;\n\n            const renderTarget = renderer.renderTarget.getRenderTarget(filterData.previousRenderSurface);\n\n            backTexture = this.getBackTexture(renderTarget, bounds, previousBounds);\n        }\n\n        filterData.backTexture = backTexture;\n\n        const filters = filterData.filterEffect.filters;\n\n        // get a BufferResource from the uniformBatch.\n        // this will batch the shader uniform data and give us a buffer resource we can\n        // set on our globalUniform Bind Group\n        // eslint-disable-next-line max-len\n\n        // update the resources on the bind group...\n        this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n        this._globalFilterBindGroup.setResource(backTexture.source, 3);\n\n        renderer.globalUniforms.pop();\n\n        if (filters.length === 1)\n        {\n            // render a single filter...\n            // this.applyFilter(filters[0], inputTexture, filterData.previousRenderSurface, false);\n            filters[0].apply(this, inputTexture, filterData.previousRenderSurface, false);\n\n            // return the texture to the pool so we can reuse the next frame\n            TexturePool.returnTexture(inputTexture);\n        }\n        else\n        {\n            let flip = filterData.inputTexture;\n\n            // get another texture that we will render the next filter too\n            let flop = TexturePool.getOptimalTexture(\n                bounds.width,\n                bounds.height,\n                flip.source._resolution,\n                false\n            );\n\n            let i = 0;\n\n            // loop and apply the filters, omitting the last one as we will render that to the final target\n            for (i = 0; i < filters.length - 1; ++i)\n            {\n                const filter = filters[i];\n\n                filter.apply(this, flip, flop, true);\n                const t = flip;\n\n                flip = flop;\n                flop = t;\n            }\n\n            filters[i].apply(this, flip, filterData.previousRenderSurface, false);\n\n            // return those textures for later!\n            TexturePool.returnTexture(flip);\n            TexturePool.returnTexture(flop);\n        }\n\n        // if we made a background texture, lets return that also\n        if (filterData.blendRequired)\n        {\n            TexturePool.returnTexture(backTexture);\n        }\n    }\n\n    public getBackTexture(lastRenderSurface: RenderTarget, bounds: Bounds, previousBounds?: Bounds)\n    {\n        const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n\n        const backTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            backgroundResolution,\n            false,\n        );\n\n        let x = bounds.minX;\n        let y = bounds.minY;\n\n        if (previousBounds)\n        {\n            x -= previousBounds.minX;\n            y -= previousBounds.minY;\n        }\n\n        x = Math.floor(x * backgroundResolution);\n        y = Math.floor(y * backgroundResolution);\n\n        const width = Math.ceil(bounds.width * backgroundResolution);\n        const height = Math.ceil(bounds.height * backgroundResolution);\n\n        this.renderer.renderTarget.copyToTexture(\n            lastRenderSurface,\n            backTexture,\n            { x, y },\n            { width, height },\n            { x: 0, y: 0 }\n        );\n\n        return backTexture;\n    }\n\n    public applyFilter(filter: Filter, input: Texture, output: RenderSurface, clear: boolean)\n    {\n        const renderer = this.renderer;\n\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        const bounds = filterData.bounds;\n\n        const offset = Point.shared;\n        const previousRenderSurface = filterData.previousRenderSurface;\n\n        const isFinalTarget = previousRenderSurface === output;\n\n        let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n\n        // to find the previous resolution we need to account for the skipped filters\n        // the following will find the last non skipped filter...\n        let currentIndex = this._filterStackIndex - 1;\n\n        while (currentIndex > 0 && this._filterStack[currentIndex].skip)\n        {\n            --currentIndex;\n        }\n\n        if (currentIndex > 0)\n        {\n            resolution = this._filterStack[currentIndex].inputTexture.source._resolution;\n        }\n\n        const filterUniforms = this._filterGlobalUniforms;\n        const uniforms = filterUniforms.uniforms;\n\n        const outputFrame = uniforms.uOutputFrame;\n        const inputSize = uniforms.uInputSize;\n        const inputPixel = uniforms.uInputPixel;\n        const inputClamp = uniforms.uInputClamp;\n        const globalFrame = uniforms.uGlobalFrame;\n        const outputTexture = uniforms.uOutputTexture;\n\n        // are we rendering back to the original surface?\n        if (isFinalTarget)\n        {\n            let lastIndex = this._filterStackIndex;\n\n            // get previous bounds.. we must take into account skipped filters also..\n            while (lastIndex > 0)\n            {\n                lastIndex--;\n                const filterData = this._filterStack[this._filterStackIndex - 1];\n\n                if (!filterData.skip)\n                {\n                    offset.x = filterData.bounds.minX;\n                    offset.y = filterData.bounds.minY;\n\n                    break;\n                }\n            }\n\n            outputFrame[0] = bounds.minX - offset.x;\n            outputFrame[1] = bounds.minY - offset.y;\n        }\n        else\n        {\n            outputFrame[0] = 0;\n            outputFrame[1] = 0;\n        }\n\n        outputFrame[2] = input.frame.width;\n        outputFrame[3] = input.frame.height;\n\n        inputSize[0] = input.source.width;\n        inputSize[1] = input.source.height;\n        inputSize[2] = 1 / inputSize[0];\n        inputSize[3] = 1 / inputSize[1];\n\n        inputPixel[0] = input.source.pixelWidth;\n        inputPixel[1] = input.source.pixelHeight;\n        inputPixel[2] = 1.0 / inputPixel[0];\n        inputPixel[3] = 1.0 / inputPixel[1];\n\n        inputClamp[0] = 0.5 * inputPixel[2];\n        inputClamp[1] = 0.5 * inputPixel[3];\n        inputClamp[2] = (input.frame.width * inputSize[2]) - (0.5 * inputPixel[2]);\n        inputClamp[3] = (input.frame.height * inputSize[3]) - (0.5 * inputPixel[3]);\n\n        const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n\n        globalFrame[0] = offset.x * resolution;\n        globalFrame[1] = offset.y * resolution;\n\n        globalFrame[2] = rootTexture.source.width * resolution;\n        globalFrame[3] = rootTexture.source.height * resolution;\n\n        // set the output texture - this is where we are going to render to\n\n        const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n\n        renderer.renderTarget.bind(output, !!clear);\n\n        if (output instanceof Texture)\n        {\n            outputTexture[0] = output.frame.width;\n            outputTexture[1] = output.frame.height;\n        }\n        else\n        {\n            // this means a renderTarget was passed directly\n            outputTexture[0] = renderTarget.width;\n            outputTexture[1] = renderTarget.height;\n        }\n\n        outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n        filterUniforms.update();\n\n        // TODO - should prolly use a adaptor...\n        if ((renderer as WebGPURenderer).renderPipes.uniformBatch)\n        {\n            const batchUniforms = (renderer as WebGPURenderer).renderPipes.uniformBatch\n                .getUboResource(filterUniforms);\n\n            this._globalFilterBindGroup.setResource(batchUniforms, 0);\n        }\n        else\n        {\n            this._globalFilterBindGroup.setResource(filterUniforms, 0);\n        }\n\n        // now lets update the output texture...\n\n        // set bind group..\n        this._globalFilterBindGroup.setResource(input.source, 1);\n        this._globalFilterBindGroup.setResource(input.source.style, 2);\n\n        filter.groups[0] = this._globalFilterBindGroup;\n\n        renderer.encoder.draw({\n            geometry: quadGeometry,\n            shader: filter,\n            state: filter._state,\n            topology: 'triangle-list'\n        });\n\n        // WebGPU blit's automatically, but WebGL does not!\n        if (renderer.type === RendererType.WEBGL)\n        {\n            renderer.renderTarget.finishRenderPass();\n        }\n    }\n\n    private _getFilterData(): FilterData\n    {\n        return {\n            skip: false,\n            inputTexture: null,\n            bounds: new Bounds(),\n            container: null,\n            filterEffect: null,\n            blendRequired: false,\n            previousRenderSurface: null,\n        };\n    }\n\n    /**\n     * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n     *\n     * Use `outputMatrix * vTextureCoord` in the shader.\n     * @param outputMatrix - The matrix to output to.\n     * @param {Sprite} sprite - The sprite to map to.\n     * @returns The mapped matrix.\n     */\n    public calculateSpriteMatrix(outputMatrix: Matrix, sprite: Sprite): Matrix\n    {\n        const data = this._activeFilterData;\n\n        const mappedMatrix = outputMatrix.set(\n            data.inputTexture._source.width,\n            0, 0,\n            data.inputTexture._source.height,\n            data.bounds.minX, data.bounds.minY\n        );\n\n        const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);\n\n        worldTransform.invert();\n        mappedMatrix.prepend(worldTransform);\n        mappedMatrix.scale(\n            1.0 / sprite.texture.frame.width,\n            1.0 / sprite.texture.frame.height\n        );\n\n        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n\n        return mappedMatrix;\n    }\n\n    public destroy?: () => void;\n}\n","import { extensions } from '../extensions/Extensions';\nimport { FilterPipe } from './FilterPipe';\nimport { FilterSystem } from './FilterSystem';\n\nextensions.add(FilterSystem);\nextensions.add(FilterPipe);\n","import { MAX_TEXTURES } from '../../../batcher/shared/const';\nimport { UniformGroup } from '../../shared/shader/UniformGroup';\n\nconst sampleValues = new Int32Array(MAX_TEXTURES);\n\nfor (let i = 0; i < MAX_TEXTURES; i++)\n{\n    sampleValues[i] = i;\n}\n\nexport const batchSamplersUniformGroup = new UniformGroup({\n    uTextures: { value: sampleValues, type: `i32`, size: MAX_TEXTURES }\n}, { isStatic: true });\n","import { DOMAdapter } from '../../../../environment/adapter';\nimport { nextPow2 } from '../../../../maths/misc/pow2';\n\nimport type { ICanvas, ICanvasRenderingContext2DSettings } from '../../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../../environment/canvas/ICanvasRenderingContext2D';\n\nexport interface CanvasAndContext\n{\n    canvas: ICanvas;\n    context: ICanvasRenderingContext2D;\n}\n\n/**\n * Texture pool, used by FilterSystem and plugins.\n *\n * Stores collection of temporary pow2 or screen-sized renderTextures\n *\n * If you use custom RenderTexturePool for your filters, you can use methods\n * `getFilterTexture` and `returnFilterTexture` same as in\n * @name CanvasPool\n * @memberof rendering\n */\nexport class CanvasPoolClass\n{\n    public canvasOptions: ICanvasRenderingContext2DSettings;\n\n    /**\n     * Allow renderTextures of the same size as screen, not just pow2\n     *\n     * Automatically sets to true after `setScreenSize`\n     * @default false\n     */\n    public enableFullScreen: boolean;\n    private _canvasPool: {[x in string | number]: CanvasAndContext[]};\n\n    constructor(canvasOptions?: ICanvasRenderingContext2DSettings)\n    {\n        this._canvasPool = Object.create(null);\n        this.canvasOptions = canvasOptions || {};\n        this.enableFullScreen = false;\n    }\n\n    /**\n     * Creates texture with params that were specified in pool constructor.\n     * @param pixelWidth - Width of texture in pixels.\n     * @param pixelHeight - Height of texture in pixels.\n     */\n    private _createCanvasAndContext(pixelWidth: number, pixelHeight: number): CanvasAndContext\n    {\n        const canvas = DOMAdapter.get().createCanvas();\n\n        canvas.width = pixelWidth;\n        canvas.height = pixelHeight;\n\n        const context = canvas.getContext('2d');\n\n        return { canvas, context };\n    }\n\n    /**\n     * Gets a Power-of-Two render texture or fullScreen texture\n     * @param minWidth - The minimum width of the render texture.\n     * @param minHeight - The minimum height of the render texture.\n     * @param resolution - The resolution of the render texture.\n     * @returns The new render texture.\n     */\n    public getOptimalCanvasAndContext(minWidth: number, minHeight: number, resolution = 1): CanvasAndContext\n    {\n        minWidth = Math.ceil((minWidth * resolution) - 1e-6);\n        minHeight = Math.ceil((minHeight * resolution) - 1e-6);\n        minWidth = nextPow2(minWidth);\n        minHeight = nextPow2(minHeight);\n\n        const key = (minWidth << 17) + (minHeight << 1);\n\n        if (!this._canvasPool[key])\n        {\n            this._canvasPool[key] = [];\n        }\n\n        let canvasAndContext = this._canvasPool[key].pop();\n\n        if (!canvasAndContext)\n        {\n            canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);\n        }\n\n        return canvasAndContext;\n    }\n\n    /**\n     * Place a render texture back into the pool.\n     * @param canvasAndContext\n     */\n    public returnCanvasAndContext(canvasAndContext: CanvasAndContext): void\n    {\n        const { width, height } = canvasAndContext.canvas;\n\n        const key = (width << 17) + (height << 1);\n\n        this._canvasPool[key].push(canvasAndContext);\n    }\n\n    public clear(): void\n    {\n        this._canvasPool = {};\n    }\n}\n\nexport const CanvasPool = new CanvasPoolClass();\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../../rendering/renderers/shared/state/State';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { color32BitToUniform } from '../gpu/colorToUniform';\nimport { BatchableGraphics } from './BatchableGraphics';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { BatchPipe, RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Graphics } from './Graphics';\nimport type { GpuGraphicsContext, GraphicsContextSystem } from './GraphicsContextSystem';\n\nexport interface GraphicsAdaptor\n{\n    shader: Shader;\n    init(): void;\n    execute(graphicsPipe: GraphicsPipe, renderable: Graphics): void;\n    destroy(): void;\n}\nexport interface GraphicsSystem\n{\n    graphicsContext: GraphicsContextSystem;\n    renderPipes: {\n        batch: BatchPipe\n    }\n    _roundPixels: 0 | 1;\n}\n\nexport class GraphicsPipe implements RenderPipe<Graphics>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'graphics',\n    } as const;\n\n    public renderer: GraphicsSystem;\n    public state: State = State.for2d();\n\n    // batchable graphics list, used to render batches\n    private _graphicsBatchesHash: Record<number, BatchableGraphics[]> = Object.create(null);\n    private _adaptor: GraphicsAdaptor;\n\n    constructor(renderer: GraphicsSystem, adaptor: GraphicsAdaptor)\n    {\n        this.renderer = renderer;\n\n        this._adaptor = adaptor;\n        this._adaptor.init();\n    }\n\n    public validateRenderable(graphics: Graphics): boolean\n    {\n        // assume context is dirty..\n\n        const context = graphics.context;\n\n        const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);\n\n        if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable)\n        {\n            // TODO what if they are the same size??\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n\n        // need to get batches here.. as we need to know if we can batch or not..\n        // this also overrides the current batches..\n\n        if (graphics._didGraphicsUpdate)\n        {\n            graphics._didGraphicsUpdate = false;\n\n            this._rebuild(graphics);\n        }\n\n        if (gpuContext.isBatchable)\n        {\n            this._addToBatcher(graphics, instructionSet);\n        }\n        else\n        {\n            this.renderer.renderPipes.batch.break(instructionSet);\n            instructionSet.add(graphics);\n        }\n    }\n\n    public updateRenderable(graphics: Graphics)\n    {\n        const batches = this._graphicsBatchesHash[graphics.uid];\n\n        if (batches)\n        {\n            for (let i = 0; i < batches.length; i++)\n            {\n                const batch = batches[i];\n\n                batch.batcher.updateElement(batch);\n            }\n        }\n    }\n\n    public destroyRenderable(graphics: Graphics)\n    {\n        if (this._graphicsBatchesHash[graphics.uid])\n        {\n            this._removeBatchForRenderable(graphics.uid);\n        }\n    }\n\n    public execute(graphics: Graphics)\n    {\n        if (!graphics.isRenderable) return;\n\n        const renderer = this.renderer;\n        const context = graphics.context;\n        const contextSystem = renderer.graphicsContext;\n\n        // early out if there is no actual visual stuff...\n        if (!contextSystem.getGpuContext(context).batches.length)\n        { return; }\n\n        const shader = context.customShader || this._adaptor.shader;\n\n        this.state.blendMode = graphics.groupBlendMode;\n\n        const localUniforms = shader.resources.localUniforms.uniforms;\n\n        localUniforms.uTransformMatrix = graphics.groupTransform;\n        localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;\n\n        color32BitToUniform(\n            graphics.groupColorAlpha,\n            localUniforms.uColor,\n            0,\n        );\n\n        this._adaptor.execute(this, graphics);\n    }\n\n    private _rebuild(graphics: Graphics)\n    {\n        const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n\n        // TODO POOL the old batches!\n\n        if (wasBatched)\n        {\n            this._removeBatchForRenderable(graphics.uid);\n        }\n\n        if (gpuContext.isBatchable)\n        {\n            this._initBatchesForRenderable(graphics);\n        }\n\n        graphics.batched = gpuContext.isBatchable;\n    }\n\n    private _addToBatcher(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const batchPipe = this.renderer.renderPipes.batch;\n\n        const batches = this._getBatchesForRenderable(graphics);\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batchPipe.addToBatch(batch, instructionSet);\n        }\n    }\n\n    private _getBatchesForRenderable(graphics: Graphics): BatchableGraphics[]\n    {\n        return this._graphicsBatchesHash[graphics.uid] || this._initBatchesForRenderable(graphics);\n    }\n\n    private _initBatchesForRenderable(graphics: Graphics): BatchableGraphics[]\n    {\n        const context = graphics.context;\n\n        const gpuContext: GpuGraphicsContext = this.renderer.graphicsContext.getGpuContext(context);\n\n        const roundPixels = (this.renderer._roundPixels | graphics._roundPixels) as 0 | 1;\n\n        const batches = gpuContext.batches.map((batch) =>\n        {\n            // TODO pool this!!\n            const batchClone = BigPool.get(BatchableGraphics);\n\n            batch.copyTo(batchClone);\n\n            batchClone.renderable = graphics;\n\n            batchClone.roundPixels = roundPixels;\n\n            return batchClone;\n        });\n\n        this._graphicsBatchesHash[graphics.uid] = batches;\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        graphics.on('destroyed', () =>\n        {\n            this.destroyRenderable(graphics);\n        });\n\n        return batches;\n    }\n\n    private _removeBatchForRenderable(graphicsUid: number)\n    {\n        this._graphicsBatchesHash[graphicsUid].forEach((batch) =>\n        {\n            BigPool.return(batch as PoolItem);\n        });\n\n        this._graphicsBatchesHash[graphicsUid] = null;\n    }\n\n    public destroy()\n    {\n        this.renderer = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n        this.state = null;\n\n        for (const i in this._graphicsBatchesHash)\n        {\n            this._removeBatchForRenderable(i as unknown as number);\n        }\n\n        this._graphicsBatchesHash = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { GraphicsContextSystem } from './shared/GraphicsContextSystem';\nimport { GraphicsPipe } from './shared/GraphicsPipe';\n\nextensions.add(GraphicsPipe);\nextensions.add(GraphicsContextSystem);\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { BindGroup } from '../../../rendering/renderers/gpu/shader/BindGroup';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform';\nimport { BatchableMesh } from './BatchableMesh';\n\nimport type { Instruction } from '../../../rendering/renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type {\n    InstructionPipe,\n    RenderPipe\n} from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Mesh } from './Mesh';\n\n// TODO Record mode is a P2, will get back to this as it's not a priority\n// const recordMode = true;\n\ninterface MeshData\n{\n    batched: boolean;\n    indexSize: number;\n    vertexSize: number;\n}\n\nexport interface MeshAdaptor\n{\n    init(): void;\n    execute(meshPipe: MeshPipe, mesh: Mesh): void;\n    destroy(): void;\n}\n\nexport interface MeshInstruction extends Instruction\n{\n    renderPipeId: 'mesh';\n    mesh: Mesh;\n}\n\n// eslint-disable-next-line max-len\nexport class MeshPipe implements RenderPipe<Mesh>, InstructionPipe<MeshInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'mesh',\n    } as const;\n\n    public localUniforms = new UniformGroup({\n        uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n        uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n        uRound: { value: 0, type: 'f32' },\n    });\n\n    public localUniformsBindGroup = new BindGroup({\n        0: this.localUniforms,\n    });\n\n    public renderer: Renderer;\n\n    private _meshDataHash: Record<number, MeshData> = Object.create(null);\n    private _gpuBatchableMeshHash: Record<number, BatchableMesh> = Object.create(null);\n    private _adaptor: MeshAdaptor;\n\n    constructor(renderer: Renderer, adaptor: MeshAdaptor)\n    {\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n\n        this._adaptor.init();\n    }\n\n    public validateRenderable(mesh: Mesh): boolean\n    {\n        const meshData = this._getMeshData(mesh);\n\n        const wasBatched = meshData.batched;\n\n        const isBatched = mesh.batched;\n\n        meshData.batched = isBatched;\n\n        if (wasBatched !== isBatched)\n        {\n            return true;\n        }\n        else if (isBatched)\n        {\n            const geometry = mesh._geometry;\n\n            // no need to break the batch if it's the same size\n            if (geometry.indices.length !== meshData.indexSize\n                    || geometry.positions.length !== meshData.vertexSize)\n            {\n                meshData.indexSize = geometry.indices.length;\n                meshData.vertexSize = geometry.positions.length;\n\n                return true;\n            }\n\n            const batchableMesh = this._getBatchableMesh(mesh);\n\n            const texture = mesh.texture;\n\n            if (batchableMesh.texture._source !== texture._source)\n            {\n                if (batchableMesh.texture._source !== texture._source)\n                {\n                    return !batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, texture);\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public addRenderable(mesh: Mesh, instructionSet: InstructionSet)\n    {\n        const batcher = this.renderer.renderPipes.batch;\n\n        const { batched } = this._getMeshData(mesh);\n\n        if (batched)\n        {\n            const gpuBatchableMesh = this._getBatchableMesh(mesh);\n\n            gpuBatchableMesh.texture = mesh._texture;\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            batcher.addToBatch(gpuBatchableMesh);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            instructionSet.add({\n                renderPipeId: 'mesh',\n                mesh\n            } as MeshInstruction);\n        }\n    }\n\n    public updateRenderable(mesh: Mesh)\n    {\n        if (mesh.batched)\n        {\n            const gpuBatchableMesh = this._gpuBatchableMeshHash[mesh.uid];\n\n            gpuBatchableMesh.texture = mesh._texture;\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            gpuBatchableMesh.batcher.updateElement(gpuBatchableMesh);\n        }\n    }\n\n    public destroyRenderable(mesh: Mesh)\n    {\n        this._meshDataHash[mesh.uid] = null;\n\n        const gpuMesh = this._gpuBatchableMeshHash[mesh.uid];\n\n        BigPool.return(gpuMesh as PoolItem);\n\n        this._gpuBatchableMeshHash[mesh.uid] = null;\n    }\n\n    public execute({ mesh }: MeshInstruction)\n    {\n        if (!mesh.isRenderable) return;\n\n        mesh.state.blendMode = mesh.groupBlendMode;\n\n        const localUniforms = this.localUniforms;\n\n        localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n        localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n        localUniforms.update();\n\n        color32BitToUniform(\n            mesh.groupColorAlpha,\n            localUniforms.uniforms.uColor,\n            0\n        );\n\n        this._adaptor.execute(this, mesh);\n    }\n\n    private _getMeshData(mesh: Mesh): MeshData\n    {\n        return this._meshDataHash[mesh.uid] || this._initMeshData(mesh);\n    }\n\n    private _initMeshData(mesh: Mesh): MeshData\n    {\n        this._meshDataHash[mesh.uid] = {\n            batched: mesh.batched,\n            indexSize: mesh._geometry.indices?.length,\n            vertexSize: mesh._geometry.positions?.length,\n        };\n\n        mesh.on('destroyed', () =>\n        {\n            this.destroyRenderable(mesh);\n        });\n\n        return this._meshDataHash[mesh.uid];\n    }\n\n    private _getBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        return this._gpuBatchableMeshHash[mesh.uid] || this._initBatchableMesh(mesh);\n    }\n\n    private _initBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        // TODO - make this batchable graphics??\n        const gpuMesh: BatchableMesh = BigPool.get(BatchableMesh);\n\n        gpuMesh.mesh = mesh;\n        gpuMesh.texture = mesh._texture;\n        gpuMesh.roundPixels = (this.renderer._roundPixels | mesh._roundPixels) as 0 | 1;\n\n        this._gpuBatchableMeshHash[mesh.uid] = gpuMesh;\n\n        gpuMesh.mesh = mesh;\n\n        return gpuMesh;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuBatchableMeshHash)\n        {\n            if (this._gpuBatchableMeshHash[i])\n            {\n                BigPool.return(this._gpuBatchableMeshHash[i] as PoolItem);\n            }\n        }\n\n        this._gpuBatchableMeshHash = null;\n        this._meshDataHash = null;\n\n        this.localUniforms = null;\n        this.localUniformsBindGroup = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n\n        this.renderer = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { MeshPipe } from './shared/MeshPipe';\n\nextensions.add(MeshPipe);\n","import { Matrix } from '../../../maths/matrix/Matrix';\n\nimport type { Batch, BatchableObject, Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport type { IndexBufferArray } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Container } from '../../container/Container';\nimport type { MeshGeometry } from './MeshGeometry';\n\n/**\n * A batchable mesh object.\n * @ignore\n */\nexport class BatchableMesh implements BatchableObject\n{\n    public indexStart: number;\n    public textureId: number;\n    public texture: Texture;\n    public location: number;\n    public batcher: Batcher = null;\n    public batch: Batch = null;\n    public mesh: Container;\n    public geometry: MeshGeometry;\n\n    public roundPixels: 0 | 1 = 0;\n\n    private _transformedUvs: Float32Array;\n    private readonly _uvMatrix = new Matrix();\n\n    get blendMode() { return this.mesh.groupBlendMode; }\n\n    public reset()\n    {\n        this.mesh = null;\n        this.texture = null;\n        this.batcher = null;\n        this.batch = null;\n    }\n\n    public packIndex(indexBuffer: IndexBufferArray, index: number, indicesOffset: number)\n    {\n        const indices = this.geometry.indices;\n\n        for (let i = 0; i < indices.length; i++)\n        {\n            indexBuffer[index++] = indices[i] + indicesOffset;\n        }\n    }\n\n    public packAttributes(\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    )\n    {\n        const mesh = this.mesh;\n\n        const geometry = this.geometry;\n        const wt = mesh.groupTransform;\n\n        const textureIdAndRound = (textureId << 16) | (this.roundPixels & 0xFFFF);\n\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        // const trim = texture.trim;\n        const positions = geometry.positions;\n        const uvs = geometry.uvs;\n\n        let transformedUvs = uvs;\n        const textureMatrix = this.texture.textureMatrix;\n\n        if (!textureMatrix.isSimple)\n        {\n            transformedUvs = this._transformedUvs;\n\n            if (!transformedUvs || transformedUvs.length < uvs.length)\n            {\n                transformedUvs = this._transformedUvs = new Float32Array(uvs.length);\n            }\n\n            if (!textureMatrix.mapCoord.equals(this._uvMatrix))\n            {\n                this._uvMatrix.copyFrom(textureMatrix.mapCoord);\n                textureMatrix.multiplyUvs(uvs, transformedUvs);\n            }\n        }\n\n        const abgr = mesh.groupColorAlpha;\n\n        for (let i = 0; i < positions.length; i += 2)\n        {\n            const x = positions[i];\n            const y = positions[i + 1];\n\n            float32View[index] = (a * x) + (c * y) + tx;\n            float32View[index + 1] = (b * x) + (d * y) + ty;\n\n            // TODO implement texture matrix?\n            float32View[index + 2] = transformedUvs[i];\n            float32View[index + 3] = transformedUvs[i + 1];\n\n            uint32View[index + 4] = abgr;\n            uint32View[index + 5] = textureIdAndRound;\n\n            index += 6;\n        }\n    }\n\n    get vertexSize()\n    {\n        return this.geometry.positions.length / 2;\n    }\n\n    get indexSize()\n    {\n        return this.geometry.indices.length;\n    }\n}\n","import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\n\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { BatchMode } from '../../graphics/shared/GraphicsContext';\n\n/**\n * Options for the mesh geometry.\n * @memberof scene\n */\nexport interface MeshGeometryOptions\n{\n    /** The positions of the mesh. */\n    positions?: Float32Array;\n    /** The UVs of the mesh. */\n    uvs?: Float32Array;\n    /** The indices of the mesh. */\n    indices?: Uint32Array;\n    /** The topology of the mesh. */\n    topology?: Topology;\n    /** Whether to shrink the buffers to fit the data. */\n    shrinkBuffersToFit?: boolean;\n}\n\n/**\n * A geometry used to batch multiple meshes with the same texture.\n * @memberof scene\n */\nexport class MeshGeometry extends Geometry\n{\n    public static defaultOptions: MeshGeometryOptions = {\n        topology: 'triangle-list',\n        shrinkBuffersToFit: false,\n    };\n\n    public batchMode: BatchMode = 'auto';\n\n    /**\n     * @param {scene.MeshGeometryOptions} options - The options of the mesh geometry.\n     */\n    constructor(options: MeshGeometryOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(positions: Float32Array, uvs: Float32Array, indices: Uint32Array);\n    constructor(...args: [MeshGeometryOptions] | [Float32Array, Float32Array, Uint32Array])\n    {\n        let options = args[0] ?? {};\n\n        if (options instanceof Float32Array)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'use new MeshGeometry({ positions, uvs, indices }) instead');\n            // #endif\n\n            options = {\n                positions: options,\n                uvs: args[1],\n                indices: args[2],\n            };\n        }\n\n        options = { ...MeshGeometry.defaultOptions, ...options };\n\n        const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n        const uvs = options.uvs || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n        const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);\n\n        const shrinkToFit = options.shrinkBuffersToFit;\n\n        const positionBuffer = new Buffer({\n            data: positions,\n            label: 'attribute-mesh-positions',\n            shrinkToFit,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n        });\n\n        const uvBuffer = new Buffer({\n            data: uvs,\n            label: 'attribute-mesh-uvs',\n            shrinkToFit,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n        });\n\n        const indexBuffer = new Buffer({\n            data: indices,\n            label: 'index-mesh-buffer',\n            shrinkToFit,\n            usage: BufferUsage.INDEX | BufferUsage.COPY_DST,\n        });\n\n        super({\n            attributes: {\n                aPosition: {\n                    buffer: positionBuffer,\n                    format: 'float32x2',\n                    stride: 2 * 4,\n                    offset: 0,\n                },\n                aUV: {\n                    buffer: uvBuffer,\n                    format: 'float32x2',\n                    stride: 2 * 4,\n                    offset: 0,\n                },\n            },\n            indexBuffer,\n            topology: options.topology,\n        });\n    }\n\n    /** The positions of the mesh. */\n    get positions(): Float32Array\n    {\n        return this.attributes.aPosition.buffer.data as Float32Array;\n    }\n\n    set positions(value: Float32Array)\n    {\n        this.attributes.aPosition.buffer.data = value;\n    }\n\n    /** The UVs of the mesh. */\n    get uvs(): Float32Array\n    {\n        return this.attributes.aUV.buffer.data as Float32Array;\n    }\n\n    set uvs(value: Float32Array)\n    {\n        this.attributes.aUV.buffer.data = value;\n    }\n\n    /** The indices of the mesh. */\n    get indices(): Uint32Array\n    {\n        return this.indexBuffer.data as Uint32Array;\n    }\n\n    set indices(value: Uint32Array)\n    {\n        this.indexBuffer.data = value;\n    }\n}\n","import { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry';\n\nimport type { MeshGeometryOptions } from '../mesh/shared/MeshGeometry';\n\n/**\n * Constructor options used for `PlaneGeometry` instances.\n * ```js\n * const planeGeometry = new PlaneGeometry({\n *    width: 100,\n *    height: 100,\n *    verticesX: 10,\n *    verticesY: 10,\n * });\n * ```\n * @see {@link scene.PlaneGeometry}\n * @memberof scene\n */\nexport interface PlaneGeometryOptions\n{\n    /** Width of plane */\n    width?: number;\n    /** Height of plane */\n    height?: number;\n    /** Number of vertices on x-axis */\n    verticesX?: number;\n    /** Number of vertices on y-axis */\n    verticesY?: number;\n}\n\n/**\n * The PlaneGeometry allows you to draw a 2d plane\n * @memberof scene\n */\nexport class PlaneGeometry extends MeshGeometry\n{\n    public static defaultOptions: PlaneGeometryOptions & MeshGeometryOptions = {\n        width: 100,\n        height: 100,\n        verticesX: 10,\n        verticesY: 10,\n    };\n\n    /** The number of vertices on x-axis */\n    public verticesX: number;\n    /** The number of vertices on y-axis */\n    public verticesY: number;\n    /** The width of plane */\n    public width: number;\n    /** The height of plane */\n    public height: number;\n\n    /**\n     * @param {PlaneGeometryOptions} options - Options to be applied to plane geometry\n     */\n    constructor(options: PlaneGeometryOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(width?: number, height?: number, verticesX?: number, verticesY?: number);\n    constructor(...args: [PlaneGeometryOptions?] | [number?, number?, number?, number?])\n    {\n        super({});\n\n        let options = args[0] ?? {};\n\n        if (typeof options === 'number')\n        {\n            // #if _DEBUG\n            // eslint-disable-next-line max-len\n            deprecation(v8_0_0, 'PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead');\n            // #endif\n\n            options = {\n                width: options,\n                height: args[1],\n                verticesX: args[2],\n                verticesY: args[3],\n            };\n        }\n\n        this.build(options);\n    }\n\n    /**\n     * Refreshes plane coordinates\n     * @param options - Options to be applied to plane geometry\n     */\n    public build(options: PlaneGeometryOptions): void\n    {\n        options = { ...PlaneGeometry.defaultOptions, ...options };\n\n        this.verticesX = this.verticesX ?? options.verticesX;\n        this.verticesY = this.verticesY ?? options.verticesY;\n\n        this.width = this.width ?? options.width;\n        this.height = this.height ?? options.height;\n\n        const total = this.verticesX * this.verticesY;\n        const verts = [];\n        const uvs = [];\n        const indices = [];\n\n        const verticesX = this.verticesX - 1;\n        const verticesY = this.verticesY - 1;\n\n        const sizeX = (this.width) / verticesX;\n        const sizeY = (this.height) / verticesY;\n\n        for (let i = 0; i < total; i++)\n        {\n            const x = (i % this.verticesX);\n            const y = ((i / this.verticesX) | 0);\n\n            verts.push(x * sizeX, y * sizeY);\n            uvs.push(x / verticesX, y / verticesY);\n        }\n\n        const totalSub = verticesX * verticesY;\n\n        for (let i = 0; i < totalSub; i++)\n        {\n            const xpos = i % verticesX;\n            const ypos = (i / verticesX) | 0;\n\n            const value = (ypos * this.verticesX) + xpos;\n            const value2 = (ypos * this.verticesX) + xpos + 1;\n            const value3 = ((ypos + 1) * this.verticesX) + xpos;\n            const value4 = ((ypos + 1) * this.verticesX) + xpos + 1;\n\n            indices.push(value, value2, value3,\n                value2, value4, value3);\n        }\n\n        this.buffers[0].data = new Float32Array(verts);\n        this.buffers[1].data = new Float32Array(uvs);\n        this.indexBuffer.data = new Uint32Array(indices);\n\n        // ensure that the changes are uploaded\n        this.buffers[0].update();\n        this.buffers[1].update();\n        this.indexBuffer.update();\n    }\n}\n","import { Matrix } from '../../maths/matrix/Matrix';\nimport { PlaneGeometry } from '../mesh-plane/PlaneGeometry';\n\n/**\n * Options for the NineSliceGeometry.\n * @memberof scene\n */\nexport interface NineSliceGeometryOptions\n{\n\n    /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    width?: number\n    /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    height?: number\n    /** The original width of the texture */\n    originalWidth?: number\n    /** The original height of the texture */\n    originalHeight?: number\n    /** The width of the left column. */\n    leftWidth?: number\n    /** The height of the top row. */\n    topHeight?: number\n    /** The width of the right column. */\n    rightWidth?: number\n    /** The height of the bottom row. */\n    bottomHeight?: number\n    /** The texture matrix of the NineSlicePlane. */\n    textureMatrix?: Matrix\n}\n\n/**\n * The NineSliceGeometry class allows you to create a NineSlicePlane object.\n * @memberof scene\n */\nexport class NineSliceGeometry extends PlaneGeometry\n{\n    /** The default options for the NineSliceGeometry. */\n    public static defaultOptions: NineSliceGeometryOptions = {\n        /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        width: 100,\n        /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        height: 100,\n        /** The width of the left column. */\n        leftWidth: 10,\n        /** The height of the top row. */\n        topHeight: 10,\n        /** The width of the right column. */\n        rightWidth: 10,\n        /** The height of the bottom row. */\n        bottomHeight: 10,\n\n        /** The original width of the texture */\n        originalWidth: 100,\n        /** The original height of the texture */\n        originalHeight: 100,\n    };\n\n    public _leftWidth: number;\n    public _rightWidth: number;\n    public _topHeight: number;\n    public _bottomHeight: number;\n\n    private _originalWidth: number;\n    private _originalHeight: number;\n    private readonly _textureMatrix: Matrix = new Matrix();\n\n    constructor(options: NineSliceGeometryOptions = {})\n    {\n        options = { ...NineSliceGeometry.defaultOptions, ...options };\n\n        super({\n            width: options.width,\n            height: options.height,\n            verticesX: 4,\n            verticesY: 4,\n        });\n\n        this.update(options);\n    }\n\n    /**\n     * Updates the NineSliceGeometry with the options.\n     * @param options - The options of the NineSliceGeometry.\n     */\n    public update(options: NineSliceGeometryOptions)\n    {\n        this.width = options.width ?? this.width;\n        this.height = options.height ?? this.height;\n        this._originalWidth = options.originalWidth ?? this._originalWidth;\n        this._originalHeight = options.originalHeight ?? this._originalHeight;\n        this._leftWidth = options.leftWidth ?? this._leftWidth;\n        this._rightWidth = options.rightWidth ?? this._rightWidth;\n        this._topHeight = options.topHeight ?? this._topHeight;\n        this._bottomHeight = options.bottomHeight ?? this._bottomHeight;\n\n        if (options.textureMatrix)\n        {\n            this._textureMatrix.copyFrom(options.textureMatrix);\n        }\n\n        this.updateUvs();\n        this.updatePositions();\n    }\n\n    /** Updates the positions of the vertices. */\n    public updatePositions()\n    {\n        const positions = this.positions;\n\n        const w = this._leftWidth + this._rightWidth;\n        const scaleW = this.width > w ? 1.0 : this.width / w;\n\n        const h = this._topHeight + this._bottomHeight;\n        const scaleH = this.height > h ? 1.0 : this.height / h;\n\n        const scale = Math.min(scaleW, scaleH);\n\n        positions[9] = positions[11] = positions[13] = positions[15] = this._topHeight * scale;\n        positions[17] = positions[19] = positions[21] = positions[23] = this.height - (this._bottomHeight * scale);\n        positions[25] = positions[27] = positions[29] = positions[31] = this.height;\n\n        positions[2] = positions[10] = positions[18] = positions[26] = this._leftWidth * scale;\n        positions[4] = positions[12] = positions[20] = positions[28] = this.width - (this._rightWidth * scale);\n        positions[6] = positions[14] = positions[22] = positions[30] = this.width;\n\n        this.getBuffer('aPosition').update();\n    }\n\n    /** Updates the UVs of the vertices. */\n    public updateUvs()\n    {\n        const textureMatrix = this._textureMatrix;\n\n        const uvs = this.uvs;\n\n        uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n        uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n\n        uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n        uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n\n        const _uvw = 1.0 / this._originalWidth;\n        const _uvh = 1.0 / this._originalHeight;\n\n        uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n        uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n\n        uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - (_uvw * this._rightWidth);\n        uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - (_uvh * this._bottomHeight);\n\n        multiplyUvs(textureMatrix, uvs);\n\n        this.getBuffer('aUV').update();\n    }\n}\n\nfunction multiplyUvs(matrix: Matrix, uvs: Float32Array, out?: Float32Array)\n{\n    out ??= uvs;\n\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n\n    for (let i = 0; i < uvs.length; i += 2)\n    {\n        const x = uvs[i];\n        const y = uvs[i + 1];\n\n        out[i] = (x * a) + (y * c) + tx;\n        out[i + 1] = (x * b) + (y * d) + ty;\n    }\n\n    return out;\n}\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh';\nimport { NineSliceGeometry } from './NineSliceGeometry';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { NineSliceSprite } from './NineSliceSprite';\n\nexport class NineSliceSpritePipe implements RenderPipe<NineSliceSprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'nineSliceSprite',\n    } as const;\n\n    private readonly _renderer: Renderer;\n    private readonly _gpuSpriteHash: Record<number, BatchableMesh> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public addRenderable(sprite: NineSliceSprite, _instructionSet: InstructionSet)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite._didSpriteUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        this._renderer.renderPipes.batch.addToBatch(gpuSprite);\n    }\n\n    public updateRenderable(sprite: NineSliceSprite)\n    {\n        const gpuSprite = this._gpuSpriteHash[sprite.uid];\n\n        if (sprite._didSpriteUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        gpuSprite.batcher.updateElement(gpuSprite);\n    }\n\n    public validateRenderable(sprite: NineSliceSprite): boolean\n    {\n        const texture = sprite._texture;\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (gpuSprite.texture._source !== texture._source)\n        {\n            return !gpuSprite.batcher.checkAndUpdateTexture(gpuSprite, texture);\n        }\n\n        return false;\n    }\n\n    public destroyRenderable(sprite: NineSliceSprite)\n    {\n        const batchableSprite = this._gpuSpriteHash[sprite.uid];\n\n        // this will call reset!\n        BigPool.return(batchableSprite as PoolItem);\n\n        this._gpuSpriteHash[sprite.uid] = null;\n    }\n\n    private _updateBatchableSprite(sprite: NineSliceSprite, batchableSprite: BatchableMesh)\n    {\n        sprite._didSpriteUpdate = false;\n        (batchableSprite.geometry as NineSliceGeometry)\n            .update(sprite);\n\n        // = sprite.bounds;\n        batchableSprite.texture = sprite._texture;\n    }\n\n    private _getGpuSprite(sprite: NineSliceSprite): BatchableMesh\n    {\n        return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);\n    }\n\n    private _initGPUSprite(sprite: NineSliceSprite): BatchableMesh\n    {\n        const batchableMesh = new BatchableMesh();\n\n        batchableMesh.geometry = new NineSliceGeometry();\n\n        batchableMesh.mesh = sprite;\n\n        batchableMesh.texture = sprite._texture;\n        batchableMesh.roundPixels = (this._renderer._roundPixels | sprite._roundPixels) as 0 | 1;\n\n        this._gpuSpriteHash[sprite.uid] = batchableMesh;\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        sprite.on('destroyed', () =>\n        {\n            this.destroyRenderable(sprite);\n        });\n\n        return batchableMesh;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuSpriteHash)\n        {\n            const batchableMesh = this._gpuSpriteHash[i];\n\n            batchableMesh.geometry.destroy();\n        }\n\n        (this._gpuSpriteHash as null) = null;\n        (this._renderer as null) = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { NineSliceSpritePipe } from './NineSliceSpritePipe';\n\nextensions.add(NineSliceSpritePipe);\n","export const tilingBit = {\n    name: 'tiling-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */`\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        `\n\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */`\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            } \n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        `\n    }\n\n};\n\nexport const tilingBitGl = {\n    name: 'tiling-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n        \n        `,\n        main: /* glsl */`\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        `\n\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        `,\n        main: /* glsl */`\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n        \n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n    \n        `\n    }\n\n};\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport {\n    compileHighShaderGlProgram,\n    compileHighShaderGpuProgram\n} from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { localUniformBit, localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { tilingBit, tilingBitGl } from './tilingBit';\n\nimport type { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport type { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\n\nlet gpuProgram: GpuProgram;\nlet glProgram: GlProgram;\n\nexport class TilingSpriteShader extends Shader\n{\n    constructor()\n    {\n        gpuProgram ??= compileHighShaderGpuProgram({\n            name: 'tiling-sprite-shader',\n            bits: [\n                localUniformBit,\n                tilingBit,\n                roundPixelsBit,\n            ],\n        });\n\n        glProgram ??= compileHighShaderGlProgram({\n            name: 'tiling-sprite-shader',\n            bits: [\n                localUniformBitGl,\n                tilingBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        const tilingUniforms = new UniformGroup({\n            uMapCoord: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: 'vec4<f32>' },\n            uClampOffset: { value: new Float32Array([0, 0]), type: 'vec2<f32>' },\n            uTextureTransform: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: 'vec4<f32>' },\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                localUniforms: new UniformGroup({\n                    uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n                    uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n                    uRound: { value: 0, type: 'f32' },\n                }),\n                tilingUniforms,\n                uTexture: Texture.EMPTY.source,\n                uSampler: Texture.EMPTY.source.style,\n            }\n        });\n    }\n\n    public updateUniforms(\n        width: number, height: number,\n        matrix: Matrix,\n        anchorX: number, anchorY: number,\n        texture: Texture\n    ): void\n    {\n        const tilingUniforms = this.resources.tilingUniforms;\n\n        const textureWidth = texture.width;\n        const textureHeight = texture.height;\n        const textureMatrix = texture.textureMatrix;\n\n        const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;\n\n        uTextureTransform.set(\n            matrix.a * textureWidth / width,\n            matrix.b * textureWidth / height,\n            matrix.c * textureHeight / width,\n            matrix.d * textureHeight / height,\n            matrix.tx / width,\n            matrix.ty / height);\n\n        uTextureTransform.invert();\n\n        tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;\n        tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;\n        tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;\n        tilingUniforms.uniforms.uTextureTransform = uTextureTransform;\n        tilingUniforms.uniforms.uSizeAnchor[0] = width;\n        tilingUniforms.uniforms.uSizeAnchor[1] = height;\n        tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;\n        tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;\n\n        if (texture)\n        {\n            this.resources.uTexture = texture.source;\n            this.resources.uSampler = texture.source.style;\n        }\n    }\n}\n","import { MeshGeometry } from '../../mesh/shared/MeshGeometry';\n\nexport class QuadGeometry extends MeshGeometry\n{\n    constructor()\n    {\n        super({\n            positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            indices: new Uint32Array([0, 1, 2, 0, 2, 3]),\n        });\n    }\n}\n","import type { TilingSprite } from '../TilingSprite';\n\nexport function setPositions(tilingSprite: TilingSprite, positions: Float32Array)\n{\n    const anchorX = tilingSprite.anchor.x;\n    const anchorY = tilingSprite.anchor.y;\n\n    positions[0] = -anchorX * tilingSprite.width;\n    positions[1] = -anchorY * tilingSprite.height;\n    positions[2] = (1 - anchorX) * tilingSprite.width;\n    positions[3] = -anchorY * tilingSprite.height;\n    positions[4] = (1 - anchorX) * tilingSprite.width;\n    positions[5] = (1 - anchorY) * tilingSprite.height;\n    positions[6] = -anchorX * tilingSprite.width;\n    positions[7] = (1 - anchorY) * tilingSprite.height;\n}\n","import type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { TypedArray } from '../../../rendering/renderers/shared/buffer/Buffer';\n\nexport function applyMatrix(array: TypedArray, stride: number, offset: number, matrix: Matrix)\n{\n    let index = 0;\n    const size = array.length / (stride || 2);\n\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n\n    offset *= stride;\n\n    while (index < size)\n    {\n        const x = array[offset];\n        const y = array[offset + 1];\n\n        array[offset] = (a * x) + (c * y) + tx;\n        array[offset + 1] = (b * x) + (d * y) + ty;\n\n        offset += stride;\n\n        index++;\n    }\n}\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { applyMatrix } from './applyMatrix';\n\nimport type { TilingSprite } from '../TilingSprite';\n\nexport function setUvs(tilingSprite: TilingSprite, uvs: Float32Array)\n{\n    const texture = tilingSprite.texture;\n\n    const width = texture.frame.width;\n    const height = texture.frame.height;\n\n    let anchorX = 0;\n    let anchorY = 0;\n\n    if (tilingSprite._applyAnchorToTexture)\n    {\n        anchorX = tilingSprite.anchor.x;\n        anchorY = tilingSprite.anchor.y;\n    }\n\n    uvs[0] = uvs[6] = -anchorX;\n    uvs[2] = uvs[4] = 1 - anchorX;\n    uvs[1] = uvs[3] = -anchorY;\n    uvs[5] = uvs[7] = 1 - anchorY;\n\n    const textureMatrix = Matrix.shared;\n\n    textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);\n\n    textureMatrix.tx /= tilingSprite.width;\n    textureMatrix.ty /= tilingSprite.height;\n\n    textureMatrix.invert();\n\n    textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);\n\n    applyMatrix(uvs, 2, 0, textureMatrix);\n}\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { ExtensionType } from '../../extensions/Extensions';\nimport { State } from '../../rendering/renderers/shared/state/State';\nimport { type Renderer, RendererType } from '../../rendering/renderers/types';\nimport { color32BitToUniform } from '../graphics/gpu/colorToUniform';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry';\nimport { TilingSpriteShader } from './shader/TilingSpriteShader';\nimport { QuadGeometry } from './utils/QuadGeometry';\nimport { setPositions } from './utils/setPositions';\nimport { setUvs } from './utils/setUvs';\n\nimport type { WebGLRenderer } from '../../rendering/renderers/gl/WebGLRenderer';\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { TilingSprite } from './TilingSprite';\n\ninterface RenderableData\n{\n    canBatch: boolean;\n    renderable: TilingSprite\n    batchableMesh?: BatchableMesh;\n    geometry?: MeshGeometry;\n    shader?: TilingSpriteShader;\n}\n\nconst sharedQuad = new QuadGeometry();\n\nexport class TilingSpritePipe implements RenderPipe<TilingSprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'tilingSprite',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private readonly _tilingSpriteDataHash: Record<number, RenderableData> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(renderable: TilingSprite): boolean\n    {\n        const tilingSpriteData = this._getTilingSpriteData(renderable);\n\n        const couldBatch = tilingSpriteData.canBatch;\n\n        this._updateCanBatch(renderable);\n\n        const canBatch = tilingSpriteData.canBatch;\n\n        if (canBatch && canBatch === couldBatch)\n        {\n            const { batchableMesh } = tilingSpriteData;\n\n            // we are batching.. check a texture change!\n            if (batchableMesh.texture._source !== renderable.texture._source)\n\n            { return !batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, renderable.texture); }\n        }\n\n        return (couldBatch !== canBatch);\n\n        // // TODO - only update if required?\n        // // only texture\n        // // only uvs\n        // // only positions?\n    }\n\n    public addRenderable(tilingSprite: TilingSprite, instructionSet: InstructionSet)\n    {\n        const batcher = this._renderer.renderPipes.batch;\n\n        // init\n        this._updateCanBatch(tilingSprite);\n\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        const { geometry, canBatch } = tilingSpriteData;\n\n        if (canBatch)\n        {\n            tilingSpriteData.batchableMesh ||= new BatchableMesh();\n\n            const batchableMesh = tilingSpriteData.batchableMesh;\n\n            if (tilingSprite._didTilingSpriteUpdate)\n            {\n                tilingSprite._didTilingSpriteUpdate = false;\n\n                this._updateBatchableMesh(tilingSprite);\n\n                batchableMesh.geometry = geometry;\n                batchableMesh.mesh = tilingSprite;\n                batchableMesh.texture = tilingSprite._texture;\n            }\n\n            batchableMesh.roundPixels = (this._renderer._roundPixels | tilingSprite._roundPixels) as 0 | 1;\n\n            batcher.addToBatch(batchableMesh);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            tilingSpriteData.shader ||= new TilingSpriteShader();\n\n            this.updateRenderable(tilingSprite);\n\n            instructionSet.add(tilingSprite);\n        }\n    }\n\n    public execute(tilingSprite: TilingSprite)\n    {\n        const { shader } = this._tilingSpriteDataHash[tilingSprite.uid];\n\n        shader.groups[0] = this._renderer.globalUniforms.bindGroup;\n\n        // deal with local uniforms...\n        const localUniforms = shader.resources.localUniforms.uniforms;\n\n        localUniforms.uTransformMatrix = tilingSprite.groupTransform;\n        localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;\n\n        color32BitToUniform(\n            tilingSprite.groupColorAlpha,\n            localUniforms.uColor,\n            0\n        );\n\n        this._renderer.encoder.draw({\n            geometry: sharedQuad,\n            shader,\n            state: State.default2d,\n        });\n    }\n\n    public updateRenderable(tilingSprite: TilingSprite)\n    {\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        const { canBatch } = tilingSpriteData;\n\n        if (canBatch)\n        {\n            const { batchableMesh } = tilingSpriteData;\n\n            if (tilingSprite._didTilingSpriteUpdate) this._updateBatchableMesh(tilingSprite);\n\n            batchableMesh.batcher.updateElement(batchableMesh);\n        }\n        else if (tilingSprite._didTilingSpriteUpdate)\n        {\n            const { shader } = tilingSpriteData;\n            // now update uniforms...\n\n            shader.updateUniforms(\n                tilingSprite.width,\n                tilingSprite.height,\n                tilingSprite._tileTransform.matrix,\n                tilingSprite.anchor.x,\n                tilingSprite.anchor.y,\n                tilingSprite.texture,\n            );\n        }\n\n        tilingSprite._didTilingSpriteUpdate = false;\n    }\n\n    public destroyRenderable(tilingSprite: TilingSprite)\n    {\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        tilingSpriteData.batchableMesh = null;\n\n        tilingSpriteData.shader?.destroy();\n\n        this._tilingSpriteDataHash[tilingSprite.uid] = null;\n    }\n\n    private _getTilingSpriteData(renderable: TilingSprite): RenderableData\n    {\n        return this._tilingSpriteDataHash[renderable.uid] || this._initTilingSpriteData(renderable);\n    }\n\n    private _initTilingSpriteData(tilingSprite: TilingSprite): RenderableData\n    {\n        const geometry = new MeshGeometry({\n            indices: sharedQuad.indices,\n            positions: sharedQuad.positions.slice(),\n            uvs: sharedQuad.uvs.slice(),\n        });\n\n        this._tilingSpriteDataHash[tilingSprite.uid] = {\n            canBatch: true,\n            renderable: tilingSprite,\n            geometry,\n        };\n\n        tilingSprite.on('destroyed', () =>\n        {\n            this.destroyRenderable(tilingSprite);\n        });\n\n        return this._tilingSpriteDataHash[tilingSprite.uid];\n    }\n\n    private _updateBatchableMesh(tilingSprite: TilingSprite)\n    {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n\n        const { geometry } = renderableData;\n\n        const style = tilingSprite.texture.source.style;\n\n        if (style.addressMode !== 'repeat')\n        {\n            style.addressMode = 'repeat';\n            style.update();\n        }\n\n        setUvs(tilingSprite, geometry.uvs);\n        setPositions(tilingSprite, geometry.positions);\n    }\n\n    public destroy()\n    {\n        for (const i in this._tilingSpriteDataHash)\n        {\n            this.destroyRenderable(this._tilingSpriteDataHash[i].renderable);\n        }\n\n        (this._tilingSpriteDataHash as null) = null;\n        this._renderer = null;\n    }\n\n    private _updateCanBatch(tilingSprite: TilingSprite)\n    {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n        const texture = tilingSprite.texture;\n\n        let _nonPowOf2wrapping = true;\n\n        if (this._renderer.type === RendererType.WEBGL)\n        {\n            _nonPowOf2wrapping = (this._renderer as WebGLRenderer).context.supports.nonPowOf2wrapping;\n        }\n\n        renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);\n\n        return renderableData.canBatch;\n    }\n}\n\n","import { extensions } from '../../extensions/Extensions';\nimport { TilingSpritePipe } from './TilingSpritePipe';\n\nextensions.add(TilingSpritePipe);\n","import EventEmitter from 'eventemitter3';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\n\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\n\n/** @memberof text */\nexport interface CharData\n{\n    /** Unique id of character */\n    id: number;\n    /** x-offset to apply when rendering character */\n    xOffset: number;\n    /** y-offset to apply when rendering character. */\n    yOffset: number;\n    /** Advancement to apply to next character. */\n    xAdvance: number;\n    /** The kerning values for this character. */\n    kerning: Record<string, number>;\n    /** The texture of the character. */\n    texture?: Texture;\n}\n\n/**\n * The raw data of a character in a bitmap font.\n * @memberof text\n */\nexport interface RawCharData extends Omit<CharData, 'texture'>\n{\n    /** The page of the font texture that the character is on. */\n    page: number;\n    /** The x position of the character in the page. */\n    x: number;\n    /** The y position of the character in the page. */\n    y: number;\n    /** The width of the character in the page. */\n    width: number;\n    /** The height of the character in the page. */\n    height: number;\n    /** The letter of the character. */\n    letter: string;\n}\n\n/**\n * The raw data of a bitmap font.\n * @memberof text\n */\nexport interface BitmapFontData\n{\n    /** The offset of the font face from the baseline. */\n    baseLineOffset: number;\n    /** The map of characters by character code. */\n    chars: Record<string, RawCharData>;\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    pages: {\n        /** Unique id for bitmap texture */\n        id: number;\n        /** File name */\n        file: string\n    }[];\n    /** The line-height of the font face in pixels. */\n    lineHeight: number;\n    /** The size of the font face in pixels. */\n    fontSize: number;\n    /** The name of the font face. */\n    fontFamily: string;\n    /** The range and type of the distance field for this font. */\n    distanceField?: {\n        /** Type of distance field */\n        type: 'sdf' | 'msdf' | 'none';\n        /** Range of the distance field in pixels */\n        range: number;\n    };\n}\n\ninterface BitmapFontEvents<Type>\n{\n    destroy: [Type];\n}\n\n/**\n * An abstract representation of a bitmap font.\n * @memberof text\n */\nexport abstract class AbstractBitmapFont<FontType>\n    extends EventEmitter<BitmapFontEvents<FontType>>\n    implements Omit<BitmapFontData, 'chars' | 'pages' | 'fontSize'>\n{\n    /** The map of characters by character code. */\n    public readonly chars: Record<string, CharData> = Object.create(null);\n\n    /**\n     * The line-height of the font face in pixels.\n     * @type {number}\n     */\n    public readonly lineHeight: BitmapFontData['lineHeight'] = 0;\n\n    /**\n     * The name of the font face\n     * @type {string}\n     */\n    public readonly fontFamily: BitmapFontData['fontFamily'] = '';\n    /** The metrics of the font face. */\n    public readonly fontMetrics: FontMetrics = { fontSize: 0, ascent: 0, descent: 0 };\n    /**\n     * The offset of the font face from the baseline.\n     * @type {number}\n     */\n    public readonly baseLineOffset: BitmapFontData['baseLineOffset'] = 0;\n    /** The range and type of the distance field for this font. */\n    public readonly distanceField: BitmapFontData['distanceField'] = { type: 'none', range: 0 };\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    public readonly pages: { texture: Texture }[] = [];\n\n    /** The size of the font face in pixels. */\n    public readonly baseMeasurementFontSize: number = 100;\n    protected baseRenderedFontSize = 100;\n\n    /**\n     * The name of the font face.\n     * @deprecated since 8.0.0 Use `fontFamily` instead.\n     */\n    public get font(): BitmapFontData['fontFamily']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.');\n        // #endif\n\n        return this.fontFamily;\n    }\n\n    /**\n     * The map of base page textures (i.e., sheets of glyphs).\n     * @deprecated since 8.0.0 Use `pages` instead.\n     */\n    public get pageTextures(): AbstractBitmapFont<FontType>['pages']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.');\n        // #endif\n\n        return this.pages;\n    }\n\n    /**\n     * The size of the font face in pixels.\n     * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.\n     */\n    public get size(): BitmapFontData['fontSize']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.');\n        // #endif\n\n        return this.fontMetrics.fontSize;\n    }\n\n    /**\n     * The kind of distance field for this font or \"none\".\n     * @deprecated since 8.0.0 Use `distanceField.type` instead.\n     */\n    public get distanceFieldRange(): NonNullable<BitmapFontData['distanceField']>['range']\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.');\n        // #endif\n\n        return this.distanceField.range;\n    }\n\n    /**\n     * The range of the distance field in pixels.\n     * @deprecated since 8.0.0 Use `distanceField.range` instead.\n     */\n    public get distanceFieldType(): NonNullable<BitmapFontData['distanceField']>['type']\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.');\n        // #endif\n\n        return this.distanceField.type;\n    }\n\n    public destroy(destroyTextures = false): void\n    {\n        this.emit('destroy', this as unknown as FontType);\n\n        this.removeAllListeners();\n\n        for (const i in this.chars)\n        {\n            this.chars[i].texture.destroy();\n        }\n\n        (this.chars as null) = null;\n\n        if (destroyTextures)\n        {\n            this.pages.forEach((page) => page.texture.destroy(true));\n            (this.pages as any) = null;\n        }\n    }\n}\n","/**\n * Processes the passed character set data and returns a flattened array of all the characters.\n *\n * Ignored because not directly exposed.\n * @ignore\n * @param {string | string[] | string[][] } chars\n * @returns {string[]} the flattened array of characters\n */\n\nexport function resolveCharacters(chars: string | (string | string[])[]): string[]\n{\n    // Skip unexpected 'empty set' check at end\n    if (chars === '')\n    {\n        return [];\n    }\n\n    // Split the chars string into individual characters\n    if (typeof chars === 'string')\n    {\n        chars = [chars];\n    }\n\n    // Handle an array of characters+ranges\n    const result: string[] = [];\n\n    for (let i = 0, j = chars.length; i < j; i++)\n    {\n        const item = chars[i];\n\n        // Handle range delimited by start/end chars\n        if (Array.isArray(item))\n        {\n            if (item.length !== 2)\n            {\n                throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);\n            }\n            if (item[0].length === 0 || item[1].length === 0)\n            {\n                throw new Error('[BitmapFont]: Invalid character delimiter.');\n            }\n\n            const startCode = item[0].charCodeAt(0);\n            const endCode = item[1].charCodeAt(0);\n\n            if (endCode < startCode)\n            {\n                throw new Error('[BitmapFont]: Invalid character range.');\n            }\n\n            for (let i = startCode, j = endCode; i <= j; i++)\n            {\n                result.push(String.fromCharCode(i));\n            }\n        }\n        else\n        {\n            result.push(...Array.from(item));\n        }\n    }\n\n    if (result.length === 0)\n    {\n        throw new Error('[BitmapFont]: Empty set when resolving characters.');\n    }\n\n    return result;\n}\n","import { Color } from '../../color/Color';\nimport { Rectangle } from '../../maths/shapes/Rectangle';\nimport { CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport { ImageSource } from '../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics';\nimport { fontStringFromTextStyle } from '../text/canvas/utils/fontStringFromTextStyle';\nimport { getCanvasFillStyle } from '../text/canvas/utils/getCanvasFillStyle';\nimport { AbstractBitmapFont } from './AbstractBitmapFont';\nimport { resolveCharacters } from './utils/resolveCharacters';\n\nimport type { ICanvasRenderingContext2D } from '../../environment/canvas/ICanvasRenderingContext2D';\nimport type { CanvasAndContext } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\nimport type { TextStyle } from '../text/TextStyle';\n\nexport interface DynamicBitmapFontOptions\n{\n    style: TextStyle\n    skipKerning?: boolean\n    resolution?: number\n    padding?: number\n    overrideFill?: boolean\n    overrideSize?: boolean\n}\n\n/**\n * A BitmapFont that generates its glyphs dynamically.\n * @memberof text\n * @ignore\n */\nexport class DynamicBitmapFont extends AbstractBitmapFont<DynamicBitmapFont>\n{\n    /**\n     * this is a resolution modifier for the font size..\n     * texture resolution will also be used to scale texture according to its font size also\n     */\n    public resolution = 1;\n    /** The pages of the font. */\n    public override readonly pages: {canvasAndContext?: CanvasAndContext, texture: Texture}[] = [];\n\n    private readonly _padding: number = 4;\n    private readonly _measureCache: Record<string, number> = Object.create(null);\n    private _currentChars: string[] = [];\n    private _currentX = 0;\n    private _currentY = 0;\n    private _currentPageIndex = -1;\n    private readonly _style: TextStyle;\n    private readonly _skipKerning: boolean = false;\n\n    /**\n     * @param options - The options for the dynamic bitmap font.\n     */\n    constructor(options: DynamicBitmapFontOptions)\n    {\n        super();\n\n        const dynamicOptions = options;\n        const style = dynamicOptions.style.clone();\n\n        if (dynamicOptions.overrideFill)\n        {\n            // assuming no shape fill..\n            style._fill.color = 0xffffff;\n            style._fill.alpha = 1;\n            style._fill.texture = Texture.WHITE;\n            style._fill.fill = null;\n        }\n\n        const requestedFontSize = style.fontSize;\n\n        // adjust font size to match the base measurement size\n        style.fontSize = this.baseMeasurementFontSize;\n\n        const font = fontStringFromTextStyle(style);\n\n        if (dynamicOptions.overrideSize)\n        {\n            if (style._stroke)\n            {\n                // we want the stroke to fit the size of the requested text, so we need to scale it\n                // accordingly (eg font size 20, with stroke 10 - stroke is 50% of size,\n                // as dynamic font is size 100, the stroke should be adjusted to 50 to make it look right)\n                style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;\n            }\n        }\n        else\n        {\n            style.fontSize = this.baseRenderedFontSize = requestedFontSize;\n        }\n\n        this._style = style;\n        this._skipKerning = dynamicOptions.skipKerning ?? false;\n        this.resolution = dynamicOptions.resolution ?? 1;\n        this._padding = dynamicOptions.padding ?? 4;\n\n        (this.fontMetrics as FontMetrics) = CanvasTextMetrics.measureFont(font);\n        (this.lineHeight as number) = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;\n    }\n\n    public ensureCharacters(chars: string): void\n    {\n        const charList = resolveCharacters(chars)\n            .filter((char) => !this._currentChars.includes(char))\n            .filter((char, index, self) => self.indexOf(char) === index);\n        // filter returns..\n\n        if (!charList.length) return;\n\n        this._currentChars = [...this._currentChars, ...charList];\n\n        let pageData;\n\n        if (this._currentPageIndex === -1)\n        {\n            pageData = this._nextPage();\n        }\n        else\n        {\n            pageData = this.pages[this._currentPageIndex];\n        }\n\n        let { canvas, context } = pageData.canvasAndContext;\n        let textureSource = pageData.texture.source;\n\n        const style = this._style;\n\n        let currentX = this._currentX;\n        let currentY = this._currentY;\n\n        const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;\n        const padding = this._padding * fontScale;\n\n        const widthScale = style.fontStyle === 'italic' ? 2 : 1;\n        let maxCharHeight = 0;\n        let skipTexture = false;\n\n        for (let i = 0; i < charList.length; i++)\n        {\n            const char = charList[i];\n\n            const metrics = CanvasTextMetrics.measureText(char, style, canvas, false);\n\n            // override the line height.. we want this to be the glyps heigh\n            // not the user specified one.\n            metrics.lineHeight = metrics.height;\n\n            const width = (widthScale * metrics.width) * fontScale;\n            const height = (metrics.height) * fontScale;\n\n            const paddedWidth = width + (padding * 2);\n            const paddedHeight = height + (padding * 2);\n\n            skipTexture = false;\n            // don't let empty characters count towards the maxCharHeight\n            if (char !== '\\n' && char !== '\\r' && char !== '\\t' && char !== ' ')\n            {\n                skipTexture = true;\n                maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));// / 1.5;\n            }\n\n            if (currentX + paddedWidth > 512)\n            {\n                currentY += maxCharHeight;\n\n                // reset the line x and height..\n                maxCharHeight = paddedHeight;\n                currentX = 0;\n\n                if (currentY + maxCharHeight > 512)\n                {\n                    textureSource.update();\n\n                    const pageData = this._nextPage();\n\n                    canvas = pageData.canvasAndContext.canvas;\n                    context = pageData.canvasAndContext.context;\n                    textureSource = pageData.texture.source;\n\n                    currentY = 0;\n                }\n            }\n\n            const xAdvance = (width / fontScale)\n                - (style.dropShadow?.distance ?? 0)\n                - (style._stroke?.width ?? 0);\n\n            // This is in coord space of the measurements.. not the texture\n            this.chars[char] = {\n                id: char.codePointAt(0),\n                xOffset: -this._padding,\n                yOffset: -this._padding,\n                xAdvance,\n                kerning: {},\n            };\n\n            if (skipTexture)\n            {\n                this._drawGlyph(\n                    context,\n                    metrics,\n                    currentX + padding,\n                    currentY + padding,\n                    fontScale,\n                    style,\n                );\n\n                const px = textureSource.width * fontScale;\n                const py = textureSource.height * fontScale;\n\n                const frame = new Rectangle(\n                    ((currentX) / px) * textureSource.width,\n                    ((currentY) / py) * textureSource.height,\n                    ((paddedWidth) / px) * textureSource.width,\n                    ((paddedHeight) / py) * textureSource.height,\n                );\n\n                this.chars[char].texture = new Texture({\n                    source: textureSource,\n                    frame,\n                });\n\n                currentX += Math.ceil(paddedWidth);\n            }\n\n            // now add it to the font data..\n        }\n\n        textureSource.update();\n\n        this._currentX = currentX;\n        this._currentY = currentY;\n\n        // now apply kerning..\n        this._skipKerning && this._applyKerning(charList, context);\n    }\n\n    /**\n     * @deprecated since 8.0.0\n     * The map of base page textures (i.e., sheets of glyphs).\n     */\n    public override get pageTextures(): DynamicBitmapFont['pages']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.');\n        // #endif\n\n        return this.pages;\n    }\n\n    private _applyKerning(newChars: string[], context: ICanvasRenderingContext2D): void\n    {\n        const measureCache = this._measureCache;\n\n        for (let i = 0; i < newChars.length; i++)\n        {\n            const first = newChars[i];\n\n            for (let j = 0; j < this._currentChars.length; j++)\n            {\n                // first go through new char being first\n                const second = this._currentChars[j];\n\n                let c1 = measureCache[first];\n\n                if (!c1) c1 = measureCache[first] = context.measureText(first).width;\n\n                let c2 = measureCache[second];\n\n                if (!c2) c2 = measureCache[second] = context.measureText(second).width;\n\n                let total = context.measureText(first + second).width;\n                let amount = total - (c1 + c2);\n\n                if (amount)\n                {\n                    this.chars[first].kerning[second] = amount;\n                }\n\n                // then go through new char being second\n                total = context.measureText(first + second).width;\n                amount = total - (c1 + c2);\n\n                if (amount)\n                {\n                    this.chars[second].kerning[first] = amount;\n                }\n            }\n        }\n    }\n\n    private _nextPage(): {canvasAndContext: CanvasAndContext, texture: Texture}\n    {\n        this._currentPageIndex++;\n\n        const textureResolution = this.resolution;\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(512, 512, textureResolution);\n\n        this._setupContext(canvasAndContext.context, this._style, textureResolution);\n\n        const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);\n        const texture = new Texture({\n            source: new ImageSource({\n                resource: canvasAndContext.canvas,\n                resolution,\n                alphaMode: 'premultiply-alpha-on-upload'\n            }),\n\n        });\n\n        const pageData = {\n            canvasAndContext,\n            texture,\n        };\n\n        this.pages[this._currentPageIndex] = pageData;\n\n        return pageData;\n    }\n\n    // canvas style!\n    private _setupContext(context: ICanvasRenderingContext2D, style: TextStyle, resolution: number): void\n    {\n        style.fontSize = this.baseRenderedFontSize;\n        context.scale(resolution, resolution);\n        context.font = fontStringFromTextStyle(style);\n        style.fontSize = this.baseMeasurementFontSize;\n        context.textBaseline = style.textBaseline;\n\n        const stroke = style._stroke;\n        const strokeThickness = stroke?.width ?? 0;\n\n        if (stroke)\n        {\n            context.lineWidth = strokeThickness;\n            context.lineJoin = stroke.join;\n            context.miterLimit = stroke.miterLimit;\n\n            // TODO prolly cache this??\n            context.strokeStyle = getCanvasFillStyle(stroke, context);\n        }\n\n        if (style._fill)\n        {\n            // set canvas text styles\n            context.fillStyle = getCanvasFillStyle(style._fill, context);\n        }\n\n        if (style.dropShadow)\n        {\n            const shadowOptions = style.dropShadow;\n            const rgb = Color.shared.setValue(shadowOptions.color).toArray();\n\n            const dropShadowBlur = shadowOptions.blur * resolution;\n            const dropShadowDistance = shadowOptions.distance * resolution;\n\n            context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;\n            context.shadowBlur = dropShadowBlur;\n            context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n            context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;\n        }\n        else\n        {\n            context.shadowColor = 'black';\n            context.shadowBlur = 0;\n            context.shadowOffsetX = 0;\n            context.shadowOffsetY = 0;\n        }\n    }\n\n    private _drawGlyph(\n        context: ICanvasRenderingContext2D,\n        metrics: CanvasTextMetrics,\n        x: number,\n        y: number,\n        fontScale: number,\n        style: TextStyle\n    ): void\n    {\n        const char = metrics.text;\n        const fontProperties = metrics.fontProperties;\n        const stroke = style._stroke;\n\n        const strokeThickness = (stroke?.width ?? 0) * fontScale;\n\n        const tx = x + (strokeThickness / 2);\n        const ty = y - (strokeThickness / 2);\n\n        const descent = fontProperties.descent * fontScale;\n        const lineHeight = metrics.lineHeight * fontScale;\n\n        if (style.stroke && strokeThickness)\n        {\n            context.strokeText(char, tx, ty + lineHeight - descent);\n        }\n\n        if (style._fill)\n        {\n            context.fillText(char, tx, ty + lineHeight - descent);\n        }\n    }\n\n    public override destroy(): void\n    {\n        super.destroy();\n\n        for (let i = 0; i < this.pages.length; i++)\n        {\n            const { canvasAndContext, texture } = this.pages[i];\n\n            CanvasPool.returnCanvasAndContext(canvasAndContext);\n            texture.destroy(true);\n        }\n\n        (this.pages as null) = null;\n    }\n}\n","import type { TextStyle } from '../../text/TextStyle';\nimport type { AbstractBitmapFont } from '../AbstractBitmapFont';\n\nexport interface BitmapTextLayoutData\n{\n    width: number;\n    height: number;\n    scale: number;\n    offsetY: number;\n    lines: {\n        width: number\n        charPositions: number[],\n        chars: string[],\n        // / spaces: number\n        spaceWidth: number\n        spacesIndex: number[]\n    }[];\n}\n\nexport function getBitmapTextLayout(chars: string[], style: TextStyle, font: AbstractBitmapFont<any>): BitmapTextLayoutData\n{\n    const layoutData: BitmapTextLayoutData = {\n        width: 0,\n        height: 0,\n        offsetY: 0,\n        scale: style.fontSize / font.baseMeasurementFontSize,\n        lines: [{\n            width: 0,\n            charPositions: [] as number[],\n            spaceWidth: 0,\n            spacesIndex: [],\n            chars: [],\n        }]\n    };\n\n    layoutData.offsetY = font.baseLineOffset;\n\n    let currentLine = layoutData.lines[0];\n\n    let previousChar: string = null;\n    let firstWord = true;\n    //    let spaceCount = 0;\n\n    const currentWord = {\n        spaceWord: false,\n        width: 0,\n        start: 0,\n        index: 0, // use index to not modify the array as we use it a lot!\n        positions: [] as number[],\n        chars: [] as string[],\n    };\n\n    const nextWord = (word: typeof currentWord) =>\n    {\n        const start = currentLine.width;\n\n        for (let j = 0; j < currentWord.index; j++)\n        {\n            const position = word.positions[j];\n\n            currentLine.chars.push(word.chars[j]);\n            currentLine.charPositions.push(position + start);\n        }\n\n        currentLine.width += word.width;\n\n        firstWord = false;\n\n        // reset the word..\n        currentWord.width = 0;\n        currentWord.index = 0;\n        currentWord.chars.length = 0;\n\n        // spaceCount = 0;\n    };\n\n    const nextLine = () =>\n    {\n        let index = currentLine.chars.length - 1;\n        let lastChar = currentLine.chars[index];\n\n        while (lastChar === ' ')\n        {\n            currentLine.width -= font.chars[lastChar].xAdvance;\n            lastChar = currentLine.chars[--index];\n        }\n\n        layoutData.width = Math.max(layoutData.width, currentLine.width);\n\n        currentLine = {\n            width: 0,\n            charPositions: [],\n            chars: [],\n            spaceWidth: 0,\n            spacesIndex: [],\n        };\n\n        firstWord = true;\n        layoutData.lines.push(currentLine);\n        layoutData.height += font.lineHeight;\n    };\n\n    const scale = font.baseMeasurementFontSize / style.fontSize;\n\n    const adjustedLetterSpacing = style.letterSpacing * scale;\n    const adjustedWordWrapWidth = style.wordWrapWidth * scale;\n\n    // loop an extra time to force a line break..\n    for (let i = 0; i < chars.length + 1; i++)\n    {\n        let char: string;\n\n        const isEnd = i === chars.length;\n\n        if (!isEnd)\n        {\n            char = chars[i];\n        }\n\n        const charData = font.chars[char] || font.chars[' '];\n\n        const isSpace = (/(?:\\s)/).test(char);\n        const isWordBreak = isSpace || char === '\\r' || char === '\\n' || isEnd;\n\n        // spaceCount++;\n        // wasSpace = isSpace;\n\n        if (isWordBreak)\n        {\n            const addWordToNextLine = !firstWord\n                && style.wordWrap\n                && (currentLine.width + currentWord.width - adjustedLetterSpacing) > adjustedWordWrapWidth;\n\n            if (addWordToNextLine)\n            {\n                nextLine();\n\n                nextWord(currentWord);\n\n                if (!isEnd)\n                {\n                    currentLine.charPositions.push(0);\n                }\n            }\n            else\n            {\n                currentWord.start = currentLine.width;\n\n                nextWord(currentWord);\n\n                if (!isEnd)\n                {\n                    currentLine.charPositions.push(0);\n                }\n            }\n\n            if (char === '\\r' || char === '\\n')\n            {\n                if (currentLine.width !== 0)\n                {\n                    nextLine();\n                }\n            }\n            else if (!isEnd)\n            {\n                const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;\n\n                currentLine.width += spaceWidth;\n\n                currentLine.spaceWidth = spaceWidth;\n                currentLine.spacesIndex.push(currentLine.charPositions.length);\n                currentLine.chars.push(char);\n\n                // spaceCount++;\n            }\n        }\n        else\n        {\n            const kerning = charData.kerning[previousChar] || 0;\n\n            const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;\n\n            currentWord.positions[currentWord.index++] = currentWord.width + kerning;\n            currentWord.chars.push(char);\n\n            currentWord.width += nextCharWidth;\n        }\n\n        previousChar = char;\n        // lastChar = char;\n    }\n\n    nextLine();\n\n    if (style.align === 'center')\n    {\n        alignCenter(layoutData);\n    }\n    else if (style.align === 'right')\n    {\n        alignRight(layoutData);\n    }\n    else if (style.align === 'justify')\n    {\n        alignJustify(layoutData);\n    }\n\n    return layoutData;\n}\n\nfunction alignCenter(measurementData: BitmapTextLayoutData)\n{\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n        const offset = ((measurementData.width / 2) - (line.width / 2));\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            line.charPositions[j] += offset;\n        }\n    }\n}\n\nfunction alignRight(measurementData: BitmapTextLayoutData)\n{\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n        const offset = ((measurementData.width) - (line.width));\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            line.charPositions[j] += offset;\n        }\n    }\n}\n\nfunction alignJustify(measurementData: BitmapTextLayoutData)\n{\n    const width = measurementData.width;\n\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n\n        let indy = 0;\n        let spaceIndex = line.spacesIndex[indy++];\n\n        let offset = 0;\n\n        const totalSpaces = line.spacesIndex.length;\n\n        const newSpaceWidth = (width - line.width) / totalSpaces;\n\n        const spaceWidth = newSpaceWidth;\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            if (j === spaceIndex)\n            {\n                spaceIndex = line.spacesIndex[indy++];\n\n                offset += spaceWidth;\n            }\n\n            line.charPositions[j] += offset;\n        }\n    }\n}\n","import { Cache } from '../../assets/cache/Cache';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { TextStyle } from '../text/TextStyle';\nimport { DynamicBitmapFont } from './DynamicBitmapFont';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout';\nimport { resolveCharacters } from './utils/resolveCharacters';\n\nimport type { TextStyleOptions } from '../text/TextStyle';\nimport type { BitmapFont } from './BitmapFont';\nimport type { BitmapTextLayoutData } from './utils/getBitmapTextLayout';\n\n/**\n *\n * The options for installing a new BitmapFont. Once installed the font will be available for use in the BitmapText.\n * It can be accessed by the `fontFamily` property of the TextStyle.\n *\n * Install a new BitmapFont will create the characters provided for the font and store them in the cache.\n * But don't worry, if a character is requested that hasn't been generated yet, it will be created on the fly.\n * @memberof text\n */\nexport interface BitmapFontInstallOptions\n{\n    /** the name of the font, this will be the name you use in the fontFamily of text style to access this font */\n    name?: string;\n    /**\n     * Characters included in the font set. You can also use ranges.\n     * For example, `[['a', 'z'], ['A', 'Z'], \"!@#$%^&*()~{}[] \"]`.\n     * Don't forget to include spaces ' ' in your character set!\n     * @default BitmapFont.ALPHANUMERIC\n     */\n    chars?: string | (string | string[])[];\n    /**\n     * Render resolution for glyphs.\n     * @default 1\n     */\n    resolution?: number;\n    /**\n     * Padding between glyphs on texture atlas. Lower values could mean more visual artifacts\n     * and bleeding from other glyphs, larger values increase the space required on the texture.\n     * @default 4\n     */\n    padding?: number;\n    /**\n     * Skip generation of kerning information for the BitmapFont.\n     * If true, this could potentially increase the performance, but may impact the rendered text appearance.\n     * @default false\n     */\n    skipKerning?: boolean;\n    /** Style options to render with BitmapFont. */\n    style?: TextStyle | TextStyleOptions;\n}\n\n/**\n * The BitmapFontManager is a helper that exists to install and uninstall fonts\n * into the cache for BitmapText objects.\n * @memberof text\n * @name BitmapFontManager\n * @example\n * import { BitmapFontManager, BitmapText } from 'pixi.js';\n *\n * BitmapFontManager.install({\n *   name: 'TitleFont',\n *   style: {}\n * });\n *\n * const title = new BitmapText({ text: 'This is the title', style: { fontFamily: 'TitleFont' }});\n */\nclass BitmapFontManagerClass\n{\n    /**\n     * This character set includes all the letters in the alphabet (both lower- and upper- case).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.ALPHA })\n     */\n    public readonly ALPHA = [['a', 'z'], ['A', 'Z'], ' '];\n\n    /**\n     * This character set includes all decimal digits (from 0 to 9).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.NUMERIC })\n     */\n    public readonly NUMERIC = [['0', '9']];\n\n    /**\n     * This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.\n     * @type {string[][]}\n     */\n    public readonly ALPHANUMERIC = [['a', 'z'], ['A', 'Z'], ['0', '9'], ' '];\n\n    /**\n     * This character set consists of all the ASCII table.\n     * @member {string[][]}\n     * @see http://www.asciitable.com/\n     */\n    public readonly ASCII = [[' ', '~']];\n\n    /** Default options for installing a new BitmapFont. */\n    public defaultOptions: Omit<BitmapFontInstallOptions, 'style'> = {\n        chars: this.ALPHANUMERIC,\n        resolution: 1,\n        padding: 4,\n        skipKerning: false,\n    };\n\n    /**\n     * Get a font for the specified text and style.\n     * @param text - The text to get the font for\n     * @param style - The style to use\n     */\n    public getFont(text: string, style: TextStyle): BitmapFont\n    {\n        let fontFamilyKey = `${style.fontFamily as string}-bitmap`;\n        let overrideFill = true;\n\n        // assuming there is no texture we can use a tint!\n        if (style._fill.fill)\n        {\n            fontFamilyKey += style._fill.fill.uid;\n            overrideFill = false;\n        }\n\n        // first get us the the right font...\n        if (!Cache.has(fontFamilyKey))\n        {\n            const fnt = new DynamicBitmapFont({\n                style,\n                overrideFill,\n                overrideSize: true,\n                ...this.defaultOptions,\n            });\n\n            fnt.once('destroy', () => Cache.remove(fontFamilyKey));\n\n            Cache.set(\n                fontFamilyKey as string,\n                fnt\n            );\n        }\n\n        const dynamicFont = Cache.get(fontFamilyKey);\n\n        (dynamicFont as DynamicBitmapFont).ensureCharacters?.(text);\n\n        return dynamicFont;\n    }\n\n    /**\n     * Get the layout of a text for the specified style.\n     * @param text - The text to get the layout for\n     * @param style - The style to use\n     */\n    public getLayout(text: string, style: TextStyle): BitmapTextLayoutData\n    {\n        const bitmapFont = this.getFont(text, style);\n\n        return getBitmapTextLayout(text.split(''), style, bitmapFont);\n    }\n\n    /**\n     * Measure the text using the specified style.\n     * @param text - The text to measure\n     * @param style - The style to use\n     */\n    public measureText(text: string, style: TextStyle): { width: number; height: number; scale: number; offsetY: number }\n    {\n        return this.getLayout(text, style);\n    }\n\n    /**\n     * Generates a bitmap-font for the given style and character set\n     * @param options - Setup options for font generation.\n     * @returns Font generated by style options.\n     * @example\n     * import { BitmapFontManager, BitmapText } from 'pixi.js';\n     *\n     * BitmapFontManager.install('TitleFont', {\n     *     fontFamily: 'Arial',\n     *     fontSize: 12,\n     *     strokeThickness: 2,\n     *     fill: 'purple',\n     * });\n     *\n     * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });\n     */\n    public install(options: BitmapFontInstallOptions): BitmapFont;\n    /** @deprecated since 7.0.0 */\n    public install(name: string, style?: TextStyle | TextStyleOptions, options?: BitmapFontInstallOptions): BitmapFont;\n    // eslint-disable-next-line max-len\n    public install(...args: [string | BitmapFontInstallOptions, (TextStyle | TextStyleOptions)?, BitmapFontInstallOptions?]): BitmapFont\n    {\n        let options = args[0] as BitmapFontInstallOptions;\n\n        if (typeof options === 'string')\n        {\n            options = {\n                name: options,\n                style: args[1],\n                chars: args[2]?.chars,\n                resolution: args[2]?.resolution,\n                padding: args[2]?.padding,\n                skipKerning: args[2]?.skipKerning,\n            } as BitmapFontInstallOptions;\n\n            // #if _DEBUG\n            // eslint-disable-next-line max-len\n            deprecation(v8_0_0, 'BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})');\n            // #endif\n        }\n\n        const name = options?.name;\n\n        if (!name)\n        {\n            throw new Error('[BitmapFontManager] Property `name` is required.');\n        }\n\n        options = { ...this.defaultOptions, ...options };\n\n        const textStyle = options.style;\n\n        const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);\n        const overrideFill = style._fill.fill !== null && style._fill.fill !== undefined;\n        const font = new DynamicBitmapFont({\n            style,\n            overrideFill,\n            skipKerning: options.skipKerning,\n            padding: options.padding,\n            resolution: options.resolution,\n            overrideSize: false\n        });\n\n        const flatChars = resolveCharacters(options.chars);\n\n        font.ensureCharacters(flatChars.join(''));\n\n        Cache.set(`${name}-bitmap`, font);\n\n        font.once('destroy', () => Cache.remove(`${name}-bitmap`));\n\n        return font;\n    }\n\n    /**\n     * Uninstalls a bitmap font from the cache.\n     * @param {string} name - The name of the bitmap font to uninstall.\n     */\n    public uninstall(name: string)\n    {\n        const cacheKey = `${name}-bitmap`;\n        const font = Cache.get<BitmapFont>(cacheKey);\n\n        if (font)\n        {\n            Cache.remove(cacheKey);\n            font.destroy();\n        }\n    }\n}\n\nexport const BitmapFontManager = new BitmapFontManagerClass();\n","import { Rectangle } from '../../maths/shapes/Rectangle';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { AbstractBitmapFont } from './AbstractBitmapFont';\nimport { BitmapFontManager } from './BitmapFontManager';\n\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\nimport type { BitmapFontData } from './AbstractBitmapFont';\nimport type { BitmapFontInstallOptions } from './BitmapFontManager';\n\n/**\n * Options for creating a BitmapFont.\n * @memberof text\n */\nexport interface BitmapFontOptions\n{\n    data: BitmapFontData\n    textures: Texture[]\n}\n\n/**\n * A BitmapFont object represents a particular font face, size, and style.\n * @memberof text\n */\nexport class BitmapFont extends AbstractBitmapFont<BitmapFont>\n{\n    /** the url of the font */\n    public url?: string;\n\n    constructor(options: BitmapFontOptions, url?: string)\n    {\n        super();\n\n        const { textures, data } = options;\n\n        Object.keys(data.pages).forEach((key: string) =>\n        {\n            const pageData = data.pages[parseInt(key, 10)];\n\n            const texture = textures[pageData.id];\n\n            this.pages.push({ texture });\n        });\n\n        Object.keys(data.chars).forEach((key: string) =>\n        {\n            const charData = data.chars[key];\n            const textureSource = textures[charData.page].source;\n\n            const frameReal = new Rectangle(\n                charData.x,\n                charData.y,\n                charData.width,\n                charData.height,\n            );\n\n            const texture = new Texture({\n                source: textureSource,\n                frame: frameReal\n            });\n\n            this.chars[key] = {\n                id: key.codePointAt(0),\n                xOffset: charData.xOffset,\n                yOffset: charData.yOffset,\n                xAdvance: charData.xAdvance,\n                kerning: charData.kerning ?? {},\n                texture,\n            };\n        });\n\n        this.baseRenderedFontSize = data.fontSize;\n\n        (this.baseMeasurementFontSize as number) = data.fontSize;\n        (this.fontMetrics as FontMetrics) = {\n            ascent: 0,\n            descent: 0,\n            fontSize: data.fontSize,\n        };\n        (this.baseLineOffset as number) = data.baseLineOffset;\n        (this.lineHeight as number) = data.lineHeight;\n        (this.fontFamily as string) = data.fontFamily;\n        (this.distanceField as { type: string, range: number }) = data.distanceField ?? {\n            type: 'none',\n            range: 0,\n        };\n\n        this.url = url;\n    }\n\n    /** Destroys the BitmapFont object. */\n    public override destroy(): void\n    {\n        super.destroy();\n\n        for (let i = 0; i < this.pages.length; i++)\n        {\n            const { texture } = this.pages[i];\n\n            texture.destroy(true);\n        }\n\n        (this.pages as null) = null;\n    }\n\n    /**\n     * Generates a bitmap-font for the given style and character set\n     * @param options - Setup options for font generation.\n     * @returns Font generated by style options.\n     * @example\n     * import { BitmapFont, BitmapText } from 'pixi.js';\n     *\n     * BitmapFont.install('TitleFont', {\n     *     fontFamily: 'Arial',\n     *     fontSize: 12,\n     *     strokeThickness: 2,\n     *     fill: 'purple',\n     * });\n     *\n     * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });\n     */\n    public static install(options: BitmapFontInstallOptions)\n    {\n        BitmapFontManager.install(options);\n    }\n    /**\n     * Uninstalls a bitmap font from the cache.\n     * @param {string} name - The name of the bitmap font to uninstall.\n     */\n    public static uninstall(name: string)\n    {\n        BitmapFontManager.uninstall(name);\n    }\n}\n","import type { BitmapFontData, RawCharData } from '../AbstractBitmapFont';\n\n/**\n * Internal data format used to convert to BitmapFontData.\n * @private\n */\nexport interface BitmapFontRawData\n{\n    info: {\n        face: string;\n        size: string;\n    }[];\n    common: { lineHeight: string, base: string }[];\n    page: {\n        id: string;\n        file: string;\n    }[];\n    chars: {\n        count: number;\n    }[];\n    char: {\n        id: string\n        page: string\n        xoffset: string\n        yoffset: string\n        xadvance: string,\n        x: string\n        y: string\n        width: string\n        height: string\n        letter?: string\n        char?: string\n    }[];\n    kernings?: {\n        count: number;\n    }[];\n    kerning?: {\n        first: string;\n        second: string;\n        amount: string;\n    }[];\n    distanceField?: {\n        fieldType: 'sdf' | 'msdf' | 'none';\n        distanceRange: string;\n    }[]\n}\n\nexport const bitmapFontTextParser = {\n    test(data: string | XMLDocument | BitmapFontData): boolean\n    {\n        return typeof data === 'string' && data.startsWith('info face=');\n    },\n\n    parse(txt: string): BitmapFontData\n    {\n        // Retrieve data item\n        const items = txt.match(/^[a-z]+\\s+.+$/gm);\n        const rawData: BitmapFontRawData = {\n            info: [],\n            common: [],\n            page: [],\n            char: [],\n            chars: [],\n            kerning: [],\n            kernings: [],\n            distanceField: [],\n        };\n\n        for (const i in items)\n        {\n            // Extract item name\n            const name = items[i].match(/^[a-z]+/gm)[0] as keyof BitmapFontRawData;\n\n            // Extract item attribute list as string ex.: \"width=10\"\n            const attributeList = items[i].match(/[a-zA-Z]+=([^\\s\"']+|\"([^\"]*)\")/gm);\n\n            // Convert attribute list into an object\n            const itemData: any = {};\n\n            for (const i in attributeList)\n            {\n                // Split key-value pairs\n                const split = attributeList[i].split('=');\n                const key = split[0];\n\n                // Remove eventual quotes from value\n                const strValue = split[1].replace(/\"/gm, '');\n\n                // Try to convert value into float\n                const floatValue = parseFloat(strValue);\n\n                // Use string value case float value is NaN\n                const value = isNaN(floatValue) ? strValue : floatValue;\n\n                itemData[key] = value;\n            }\n\n            // Push current item to the resulting data\n            rawData[name].push(itemData);\n        }\n\n        const font: BitmapFontData = {\n            chars: {},\n            pages: [],\n            lineHeight: 0,\n            fontSize: 0,\n            fontFamily: '',\n            distanceField: null,\n            baseLineOffset: 0,\n        };\n\n        const [info] = rawData.info;\n        const [common] = rawData.common;\n        const [distanceField] = rawData.distanceField ?? [];\n\n        if (distanceField)\n        {\n            font.distanceField = {\n                range: parseInt(distanceField.distanceRange, 10),\n                type: distanceField.fieldType\n            };\n        }\n\n        font.fontSize = parseInt(info.size, 10);\n        font.fontFamily = info.face;\n        font.lineHeight = parseInt(common.lineHeight, 10);\n\n        const page = rawData.page;\n\n        for (let i = 0; i < page.length; i++)\n        {\n            font.pages.push({\n                id: parseInt(page[i].id, 10) || 0,\n                file: page[i].file,\n            });\n        }\n\n        const map: Record<string, string> = {};\n\n        font.baseLineOffset = font.lineHeight - parseInt(common.base, 10);\n\n        const char = rawData.char;\n\n        for (let i = 0; i < char.length; i++)\n        {\n            const charNode = char[i];\n            const id = parseInt(charNode.id, 10);\n\n            let letter = charNode.letter ?? charNode.char ?? String.fromCharCode(id);\n\n            if (letter === 'space')letter = ' ';\n\n            map[id] = letter;\n\n            font.chars[letter] = {\n                id,\n                // texture deets..\n                page: parseInt(charNode.page, 10) || 0,\n                x: parseInt(charNode.x, 10),\n                y: parseInt(charNode.y, 10),\n                width: parseInt(charNode.width, 10),\n                height: parseInt(charNode.height, 10),\n                xOffset: parseInt(charNode.xoffset, 10),\n                yOffset: parseInt(charNode.yoffset, 10),\n                xAdvance: parseInt(charNode.xadvance, 10),\n                kerning: {},\n            } as RawCharData;\n        }\n\n        const kerning = rawData.kerning || [];\n\n        for (let i = 0; i < kerning.length; i++)\n        {\n            const first = parseInt(kerning[i].first, 10);\n            const second = parseInt(kerning[i].second, 10);\n            const amount = parseInt(kerning[i].amount, 10);\n\n            font.chars[map[second]].kerning[map[first]] = amount;\n        }\n\n        return font;\n    }\n};\n","import type { BitmapFontData, RawCharData } from '../AbstractBitmapFont';\n\nexport const bitmapFontXMLParser = {\n    test(data: string | XMLDocument | BitmapFontData): boolean\n    {\n        const xml = data as Document;\n\n        return typeof xml !== 'string'\n            && 'getElementsByTagName' in xml\n            && xml.getElementsByTagName('page').length\n            && xml.getElementsByTagName('info')[0].getAttribute('face') !== null;\n    },\n\n    parse(xml: Document): BitmapFontData\n    {\n        const data: BitmapFontData = {\n            chars: {},\n            pages: [],\n            lineHeight: 0,\n            fontSize: 0,\n            fontFamily: '',\n            distanceField: null,\n            baseLineOffset: 0,\n        };\n\n        const info = xml.getElementsByTagName('info')[0];\n        const common = xml.getElementsByTagName('common')[0];\n        const distanceField = xml.getElementsByTagName('distanceField')[0];\n\n        if (distanceField)\n        {\n            data.distanceField = {\n                type: distanceField.getAttribute('fieldType') as 'sdf' | 'msdf' | 'none',\n                range: parseInt(distanceField.getAttribute('distanceRange'), 10),\n            };\n        }\n\n        // pages and chars:\n        const page = xml.getElementsByTagName('page');\n        const char = xml.getElementsByTagName('char');\n        const kerning = xml.getElementsByTagName('kerning');\n\n        data.fontSize = parseInt(info.getAttribute('size'), 10);\n        data.fontFamily = info.getAttribute('face');\n        data.lineHeight = parseInt(common.getAttribute('lineHeight'), 10);\n\n        for (let i = 0; i < page.length; i++)\n        {\n            data.pages.push({\n                id: parseInt(page[i].getAttribute('id'), 10) || 0,\n                file: page[i].getAttribute('file'),\n            });\n        }\n\n        const map: Record<string, string> = {};\n\n        data.baseLineOffset = data.lineHeight - parseInt(common.getAttribute('base'), 10);\n\n        for (let i = 0; i < char.length; i++)\n        {\n            const charNode = char[i];\n            const id = parseInt(charNode.getAttribute('id'), 10);\n\n            let letter = charNode.getAttribute('letter') ?? charNode.getAttribute('char') ?? String.fromCharCode(id);\n\n            if (letter === 'space')letter = ' ';\n\n            map[id] = letter;\n\n            data.chars[letter] = {\n                id,\n                // texture deets..\n                page: parseInt(charNode.getAttribute('page'), 10) || 0,\n                x: parseInt(charNode.getAttribute('x'), 10),\n                y: parseInt(charNode.getAttribute('y'), 10),\n                width: parseInt(charNode.getAttribute('width'), 10),\n                height: parseInt(charNode.getAttribute('height'), 10),\n\n                // render deets..\n                xOffset: parseInt(charNode.getAttribute('xoffset'), 10),\n                yOffset: parseInt(charNode.getAttribute('yoffset'), 10), // + baseLineOffset,\n                xAdvance: parseInt(charNode.getAttribute('xadvance'), 10),\n                kerning: {},\n            } as RawCharData;\n        }\n\n        for (let i = 0; i < kerning.length; i++)\n        {\n            const first = parseInt(kerning[i].getAttribute('first'), 10);\n            const second = parseInt(kerning[i].getAttribute('second'), 10);\n            const amount = parseInt(kerning[i].getAttribute('amount'), 10);\n\n            data.chars[map[second]].kerning[map[first]] = amount;// * 10000;\n        }\n\n        return data;\n    }\n};\n","import { DOMAdapter } from '../../../environment/adapter';\nimport { bitmapFontXMLParser } from './bitmapFontXMLParser';\n\nimport type { BitmapFontData } from '../AbstractBitmapFont';\n\nexport const bitmapFontXMLStringParser = {\n    test(data: string | XMLDocument | BitmapFontData): boolean\n    {\n        if (typeof data === 'string' && data.includes('<font>'))\n        {\n            return bitmapFontXMLParser.test(DOMAdapter.get().parseXML(data));\n        }\n\n        return false;\n    },\n\n    parse(data: string): BitmapFontData\n    {\n        return bitmapFontXMLParser.parse(DOMAdapter.get().parseXML(data));\n    }\n};\n","import { LoaderParserPriority } from '../../../assets/loader/parsers/LoaderParser';\nimport { copySearchParams } from '../../../assets/utils/copySearchParams';\nimport { DOMAdapter } from '../../../environment/adapter';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { path } from '../../../utils/path';\nimport { BitmapFont } from '../BitmapFont';\nimport { bitmapFontTextParser } from './bitmapFontTextParser';\nimport { bitmapFontXMLStringParser } from './bitmapFontXMLStringParser';\n\nimport type { Loader } from '../../../assets/loader/Loader';\nimport type { LoaderParser } from '../../../assets/loader/parsers/LoaderParser';\nimport type { ResolvedAsset } from '../../../assets/types';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\n\nconst validExtensions = ['.xml', '.fnt'];\n\n/** simple loader plugin for loading in bitmap fonts! */\nexport const bitmapFontCachePlugin = {\n    extension: ExtensionType.CacheParser,\n    test: (asset: BitmapFont) => asset instanceof BitmapFont,\n    getCacheableAssets(keys: string[], asset: BitmapFont)\n    {\n        const out: Record<string, BitmapFont> = {};\n\n        keys.forEach((key) =>\n        {\n            out[key] = asset;\n        });\n\n        out[`${asset.fontFamily}-bitmap`] = asset;\n\n        return out;\n    }\n};\n\nexport const loadBitmapFont = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Normal,\n    },\n\n    test(url: string): boolean\n    {\n        return validExtensions.includes(path.extname(url).toLowerCase());\n    },\n\n    async testParse(data: string): Promise<boolean>\n    {\n        return bitmapFontTextParser.test(data) || bitmapFontXMLStringParser.test(data);\n    },\n\n    async parse(asset: string, data: ResolvedAsset, loader: Loader): Promise<BitmapFont>\n    {\n        const bitmapFontData = bitmapFontTextParser.test(asset)\n            ? bitmapFontTextParser.parse(asset)\n            : bitmapFontXMLStringParser.parse(asset);\n\n        const { src } = data;\n        const { pages } = bitmapFontData;\n        const textureUrls = [];\n\n        for (let i = 0; i < pages.length; ++i)\n        {\n            const pageFile = pages[i].file;\n            let imagePath = path.join(path.dirname(src), pageFile);\n\n            imagePath = copySearchParams(imagePath, src);\n\n            textureUrls.push(imagePath);\n        }\n\n        const loadedTextures = await loader.load<Texture>(textureUrls);\n        const textures = textureUrls.map((url) => loadedTextures[url]);\n\n        const bitmapFont = new BitmapFont({\n            data: bitmapFontData,\n            textures\n        }, src);\n\n        return bitmapFont;\n    },\n\n    async load(url: string, _options: ResolvedAsset): Promise<string>\n    {\n        const response = await DOMAdapter.get().fetch(url);\n\n        return await response.text();\n    },\n\n    async unload(bitmapFont: BitmapFont, _resolvedAsset, loader): Promise<void>\n    {\n        await Promise.all(bitmapFont.pages.map((page) => loader.unload(page.texture.source._sourceOrigin)));\n\n        bitmapFont.destroy();\n    }\n} as LoaderParser;\n","import { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\nimport { Container } from '../../container/Container';\nimport { GraphicsContext } from './GraphicsContext';\n\nimport type { ColorSource } from '../../../color/Color';\nimport type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Instruction } from '../../../rendering/renderers/shared/instructions/Instruction';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { View } from '../../../rendering/renderers/shared/view/View';\nimport type { Bounds } from '../../container/bounds/Bounds';\nimport type { ContainerOptions } from '../../container/Container';\nimport type { ContextDestroyOptions, DestroyOptions } from '../../container/destroyTypes';\nimport type { FillStyle, FillStyleInputs, StrokeStyle } from './GraphicsContext';\nimport type { GraphicsPath } from './path/GraphicsPath';\nimport type { RoundedPoint } from './path/roundShape';\n\n/**\n * Constructor options used for `Graphics` instances.\n * ```js\n * const graphics = new Graphics({\n *    fillStyle: { color: 0xff0000, alpha: 0.5 },\n *    strokeStyle: { color: 0x00ff00, width: 2 },\n * });\n * ```\n * @see {@link scene.Graphics}\n * @memberof scene\n */\nexport interface GraphicsOptions extends ContainerOptions\n{\n    /** The GraphicsContext to use, useful for reuse and optimisation */\n    context?: GraphicsContext;\n    /** Whether or not to round the x/y position. */\n    roundPixels?: boolean;\n}\n\n/**\n * The Graphics class is primarily used to render primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.  However, you can also use a Graphics\n * object to build a list of primitives to use as a mask, or as a complex hitArea.\n * @memberof scene\n * @extends scene.Container\n */\nexport class Graphics extends Container implements View, Instruction\n{\n    public readonly canBundle = true;\n    public readonly renderPipeId = 'graphics';\n    public batched: boolean;\n\n    public _roundPixels: 0 | 1 = 0;\n\n    public _didGraphicsUpdate: boolean;\n\n    private _context: GraphicsContext;\n    private readonly _ownedContext: GraphicsContext;\n\n    /**\n     * @param options - Options for the Graphics.\n     */\n    constructor(options?: GraphicsOptions | GraphicsContext)\n    {\n        if (options instanceof GraphicsContext)\n        {\n            options = { context: options };\n        }\n\n        const { context, roundPixels, ...rest } = options || {};\n\n        super({\n            label: 'Graphics',\n            ...rest\n        });\n\n        if (!context)\n        {\n            this._context = this._ownedContext = new GraphicsContext();\n        }\n        else\n        {\n            this._context = context;\n        }\n\n        this._context.on('update', this.onViewUpdate, this);\n\n        this.allowChildren = false;\n        this.roundPixels = roundPixels ?? false;\n    }\n\n    set context(context: GraphicsContext)\n    {\n        if (context === this._context) return;\n\n        this._context.off('update', this.onViewUpdate, this);\n\n        this._context = context;\n\n        // TODO store this bound function somewhere else..\n        this._context.on('update', this.onViewUpdate, this);\n\n        this.onViewUpdate();\n    }\n\n    get context(): GraphicsContext\n    {\n        return this._context;\n    }\n\n    /**\n     * The local bounds of the graphic.\n     * @type {rendering.Bounds}\n     */\n    get bounds(): Bounds\n    {\n        return this._context.bounds;\n    }\n\n    /**\n     * Adds the bounds of this object to the bounds object.\n     * @param bounds - The output bounds object.\n     */\n    public addBounds(bounds: Bounds)\n    {\n        bounds.addBounds(this._context.bounds);\n    }\n\n    /**\n     * Checks if the object contains the given point.\n     * @param point - The point to check\n     */\n    public containsPoint(point: PointData)\n    {\n        return this._context.containsPoint(point);\n    }\n\n    /**\n     *  Whether or not to round the x/y position of the graphic.\n     * @type {boolean}\n     */\n    get roundPixels()\n    {\n        return !!this._roundPixels;\n    }\n\n    set roundPixels(value: boolean)\n    {\n        this._roundPixels = value ? 1 : 0;\n    }\n\n    protected onViewUpdate()\n    {\n        // increment from the 12th bit!\n        this._didChangeId += 1 << 12;\n        this._didGraphicsUpdate = true;\n\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n\n        if (this.renderGroup)\n        {\n            this.renderGroup.onChildViewUpdate(this);\n        }\n    }\n\n    /**\n     * Destroys this graphics renderable and optionally its context.\n     * @param options - Options parameter. A boolean will act as if all options\n     *\n     * If the context was created by this graphics and `destroy(false)` or `destroy()` is called\n     * then the context will still be destroyed.\n     *\n     * If you want to explicitly not destroy this context that this graphics created,\n     * then you should pass destroy({ context: false })\n     *\n     * If the context was passed in as an argument to the constructor then it will not be destroyed\n     * @param {boolean} [options.texture=false] - Should destroy the texture of the graphics context\n     * @param {boolean} [options.textureSource=false] - Should destroy the texture source of the graphics context\n     * @param {boolean} [options.context=false] - Should destroy the context\n     */\n    public destroy(options?: DestroyOptions): void\n    {\n        if (this._ownedContext && !options)\n        {\n            this._ownedContext.destroy(options);\n        }\n        else if (options === true || (options as ContextDestroyOptions)?.context === true)\n        {\n            this._context.destroy(options);\n        }\n\n        (this._ownedContext as null) = null;\n        this._context = null;\n\n        super.destroy(options);\n    }\n\n    private _callContextMethod(method: keyof GraphicsContext, args: any[]): this\n    {\n        (this.context as any)[method](...args);\n\n        return this;\n    }\n\n    // --------------------------------------- GraphicsContext methods ---------------------------------------\n    /**\n     * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n     * pattern, or a more complex style defined by a FillStyle object.\n     * @param {FillStyleInputs} args - The fill style to apply. This can be a simple color, a gradient or\n     * pattern object, or a FillStyle or ConvertedFillStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setFillStyle(...args: Parameters<GraphicsContext['setFillStyle']>): this\n    {\n        return this._callContextMethod('setFillStyle', args);\n    }\n\n    /**\n     * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n     * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n     * @param {FillStyleInputs} args - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n     * or a StrokeStyle or ConvertedStrokeStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setStrokeStyle(...args: Parameters<GraphicsContext['setStrokeStyle']>): this\n    {\n        return this._callContextMethod('setStrokeStyle', args);\n    }\n\n    /**\n     * Fills the current or given path with the current fill style. This method can optionally take\n     * a color and alpha for a simple fill, or a more complex FillStyleInputs object for advanced fills.\n     * @param {FillStyleInputs} style - (Optional) The style to fill the path with. Can be a color, gradient, pattern, or a\n     * complex style object. If omitted, uses the current fill style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public fill(style?: FillStyleInputs): this;\n    /** @deprecated 8.0.0 */\n    public fill(color: ColorSource, alpha: number): this;\n    public fill(...args: [FillStyleInputs, ColorSource?]): this\n    {\n        return this._callContextMethod('fill', args);\n    }\n    /**\n     * Strokes the current path with the current stroke style. This method can take an optional\n     * FillStyleInputs parameter to define the stroke's appearance, including its color, width, and other properties.\n     * @param {FillStyleInputs} args - (Optional) The stroke style to apply. Can be defined as a simple color or a more\n     * complex style object. If omitted, uses the current stroke style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public stroke(...args: Parameters<GraphicsContext['stroke']>): this\n    {\n        return this._callContextMethod('stroke', args);\n    }\n    /**\n     * Adds a texture to the graphics context. This method supports multiple overloads for specifying the texture,\n     * tint, and dimensions. If only a texture is provided, it uses the texture's width and height for drawing.\n     * Additional parameters allow for specifying a tint color, and custom dimensions for the texture drawing area.\n     * @param texture - The Texture object to use.\n     * @param tint - (Optional) A ColorSource to tint the texture. If not provided, defaults to white (0xFFFFFF).\n     * @param dx - (Optional) The x-coordinate in the destination canvas at which to place the top-left corner of\n     * the source image.\n     * @param dy - (Optional) The y-coordinate in the destination canvas at which to place the top-left corner of\n     * the source image.\n     * @param dw - (Optional) The width of the rectangle within the source image to draw onto the destination canvas.\n     * If not provided, uses the texture's frame width.\n     * @param dh - (Optional) The height of the rectangle within the source image to draw onto the destination canvas.\n     * If not provided, uses the texture's frame height.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public texture(texture: Texture, tint?: ColorSource, dx?: number, dy?: number, dw?: number, dh?: number): this;\n    public texture(texture: Texture): this;\n    public texture(...args: [Texture, number?, number?, number?, number?, number?]): this\n    {\n        return this._callContextMethod('texture', args);\n    }\n    /**\n     * Resets the current path. Any previous path and its commands are discarded and a new path is\n     * started. This is typically called before beginning a new shape or series of drawing commands.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public beginPath(): this\n    {\n        return this._callContextMethod('beginPath', []);\n    }\n    /**\n     * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n     * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n     * fail to cut correctly!\n     */\n    public cut(): this\n    {\n        return this._callContextMethod('cut', []);\n    }\n    /**\n     * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n     * starting and ending angles, and direction.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The arc's radius.\n     * @param startAngle - The starting angle, in radians.\n     * @param endAngle - The ending angle, in radians.\n     * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise\n     * (false). Defaults to false.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this;\n    public arc(...args: Parameters<GraphicsContext['arc']>): this\n    {\n        return this._callContextMethod('arc', args);\n    }\n    /**\n     * Adds an arc to the current path with the given control points and radius, connected to the previous point\n     * by a straight line if necessary.\n     * @param x1 - The x-coordinate of the first control point.\n     * @param y1 - The y-coordinate of the first control point.\n     * @param x2 - The x-coordinate of the second control point.\n     * @param y2 - The y-coordinate of the second control point.\n     * @param radius - The arc's radius.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this;\n    public arcTo(...args: Parameters<GraphicsContext['arcTo']>): this\n    {\n        return this._callContextMethod('arcTo', args);\n    }\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcToSvg(\n        rx: number, ry: number, xAxisRotation: number, largeArcFlag: number, sweepFlag: number, x: number, y: number\n    ): this;\n    public arcToSvg(...args: Parameters<GraphicsContext['arcToSvg']>): this\n    {\n        return this._callContextMethod('arcToSvg', args);\n    }\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number, smoothness?: number\n    ): this;\n    public bezierCurveTo(...args: Parameters<GraphicsContext['bezierCurveTo']>): this\n    {\n        return this._callContextMethod('bezierCurveTo', args);\n    }\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        return this._callContextMethod('closePath', []);\n    }\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number): this;\n    public ellipse(...args: Parameters<GraphicsContext['ellipse']>): this\n    {\n        return this._callContextMethod('ellipse', args);\n    }\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number): this;\n    public circle(...args: Parameters<GraphicsContext['circle']>): this\n    {\n        return this._callContextMethod('circle', args);\n    }\n    /**\n     * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n     * @param path - The `GraphicsPath` to add.\n     * @returns The instance of the current object for chaining.\n     */\n    public path(path: GraphicsPath): this;\n    public path(...args: Parameters<GraphicsContext['path']>): this\n    {\n        return this._callContextMethod('path', args);\n    }\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this;\n    public lineTo(...args: Parameters<GraphicsContext['lineTo']>): this\n    {\n        return this._callContextMethod('lineTo', args);\n    }\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this;\n    public moveTo(...args: Parameters<GraphicsContext['moveTo']>): this\n    {\n        return this._callContextMethod('moveTo', args);\n    }\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cpx - The x-coordinate of the control point.\n     * @param cpy - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this;\n    public quadraticCurveTo(...args: Parameters<GraphicsContext['quadraticCurveTo']>): this\n    {\n        return this._callContextMethod('quadraticCurveTo', args);\n    }\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number): this;\n    public rect(...args: Parameters<GraphicsContext['rect']>): this\n    {\n        return this._callContextMethod('rect', args);\n    }\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number): this;\n    public roundRect(...args: Parameters<GraphicsContext['roundRect']>): this\n    {\n        return this._callContextMethod('roundRect', args);\n    }\n    /**\n     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n     * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n     * rotated, or translated as needed.\n     * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n     * representing the x and y coordinates, of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public poly(points: number[] | PointData[], close?: boolean): this;\n    public poly(...args: Parameters<GraphicsContext['poly']>): this\n    {\n        return this._callContextMethod('poly', args);\n    }\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation?: number, transform?: Matrix): this;\n    public regularPoly(...args: Parameters<GraphicsContext['regularPoly']>): this\n    {\n        return this._callContextMethod('regularPoly', args);\n    }\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this;\n    public roundPoly(...args: Parameters<GraphicsContext['roundPoly']>): this\n    {\n        return this._callContextMethod('roundPoly', args);\n    }\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this;\n    public roundShape(...args: Parameters<GraphicsContext['roundShape']>): this\n    {\n        return this._callContextMethod('roundShape', args);\n    }\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this;\n    public filletRect(...args: Parameters<GraphicsContext['filletRect']>): this\n    {\n        return this._callContextMethod('filletRect', args);\n    }\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this;\n    public chamferRect(...args: Parameters<GraphicsContext['chamferRect']>): this\n    {\n        return this._callContextMethod('chamferRect', args);\n    }\n    /**\n     * Draws a star shape centered at a specified location. This method allows for the creation\n     *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n     * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n     * @param x - The x-coordinate of the center of the star.\n     * @param y - The y-coordinate of the center of the star.\n     * @param points - The number of points of the star.\n     * @param radius - The outer radius of the star (distance from the center to the outer points).\n     * @param innerRadius - Optional. The inner radius of the star\n     * (distance from the center to the inner points between the outer points).\n     * If not provided, defaults to half of the `radius`.\n     * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n     * Defaults to 0, meaning one point is directly upward.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public star(x: number, y: number, points: number, radius: number, innerRadius?: number, rotation?: number): this;\n    public star(...args: Parameters<GraphicsContext['star']>): this\n    {\n        return this._callContextMethod('star', args);\n    }\n    /**\n     * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths\n     * defined in SVG format to be drawn within the graphics context.\n     * @param svg - The SVG string to be parsed and rendered.\n     */\n    public svg(svg: string): this;\n    public svg(...args: Parameters<GraphicsContext['svg']>): this\n    {\n        return this._callContextMethod('svg', args);\n    }\n    /**\n     * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n     * This includes transformations, fill styles, and stroke styles.\n     */\n    public restore(): this;\n    public restore(...args: Parameters<GraphicsContext['restore']>): this\n    {\n        return this._callContextMethod('restore', args);\n    }\n    /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n    public save(): this\n    {\n        return this._callContextMethod('save', []);\n    }\n    /**\n     * Returns the current transformation matrix of the graphics context.\n     * @returns The current transformation matrix.\n     */\n    public getTransform(): Matrix\n    {\n        return this.context.getTransform();\n    }\n    /**\n     * Resets the current transformation matrix to the identity matrix, effectively removing\n     * any transformations (rotation, scaling, translation) previously applied.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public resetTransform(): this\n    {\n        return this._callContextMethod('resetTransform', []);\n    }\n    /**\n     * Applies a rotation transformation to the graphics context around the current origin.\n     * @param angle - The angle of rotation in radians.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public rotateTransform(angle: number): this;\n    public rotateTransform(...args: Parameters<GraphicsContext['rotate']>): this\n    {\n        return this._callContextMethod('rotate', args);\n    }\n    /**\n     * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.\n     * @param x - The scale factor in the horizontal direction.\n     * @param y - (Optional) The scale factor in the vertical direction.\n     * If not specified, the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public scaleTransform(x: number, y?: number): this;\n    public scaleTransform(...args: Parameters<GraphicsContext['scale']>): this\n    {\n        return this._callContextMethod('scale', args);\n    }\n    /**\n     * Sets the current transformation matrix of the graphics context to the specified matrix or values.\n     * This replaces the current transformation matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setTransform(transform: Matrix): this;\n    public setTransform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public setTransform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this;\n    public setTransform(...args: [Matrix] | [number, number, number, number, number, number]): this\n    {\n        return this._callContextMethod('setTransform', args);\n    }\n    /**\n     * Applies the specified transformation matrix to the current graphics context by multiplying\n     * the current matrix with the specified matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public transform(transform: Matrix): this;\n    public transform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public transform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this;\n    public transform(...args: [Matrix] | [number, number, number, number, number, number]): this\n    {\n        return this._callContextMethod('transform', args);\n    }\n    /**\n     * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n     * @param x - The amount to translate in the horizontal direction.\n     * @param y - (Optional) The amount to translate in the vertical direction. If not specified,\n     * the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public translateTransform(x: number, y?: number): this;\n    public translateTransform(...args: Parameters<GraphicsContext['translate']>): this\n    {\n        return this._callContextMethod('translate', args);\n    }\n    /**\n     * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n     * and optionally resetting transformations to the identity matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public clear(): this\n    {\n        return this._callContextMethod('clear', []);\n    }\n    /**\n     * The fill style to use.\n     * @type {ConvertedFillStyle}\n     */\n    get fillStyle(): GraphicsContext['fillStyle']\n    {\n        return this._context.fillStyle;\n    }\n    set fillStyle(value: FillStyleInputs)\n    {\n        this._context.fillStyle = value;\n    }\n    /**\n     * The stroke style to use.\n     * @type {ConvertedStrokeStyle}\n     */\n    get strokeStyle(): GraphicsContext['strokeStyle']\n    {\n        return this._context.strokeStyle;\n    }\n    set strokeStyle(value: FillStyleInputs)\n    {\n        this._context.strokeStyle = value;\n    }\n\n    /**\n     * Creates a new Graphics object.\n     * Note that only the context of the object is cloned, not its transform (position,scale,etc)\n     * @param deep - Whether to create a deep clone of the graphics object. If false, the context\n     * will be shared between the two objects (default false). If true, the context will be\n     * cloned (recommended if you need to modify the context in any way).\n     * @returns - A clone of the graphics object\n     */\n    public clone(deep = false): Graphics\n    {\n        if (deep)\n        {\n            return new Graphics(this._context.clone());\n        }\n\n        (this._ownedContext as null) = null;\n        const clone = new Graphics(this._context);\n\n        return clone;\n    }\n\n    // -------- v7 deprecations ---------\n\n    /**\n     * @param width\n     * @param color\n     * @param alpha\n     * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead\n     */\n    public lineStyle(width?: number, color?: ColorSource, alpha?: number): this\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.');\n        // #endif\n\n        const strokeStyle: Partial<StrokeStyle> = {};\n\n        // avoid undefined assignment\n        width && (strokeStyle.width = width);\n        color && (strokeStyle.color = color);\n        alpha && (strokeStyle.alpha = alpha);\n\n        this.context.strokeStyle = strokeStyle;\n\n        return this;\n    }\n\n    /**\n     * @param color\n     * @param alpha\n     * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n     */\n    public beginFill(color: ColorSource, alpha?: number)\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.');\n        // #endif\n\n        const fillStyle: Partial<FillStyle> = {};\n\n        // avoid undefined assignment\n        color && (fillStyle.color = color);\n        alpha && (fillStyle.alpha = alpha);\n\n        this.context.fillStyle = fillStyle;\n\n        return this;\n    }\n\n    /**\n     * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n     */\n    public endFill()\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.');\n        // #endif\n\n        this.context.fill();\n        const strokeStyle = this.context.strokeStyle;\n\n        if (strokeStyle.width !== GraphicsContext.defaultStrokeStyle.width\n            || strokeStyle.color !== GraphicsContext.defaultStrokeStyle.color\n            || strokeStyle.alpha !== GraphicsContext.defaultStrokeStyle.alpha)\n        {\n            this.context.stroke();\n        }\n\n        return this;\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#circle} instead\n     */\n    public drawCircle(...args: Parameters<GraphicsContext['circle']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawCircle has been renamed to Graphics#circle');\n        // #endif\n\n        return this._callContextMethod('circle', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead\n     */\n    public drawEllipse(...args: Parameters<GraphicsContext['ellipse']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawEllipse has been renamed to Graphics#ellipse');\n        // #endif\n\n        return this._callContextMethod('ellipse', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#poly} instead\n     */\n    public drawPolygon(...args: Parameters<GraphicsContext['poly']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawPolygon has been renamed to Graphics#poly');\n        // #endif\n\n        return this._callContextMethod('poly', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#rect} instead\n     */\n    public drawRect(...args: Parameters<GraphicsContext['rect']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawRect has been renamed to Graphics#rect');\n        // #endif\n\n        return this._callContextMethod('rect', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead\n     */\n    public drawRoundedRect(...args: Parameters<GraphicsContext['roundRect']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawRoundedRect has been renamed to Graphics#roundRect');\n        // #endif\n\n        return this._callContextMethod('roundRect', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#star} instead\n     */\n    public drawStar(...args: Parameters<GraphicsContext['star']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawStar has been renamed to Graphics#star');\n        // #endif\n\n        return this._callContextMethod('star', args);\n    }\n}\n","// TODO eventually we should not use this bit, but instead use the localUniformBit\n// have the MSDF bit be merged in with the localUniformBit\n\nexport const localUniformMSDFBit = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         `,\n        main: /* wgsl */` \n            outColor = vColor * calculateMSDFAlpha(outColor, localUniforms.uDistance);\n        `\n\n    }\n};\n\nexport const localUniformMSDFBitGl = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform float uDistance;\n         `,\n        main: /* glsl */` \n            outColor = vColor * calculateMSDFAlpha(outColor, uDistance);\n        `\n\n    }\n};\n","export const mSDFBit = {\n    name: 'msdf-bit',\n    fragment: {\n        header: /* wgsl */`\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, distance:f32) -> f32 {\n                \n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n            \n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                return alpha;\n            }\n        `,\n    }\n\n};\n\nexport const mSDFBitGl = {\n    name: 'msdf-bit',\n    fragment: {\n        header: /* glsl */`\n            float calculateMSDFAlpha(vec4 msdfColor, float distance) {\n                \n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n               \n                // SDF\n                median = min(median, msdfColor.a);\n            \n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n           \n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                return alpha;\n            }\n        `,\n    }\n\n};\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { MAX_TEXTURES } from '../../../rendering/batcher/shared/const';\nimport {\n    compileHighShaderGlProgram,\n    compileHighShaderGpuProgram\n} from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { colorBit, colorBitGl } from '../../../rendering/high-shader/shader-bits/colorBit';\nimport {\n    generateTextureBatchBit,\n    generateTextureBatchBitGl\n} from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { batchSamplersUniformGroup } from '../../../rendering/renderers/gl/shader/batchSamplersUniformGroup';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { localUniformMSDFBit, localUniformMSDFBitGl } from './shader-bits/localUniformMSDFBit';\nimport { mSDFBit, mSDFBitGl } from './shader-bits/mSDFBit';\n\nexport class SdfShader extends Shader\n{\n    constructor()\n    {\n        const uniforms = new UniformGroup({\n            uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n            uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uDistance: { value: 4, type: 'f32' },\n            uRound: { value: 0, type: 'f32' },\n        });\n\n        const gpuProgram = compileHighShaderGpuProgram({\n            name: 'sdf-shader',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(MAX_TEXTURES),\n                localUniformMSDFBit,\n                mSDFBit,\n                roundPixelsBit\n            ]\n        });\n\n        const glProgram = compileHighShaderGlProgram({\n            name: 'sdf-shader',\n            bits: [\n                colorBitGl,\n                generateTextureBatchBitGl(MAX_TEXTURES),\n                localUniformMSDFBitGl,\n                mSDFBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                localUniforms: uniforms,\n                batchSamplers: batchSamplersUniformGroup,\n            }\n        });\n    }\n}\n","import { Cache } from '../../assets/cache/Cache';\nimport { ExtensionType } from '../../extensions/Extensions';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { Graphics } from '../graphics/shared/Graphics';\nimport { SdfShader } from '../text/sdfShader/SdfShader';\nimport { BitmapFontManager } from './BitmapFontManager';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderable } from '../../rendering/renderers/shared/Renderable';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { BitmapText } from './BitmapText';\n\nexport class BitmapTextPipe implements RenderPipe<BitmapText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'bitmapText',\n    } as const;\n\n    private _renderer: Renderer;\n    private _gpuBitmapText: Record<number, Graphics> = {};\n    private _sdfShader: SdfShader;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(bitmapText: BitmapText): boolean\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        if (bitmapText._didTextUpdate)\n        {\n            bitmapText._didTextUpdate = false;\n\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n\n        return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);\n\n        // TODO - need to shift all the verts in the graphicsData to the new anchor\n\n        // update the anchor...\n    }\n\n    public addRenderable(bitmapText: BitmapText, instructionSet: InstructionSet)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        if (bitmapText._didTextUpdate)\n        {\n            bitmapText._didTextUpdate = false;\n\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n\n        this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    public destroyRenderable(bitmapText: BitmapText)\n    {\n        this._destroyRenderableByUid(bitmapText.uid);\n    }\n\n    private _destroyRenderableByUid(renderableUid: number)\n    {\n        BigPool.return(this._gpuBitmapText[renderableUid] as PoolItem);\n        this._gpuBitmapText[renderableUid] = null;\n    }\n\n    public updateRenderable(bitmapText: BitmapText)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    private _updateContext(bitmapText: BitmapText, proxyGraphics: Graphics)\n    {\n        const { context } = proxyGraphics;\n\n        const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);\n\n        context.clear();\n\n        if (bitmapFont.distanceField.type !== 'none')\n        {\n            if (!context.customShader)\n            {\n                if (!this._sdfShader)\n                {\n                    this._sdfShader = new SdfShader();\n                }\n\n                context.customShader = this._sdfShader;\n            }\n        }\n\n        const chars = Array.from(bitmapText.text);\n        const style = bitmapText._style;\n\n        let currentY = (style._stroke?.width || 0) / 2;\n\n        currentY += bitmapFont.baseLineOffset;\n\n        // measure our text...\n        const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont);\n\n        let index = 0;\n\n        const padding = style.padding;\n        const scale = bitmapTextLayout.scale;\n\n        context\n            .translate(\n                (-bitmapText._anchor._x * bitmapTextLayout.width) - padding,\n                (-bitmapText._anchor._y * (bitmapTextLayout.height + bitmapTextLayout.offsetY)) - padding)\n            .scale(scale, scale);\n\n        const tint = style._fill.color;\n\n        for (let i = 0; i < bitmapTextLayout.lines.length; i++)\n        {\n            const line = bitmapTextLayout.lines[i];\n\n            for (let j = 0; j < line.charPositions.length; j++)\n            {\n                const char = chars[index++];\n\n                const charData = bitmapFont.chars[char];\n\n                if (charData?.texture)\n                {\n                    context.texture(\n                        charData.texture,\n                        tint ? tint : 'black',\n                        Math.round(line.charPositions[j] + charData.xOffset),\n                        Math.round(currentY + charData.yOffset),\n                    );\n                }\n            }\n\n            currentY += bitmapFont.lineHeight;\n        }\n    }\n\n    private _getGpuBitmapText(bitmapText: BitmapText)\n    {\n        return this._gpuBitmapText[bitmapText.uid] || this.initGpuText(bitmapText);\n    }\n\n    public initGpuText(bitmapText: BitmapText)\n    {\n        // TODO we could keep a bunch of contexts around and reuse one that hav the same style!\n        const proxyRenderable = BigPool.get(Graphics);\n\n        this._gpuBitmapText[bitmapText.uid] = proxyRenderable;\n\n        this._updateContext(bitmapText, proxyRenderable);\n\n        bitmapText.on('destroyed', () =>\n        {\n            this.destroyRenderable(bitmapText);\n        });\n\n        return this._gpuBitmapText[bitmapText.uid];\n    }\n\n    private _updateDistanceField(bitmapText: BitmapText)\n    {\n        const context = this._getGpuBitmapText(bitmapText).context;\n\n        const fontFamily = bitmapText._style.fontFamily as string;\n        const dynamicFont = Cache.get(`${fontFamily as string}-bitmap`);\n\n        // Inject the shader code with the correct value\n        const { a, b, c, d } = bitmapText.groupTransform;\n\n        const dx = Math.sqrt((a * a) + (b * b));\n        const dy = Math.sqrt((c * c) + (d * d));\n        const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n\n        const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;\n\n        const resolution = bitmapText.resolution ?? this._renderer.resolution;\n        const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale) * resolution;\n\n        context.customShader.resources.localUniforms.uniforms.uDistance = distance;\n    }\n\n    public destroy()\n    {\n        for (const uid in this._gpuBitmapText)\n        {\n            this._destroyRenderableByUid(uid as unknown as number);\n        }\n\n        this._gpuBitmapText = null;\n\n        this._sdfShader?.destroy(true);\n        this._sdfShader = null;\n\n        this._renderer = null;\n    }\n}\n\nfunction syncWithProxy(container: Renderable, proxy: Renderable)\n{\n    proxy.groupTransform = container.groupTransform;\n    proxy.groupColorAlpha = container.groupColorAlpha;\n    proxy.groupColor = container.groupColor;\n    proxy.groupBlendMode = container.groupBlendMode;\n    proxy.globalDisplayStatus = container.globalDisplayStatus;\n    proxy.groupTransform = container.groupTransform;\n    proxy.localDisplayStatus = container.localDisplayStatus;\n    proxy.groupAlpha = container.groupAlpha;\n    proxy._roundPixels = container._roundPixels;\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { bitmapFontCachePlugin, loadBitmapFont } from './asset/loadBitmapFont';\nimport { BitmapTextPipe } from './BitmapTextPipe';\n\nextensions.add(BitmapTextPipe, loadBitmapFont, bitmapFontCachePlugin);\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { updateQuadBounds } from '../../utils/data/updateQuadBounds';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { BatchableSprite } from '../sprite/BatchableSprite';\n\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { HTMLText } from './HTMLText';\nimport type { HTMLTextStyle } from './HtmlTextStyle';\n\nexport class HTMLTextPipe implements RenderPipe<HTMLText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private _gpuText: Record<number, {\n        textureNeedsUploading: boolean;\n        generatingTexture: boolean;\n        texture: Texture,\n        currentKey: string,\n        batchableSprite: BatchableSprite,\n    }> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(htmlText: HTMLText): boolean\n    {\n        const gpuText = this._getGpuText(htmlText);\n\n        const newKey = htmlText._getKey();\n\n        if (gpuText.textureNeedsUploading)\n        {\n            gpuText.textureNeedsUploading = false;\n\n            return true;\n        }\n\n        if (gpuText.currentKey !== newKey)\n        {\n            // TODO - could look into optimising this a tad!\n            // if its a single texture, then we could just swap it?\n            // same for CanvasText..\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(htmlText: HTMLText)\n    {\n        const gpuText = this._getGpuText(htmlText);\n\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (htmlText._didTextUpdate)\n        {\n            this._updateText(htmlText);\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableSprite);\n    }\n\n    public updateRenderable(htmlText: HTMLText)\n    {\n        const gpuText = this._getGpuText(htmlText);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (htmlText._didTextUpdate)\n        {\n            this._updateText(htmlText);\n        }\n\n        batchableSprite.batcher.updateElement(batchableSprite);\n    }\n\n    public destroyRenderable(htmlText: HTMLText)\n    {\n        this._destroyRenderableById(htmlText.uid);\n    }\n\n    private _destroyRenderableById(htmlTextUid: number)\n    {\n        const gpuText = this._gpuText[htmlTextUid];\n\n        this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n\n        BigPool.return(gpuText.batchableSprite);\n\n        this._gpuText[htmlTextUid] = null;\n    }\n\n    private _updateText(htmlText: HTMLText)\n    {\n        const newKey = htmlText._getKey();\n        const gpuText = this._getGpuText(htmlText);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (gpuText.currentKey !== newKey)\n        {\n            this._updateGpuText(htmlText).catch((e) =>\n            {\n                console.error(e);\n            });\n        }\n\n        htmlText._didTextUpdate = false;\n\n        const padding = htmlText._style.padding;\n\n        updateQuadBounds(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n    }\n\n    private async _updateGpuText(htmlText: HTMLText)\n    {\n        htmlText._didTextUpdate = false;\n\n        const gpuText = this._getGpuText(htmlText);\n\n        if (gpuText.generatingTexture) return;\n\n        const newKey = htmlText._getKey();\n\n        this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n\n        gpuText.generatingTexture = true;\n\n        gpuText.currentKey = newKey;\n\n        const resolution = htmlText.resolution ?? this._renderer.resolution;\n\n        const texture = await this._renderer.htmlText.getManagedTexture(\n            htmlText.text,\n            resolution,\n            htmlText._style as HTMLTextStyle,\n            htmlText._getKey()\n        );\n\n        const batchableSprite = gpuText.batchableSprite;\n\n        batchableSprite.texture = gpuText.texture = texture;\n\n        gpuText.generatingTexture = false;\n\n        gpuText.textureNeedsUploading = true;\n        htmlText.onViewUpdate();\n\n        const padding = htmlText._style.padding;\n\n        updateQuadBounds(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n    }\n\n    private _getGpuText(htmlText: HTMLText)\n    {\n        return this._gpuText[htmlText.uid] || this.initGpuText(htmlText);\n    }\n\n    public initGpuText(htmlText: HTMLText)\n    {\n        const gpuTextData: HTMLTextPipe['_gpuText'][number] = {\n            texture: Texture.EMPTY,\n            currentKey: '--',\n            batchableSprite: BigPool.get(BatchableSprite),\n            textureNeedsUploading: false,\n            generatingTexture: false,\n        };\n\n        const batchableSprite = gpuTextData.batchableSprite;\n\n        batchableSprite.renderable = htmlText;\n        batchableSprite.texture = Texture.EMPTY;\n        batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        batchableSprite.roundPixels = (this._renderer._roundPixels | htmlText._roundPixels) as 0 | 1;\n\n        this._gpuText[htmlText.uid] = gpuTextData;\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        htmlText.on('destroyed', () =>\n        {\n            this.destroyRenderable(htmlText);\n        });\n\n        return gpuTextData;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuText)\n        {\n            this._destroyRenderableById(i as unknown as number);\n        }\n\n        this._gpuText = null;\n        this._renderer = null;\n    }\n}\n\n","import { DOMAdapter } from '../../environment/adapter';\n\nexport function isSafari(): boolean\n{\n    const { userAgent } = DOMAdapter.get().getNavigator();\n\n    return (/^((?!chrome|android).)*safari/i).test(userAgent);\n}\n","import type { CanvasAndContext } from '../../rendering/renderers/shared/texture/CanvasPool';\n\nexport const nssvg = 'http://www.w3.org/2000/svg';\nexport const nsxhtml = 'http://www.w3.org/1999/xhtml';\n\nexport class HTMLTextRenderData\n{\n    public svgRoot = document.createElementNS(nssvg, 'svg');\n    public foreignObject = document.createElementNS(nssvg, 'foreignObject');\n    public domElement = document.createElementNS(nsxhtml, 'div');\n    public styleElement = document.createElementNS(nsxhtml, 'style');\n    public image = new Image();\n    public canvasAndContext?: CanvasAndContext;\n\n    constructor()\n    {\n        const { foreignObject, svgRoot, styleElement, domElement } = this;\n        // Arbitrary max size\n\n        foreignObject.setAttribute('width', '10000');\n        foreignObject.setAttribute('height', '10000');\n        foreignObject.style.overflow = 'hidden';\n\n        svgRoot.appendChild(foreignObject);\n\n        foreignObject.appendChild(styleElement);\n        foreignObject.appendChild(domElement);\n    }\n}\n","import { Color } from '../../../color/Color';\n\nimport type { StrokeStyle } from '../../graphics/shared/GraphicsContext';\nimport type { TextStyle } from '../../text/TextStyle';\nimport type { HTMLTextStyle, HTMLTextStyleOptions } from '../HtmlTextStyle';\n\n/**\n * Internally converts all of the style properties into CSS equivalents.\n * @param style\n * @returns The CSS style string, for setting `style` property of root HTMLElement.\n */\nexport function textStyleToCSS(style: HTMLTextStyle): string\n{\n    const stroke = style._stroke;\n    const fill = style._fill;\n\n    const cssStyleString = [\n        `color: ${Color.shared.setValue(fill.color).toHex()}`,\n        `font-size: ${(style.fontSize as number)}px`,\n        `font-family: ${style.fontFamily}`,\n        `font-weight: ${style.fontWeight}`,\n        `font-style: ${style.fontStyle}`,\n        `font-variant: ${style.fontVariant}`,\n        `letter-spacing: ${style.letterSpacing}px`,\n        `text-align: ${style.align}`,\n        `padding: ${style.padding}px`,\n        `white-space: ${(style.whiteSpace === 'pre' && style.wordWrap) ? 'pre-wrap' : style.whiteSpace}`,\n        ...style.lineHeight ? [`line-height: ${style.lineHeight}px`] : [],\n        ...style.wordWrap ? [\n            `word-wrap: ${style.breakWords ? 'break-all' : 'break-word'}`,\n            `max-width: ${style.wordWrapWidth}px`\n        ] : [],\n        ...stroke ? [strokeToCSS(stroke)] : [],\n        ...style.dropShadow ? [dropShadowToCSS(style.dropShadow)] : [],\n        ...style.cssOverrides,\n    ].join(';');\n\n    const cssStyles = [`div { ${cssStyleString} }`];\n\n    tagStyleToCSS(style.tagStyles, cssStyles);\n\n    return cssStyles.join(' ');\n}\n\nfunction dropShadowToCSS(dropShadowStyle: TextStyle['dropShadow']): string\n{\n    const color = Color.shared.setValue(dropShadowStyle.color).setAlpha(dropShadowStyle.alpha).toHexa();\n    const x = Math.round(Math.cos(dropShadowStyle.angle) * dropShadowStyle.distance);\n    const y = Math.round(Math.sin(dropShadowStyle.angle) * dropShadowStyle.distance);\n\n    const position = `${x}px ${y}px`;\n\n    if (dropShadowStyle.blur > 0)\n    {\n        return `text-shadow: ${position} ${dropShadowStyle.blur}px ${color}`;\n    }\n\n    return `text-shadow: ${position} ${color}`;\n}\n\nfunction strokeToCSS(stroke: StrokeStyle): string\n{\n    return [\n        `-webkit-text-stroke-width: ${stroke.width}px`,\n        `-webkit-text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,\n        `text-stroke-width: ${stroke.width}px`,\n        `text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,\n        'paint-order: stroke',\n    ].join(';');\n}\n\n/** Converts the tag styles into CSS. */\nconst templates = {\n    fontSize: `font-size: {{VALUE}}px`,\n    fontFamily: `font-family: {{VALUE}}`,\n    fontWeight: `font-weight: {{VALUE}}`,\n    fontStyle: `font-style: {{VALUE}}`,\n    fontVariant: `font-variant: {{VALUE}}`,\n    letterSpacing: `letter-spacing: {{VALUE}}px`,\n    align: `text-align: {{VALUE}}`,\n    padding: `padding: {{VALUE}}px`,\n    whiteSpace: `white-space: {{VALUE}}`,\n    lineHeight: `line-height: {{VALUE}}px`,\n    wordWrapWidth: `max-width: {{VALUE}}px`,\n};\n\n/** Converts the tag styles into CSS if modifications are required */\nconst transform = {\n    fill: (value: string) => `color: ${Color.shared.setValue(value).toHex()}`,\n    breakWords: (value: string) => `word-wrap: ${value ? 'break-all' : 'break-word'}`,\n    stroke: strokeToCSS,\n    dropShadow: dropShadowToCSS\n};\n\nfunction tagStyleToCSS(tagStyles: Record<string, HTMLTextStyleOptions>, out: string[])\n{\n    for (const i in tagStyles)\n    {\n        const tagStyle = tagStyles[i];\n        const cssTagStyle = [];\n\n        for (const j in tagStyle)\n        {\n            if (transform[j as keyof typeof transform])\n            {\n                // eslint-disable-next-line max-len\n                cssTagStyle.push(transform[j as keyof typeof transform](tagStyle[j as keyof HTMLTextStyleOptions] as any));\n            }\n            else if (templates[j as keyof typeof templates])\n            {\n                // eslint-disable-next-line max-len\n                cssTagStyle.push(templates[j as keyof typeof templates].replace('{{VALUE}}', tagStyle[j as keyof HTMLTextStyleOptions] as any));\n            }\n        }\n\n        out.push(`${i} { ${cssTagStyle.join(';')} }`);\n    }\n}\n","/* eslint-disable accessor-pairs */\nimport { warn } from '../../utils/logging/warn';\nimport { TextStyle } from '../text/TextStyle';\nimport { generateTextStyleKey } from '../text/utils/generateTextStyleKey';\nimport { textStyleToCSS } from './utils/textStyleToCSS';\n\nimport type { FillStyleInputs } from '../graphics/shared/GraphicsContext';\nimport type { TextStyleOptions } from '../text/TextStyle';\n\n/**\n * Options for HTML text style, extends {@link TextStyle}.\n * @memberof text\n * @extends text.TextStyleOptions\n * @property {string[]} [cssOverrides] - CSS style(s) to add.\n * @property {Record<string, text.HTMLTextStyleOptions>} [tagStyles] - Tag styles.\n */\nexport interface HTMLTextStyleOptions extends Omit<TextStyleOptions, 'leading' | 'textBaseline' | 'trim' >\n{\n    cssOverrides?: string[];\n    tagStyles?: Record<string, HTMLTextStyleOptions>;\n}\n\n/**\n * A TextStyle object rendered by the HTMLTextSystem.\n * @memberof text\n */\nexport class HTMLTextStyle extends TextStyle\n{\n    private _cssOverrides: string[] = [];\n    private _cssStyle: string;\n    /**\n     * List of styles per tag.\n     * @example\n     * new HTMLText({\n     *   text:'<red>Red</red>,<blue>Blue</blue>,<green>Green</green>',\n     *   style:{\n     *       fontFamily: 'DM Sans',\n     *       fill: 'white',\n     *       fontSize:100,\n     *       tagStyles:{\n     *           red:{\n     *               fill:'red',\n     *           },\n     *           blue:{\n     *               fill:'blue',\n     *           },\n     *           green:{\n     *               fill:'green',\n     *           }\n     *       }\n     *   }\n     * );\n     */\n    public tagStyles: Record<string, HTMLTextStyleOptions>;\n\n    constructor(options: HTMLTextStyleOptions = {})\n    {\n        super(options);\n\n        this.cssOverrides ??= options.cssOverrides;\n        this.tagStyles = options.tagStyles ?? {};\n    }\n\n    /** List of style overrides that will be applied to the HTML text. */\n    set cssOverrides(value: string | string[])\n    {\n        this._cssOverrides = value instanceof Array ? value : [value];\n        this.update();\n    }\n\n    get cssOverrides(): string[]\n    {\n        return this._cssOverrides;\n    }\n\n    protected override _generateKey(): string\n    {\n        this._styleKey = generateTextStyleKey(this) + this._cssOverrides.join('-');\n\n        return this._styleKey;\n    }\n\n    public update()\n    {\n        this._cssStyle = null;\n        super.update();\n    }\n\n    /**\n     * Creates a new HTMLTextStyle object with the same values as this one.\n     * @returns New cloned HTMLTextStyle object\n     */\n    public clone(): HTMLTextStyle\n    {\n        return new HTMLTextStyle({\n            align: this.align,\n            breakWords: this.breakWords,\n            dropShadow: this.dropShadow,\n            fill: this._fill,\n            fontFamily: this.fontFamily,\n            fontSize: this.fontSize,\n            fontStyle: this.fontStyle,\n            fontVariant: this.fontVariant,\n            fontWeight: this.fontWeight,\n            letterSpacing: this.letterSpacing,\n            lineHeight: this.lineHeight,\n            padding: this.padding,\n            stroke: this._stroke,\n            whiteSpace: this.whiteSpace,\n            wordWrap: this.wordWrap,\n            wordWrapWidth: this.wordWrapWidth,\n            cssOverrides: this.cssOverrides,\n        });\n    }\n\n    get cssStyle(): string\n    {\n        if (!this._cssStyle)\n        {\n            this._cssStyle = textStyleToCSS(this);\n        }\n\n        return this._cssStyle;\n    }\n\n    /**\n     * Add a style override, this can be any CSS property\n     * it will override any built-in style. This is the\n     * property and the value as a string (e.g., `color: red`).\n     * This will override any other internal style.\n     * @param {string} value - CSS style(s) to add.\n     * @example\n     * style.addOverride('background-color: red');\n     */\n    public addOverride(...value: string[]): void\n    {\n        const toAdd = value.filter((v) => !this.cssOverrides.includes(v));\n\n        if (toAdd.length > 0)\n        {\n            this.cssOverrides.push(...toAdd);\n            this.update();\n        }\n    }\n\n    /**\n     * Remove any overrides that match the value.\n     * @param {string} value - CSS style to remove.\n     * @example\n     * style.removeOverride('background-color: red');\n     */\n    public removeOverride(...value: string[]): void\n    {\n        const toRemove = value.filter((v) => this.cssOverrides.includes(v));\n\n        if (toRemove.length > 0)\n        {\n            this.cssOverrides = this.cssOverrides.filter((v) => !toRemove.includes(v));\n            this.update();\n        }\n    }\n\n    override set fill(value: FillStyleInputs)\n    {\n        // if its not a string or a number, then its a texture!\n        if (typeof value !== 'string' && typeof value !== 'number')\n        {\n            // #if _DEBUG\n            warn('[HTMLTextStyle] only color fill is not supported by HTMLText');\n            // #endif\n        }\n\n        super.fill = value;\n    }\n\n    override set stroke(value: FillStyleInputs)\n    {\n        // if its not a string or a number, then its a texture!\n        if (value && typeof value !== 'string' && typeof value !== 'number')\n        {\n            // #if _DEBUG\n            warn('[HTMLTextStyle] only color stroke is not supported by HTMLText');\n            // #endif\n        }\n\n        super.stroke = value;\n    }\n}\n","import type { HTMLTextStyle } from '../HtmlTextStyle';\n\n/**\n * Extracts font families from text. It will extract font families from the style, tagStyles and any font families\n * embedded in the text. It should also strip out duplicates as it goes.\n * @param  text - The text to extract font families from\n * @param style - The style to extract font families from\n * @returns {string[]} - The font families as an array of strings\n */\nexport function extractFontFamilies(text: string, style: HTMLTextStyle): string[]\n{\n    const fontFamily = style.fontFamily;\n    const fontFamilies: string[] = [];\n    const dedupe: Record<string, boolean> = {};\n\n    // first ensure fonts are loaded inline..\n    // find any font..\n    const regex = /font-family:([^;\"\\s]+)/g;\n\n    const matches = text.match(regex);\n\n    function addFontFamily(fontFamily: string)\n    {\n        if (!dedupe[fontFamily])\n        {\n            fontFamilies.push(fontFamily);\n\n            dedupe[fontFamily] = true;\n        }\n    }\n\n    if (Array.isArray(fontFamily))\n    {\n        for (let i = 0; i < fontFamily.length; i++)\n        {\n            addFontFamily(fontFamily[i]);\n        }\n    }\n    else\n    {\n        addFontFamily(fontFamily);\n    }\n\n    if (matches)\n    {\n        matches.forEach((match) =>\n        {\n            const fontFamily = match.split(':')[1].trim();\n\n            addFontFamily(fontFamily);\n        });\n    }\n\n    for (const i in style.tagStyles)\n    {\n        const fontFamily = style.tagStyles[i].fontFamily;\n\n        addFontFamily(fontFamily as string);\n    }\n\n    return fontFamilies;\n}\n","import { DOMAdapter } from '../../../environment/adapter';\n\n/**\n * Resolves a font url to a base64 string\n * @param url - The url to load the font from\n * @returns - The font as a base64 string\n */\nexport async function loadFontAsBase64(url: string): Promise<string>\n{\n    const response = await DOMAdapter.get().fetch(url);\n\n    const blob = await response.blob();\n\n    const reader = new FileReader();\n\n    const dataSrc: string = await new Promise((resolve, reject) =>\n    {\n        reader.onloadend = () => resolve(reader.result as string);\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n    });\n\n    return dataSrc;\n}\n","import { loadFontAsBase64 } from './loadFontAsBase64';\n\nexport interface FontCSSStyleOptions\n{\n    fontFamily: string | string[]\n    fontWeight: string\n    fontStyle: string\n}\n\n/**\n * This will take a font url and a style and return a css string that can be injected into a style tag\n * This will contain inlined base64 font and the font family information\n * @param style - the style to generate the css for\n * @param url - The url to load the font from\n * @returns - The css string\n */\nexport async function loadFontCSS(style: FontCSSStyleOptions, url: string): Promise<string>\n{\n    const dataSrc = await loadFontAsBase64(url);\n\n    return `@font-face {\n        font-family: \"${style.fontFamily}\";\n        src: url('${dataSrc}');\n        font-weight: ${style.fontWeight};\n        font-style: ${style.fontStyle};\n    }`;\n}\n","import { Cache } from '../../../assets/cache/Cache';\nimport { loadFontCSS } from './loadFontCSS';\n\nimport type { FontCSSStyleOptions } from './loadFontCSS';\n\nexport const FontStylePromiseCache = new Map<string, Promise<string>>();\n\n/**\n * takes the font families and returns a css string that can be injected into a style tag\n * It will contain the font families and the font urls encoded as base64\n * @param fontFamilies - The font families to load\n * @param style - The FontCSSStyleOptions to load the font with (used for the first font family)\n * @param defaultOptions - The default options to load the font with (used for the rest of the font families)\n * @param defaultOptions.fontWeight - The default font weight\n * @param defaultOptions.fontStyle - The default font style\n * @returns - The css string\n */\nexport async function getFontCss(\n    fontFamilies: string[],\n    style: FontCSSStyleOptions,\n    defaultOptions: {fontWeight: string, fontStyle: string}\n)\n{\n    const fontPromises = fontFamilies\n        .filter((fontFamily) => Cache.has(fontFamily))\n        .map((fontFamily, i) =>\n        {\n            if (!FontStylePromiseCache.has(fontFamily))\n            {\n                const { url } = Cache.get(fontFamily);\n\n                if (i === 0)\n                {\n                    FontStylePromiseCache.set(fontFamily, loadFontCSS(style, url));\n                }\n\n                else\n                {\n                    FontStylePromiseCache.set(fontFamily, loadFontCSS({\n                        fontWeight: defaultOptions.fontWeight,\n                        fontStyle: defaultOptions.fontStyle,\n                        fontFamily,\n                    }, url));\n                }\n            }\n\n            return FontStylePromiseCache.get(fontFamily);\n        });\n\n    return (await Promise.all(fontPromises)).join('\\n');\n}\n","import type { HTMLTextRenderData } from '../HTMLTextRenderData';\nimport type { HTMLTextStyle } from '../HtmlTextStyle';\n\n/**\n * takes all the data and returns a svg url string can be loaded by an image element\n * @param text - The text to measure\n * @param style - The style to use\n * @param resolution - The resolution to use\n * @param fontCSS - The font css to use\n * @param htmlTextData - The HTMLTextRenderData to write the SVG to\n * @returns - The SVG as a url string\n */\nexport function getSVGUrl(\n    text: string,\n    style: HTMLTextStyle,\n    resolution: number,\n    fontCSS: string,\n    htmlTextData: HTMLTextRenderData\n)\n{\n    const { domElement, styleElement, svgRoot } = htmlTextData;\n\n    domElement.innerHTML = `<style>${style.cssStyle}</style><div>${text}</div>`;\n    domElement.setAttribute('style', `transform: scale(${resolution});transform-origin: top left; display: inline-block`);\n    styleElement.textContent = fontCSS;\n\n    const { width, height } = htmlTextData.image;\n\n    svgRoot.setAttribute('width', width.toString());\n    svgRoot.setAttribute('height', height.toString());\n\n    return new XMLSerializer().serializeToString(svgRoot);\n}\n","import { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool';\n\n/**\n * This function converts an image to a canvas, and returns the canvas.\n * It is used to convert images to canvases to work around a CORS issue where WebGPU cannot\n * upload an SVGImage to a texture.\n *\n * It uses the CanvasPool to get an optimal canvas and context, and then draws the image onto it.\n * This canvas is immediately returned to the CanvasPool for reuse, so use the result straight away!\n * (eg upload it to the GPU!)\n * @param image - The image to convert to a canvas.\n * @param resolution - The resolution of the canvas.\n */\nexport function getTemporaryCanvasFromImage(image: HTMLImageElement, resolution: number): HTMLCanvasElement\n{\n    // Get an optimal canvas and context from the CanvasPool, based on the\n    // dimensions of the image and the desired resolution.\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(\n        image.width,\n        image.height,\n        resolution\n    );\n\n    // Clear the context of the canvas, and draw the image onto it.\n    const { context } = canvasAndContext;\n\n    context.clearRect(0, 0, image.width, image.height);\n    context.drawImage(image, 0, 0);\n\n    // Return the canvas and context to the CanvasPool.\n    CanvasPool.returnCanvasAndContext(canvasAndContext);\n\n    // Return the canvas.\n    return canvasAndContext.canvas as HTMLCanvasElement;\n}\n\n","/**\n * This function loads an SVG image into an HTMLImageElement.\n * The image can then be uploaded as texture to the GPU.\n * iOS has a bug where embedded fonts are not available immediately after the image loads,\n * so we wait an arbitrary amount of time before resolving the promise.\n * @param image - The image to load the SVG into\n * @param url - The url to load the SVG from\n * @param delay - Whether to delay the load\n * @returns - A promise that resolves when the image has loaded\n */\nexport function loadSVGImage(image: HTMLImageElement, url: string, delay: boolean)\n{\n    return new Promise<void>(async (resolve) =>\n    {\n        // Safari has a known bug where embedded fonts are not available\n        // immediately after the image loads, to compensate we wait an\n        // arbitrary amount of time\n        // @see https://bugs.webkit.org/show_bug.cgi?id=219770\n        if (delay)\n        {\n            await new Promise<void>((resolve) => setTimeout(resolve, 100));\n        }\n\n        image.onload = () =>\n        {\n            resolve();\n        };\n\n        image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;\n        image.crossOrigin = 'anonymous';\n    });\n}\n","import { CanvasTextMetrics } from '../../text/canvas/CanvasTextMetrics';\nimport { HTMLTextRenderData } from '../HTMLTextRenderData';\n\nimport type { Size } from '../../../maths/misc/Size';\nimport type { HTMLTextStyle } from '../HtmlTextStyle';\n\nlet tempHTMLTextRenderData: HTMLTextRenderData;\n\n/**\n * Measures the HTML text without actually generating an image.\n * This is used to calculate the size of the text.\n * @param text - The text to measure\n * @param style - The style to use\n * @param fontStyleCSS - The font css to use\n * @param htmlTextRenderData - The HTMLTextRenderData to write the SVG to\n * @returns - The size of the text\n */\nexport function measureHtmlText(\n    text: string,\n    style: HTMLTextStyle,\n    fontStyleCSS?: string,\n    htmlTextRenderData?: HTMLTextRenderData\n): Size\n{\n    htmlTextRenderData = htmlTextRenderData || tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData());\n\n    const { domElement, styleElement, svgRoot } = htmlTextRenderData;\n\n    domElement.innerHTML = `<style>${style.cssStyle}</style><div>${text}</div>`;\n\n    domElement.setAttribute('style', 'transform-origin: top left; display: inline-block');\n\n    if (fontStyleCSS)\n    {\n        styleElement.textContent = fontStyleCSS;\n    }\n\n    // Measure the contents using the shadow DOM\n    document.body.appendChild(svgRoot);\n\n    const contentBounds = domElement.getBoundingClientRect();\n\n    svgRoot.remove();\n\n    const descenderPadding = CanvasTextMetrics.measureFont(style.fontStyle).descent;\n\n    return {\n        width: contentBounds.width,\n        height: contentBounds.height + descenderPadding,\n    };\n}\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer, RendererType } from '../../rendering/renderers/types';\nimport { isSafari } from '../../utils/browser/isSafari';\nimport { warn } from '../../utils/logging/warn';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { getPo2TextureFromSource } from '../text/utils/getPo2TextureFromSource';\nimport { HTMLTextRenderData } from './HTMLTextRenderData';\nimport { HTMLTextStyle } from './HtmlTextStyle';\nimport { extractFontFamilies } from './utils/extractFontFamilies';\nimport { getFontCss } from './utils/getFontCss';\nimport { getSVGUrl } from './utils/getSVGUrl';\nimport { getTemporaryCanvasFromImage } from './utils/getTemporaryCanvasFromImage';\nimport { loadSVGImage } from './utils/loadSVGImage';\nimport { measureHtmlText } from './utils/measureHtmlText';\n\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { HTMLTextOptions } from './HTMLText';\nimport type { FontCSSStyleOptions } from './utils/loadFontCSS';\n\ninterface HTMLTextTexture\n{\n    texture: Texture,\n    usageCount: number,\n    promise: Promise<Texture>,\n}\n\n/**\n * System plugin to the renderer to manage HTMLText\n * @memberof rendering\n */\nexport class HTMLTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    public static defaultFontOptions: FontCSSStyleOptions = {\n        fontFamily: 'Arial',\n        fontStyle: 'normal',\n        fontWeight: 'normal',\n    };\n\n    private _activeTextures: Record<string, HTMLTextTexture> = {};\n\n    /**\n     * WebGPU has a cors issue when uploading an image that is an SVGImage\n     * To get around this we need to create a canvas draw the image to it and upload that instead.\n     * Bit of a shame.. but no other work around just yet!\n     */\n    private readonly _createCanvas: boolean;\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._createCanvas = renderer.type === RendererType.WEBGPU;\n    }\n\n    public getTexture(options: HTMLTextOptions): Promise<Texture>\n    {\n        return this._buildTexturePromise(\n            options.text as string,\n            options.resolution,\n            options.style as HTMLTextStyle\n        );\n    }\n\n    public getManagedTexture(\n        text: string,\n        resolution: number,\n        style: HTMLTextStyle,\n        textKey: string\n    ): Promise<Texture>\n    {\n        if (this._activeTextures[textKey])\n        {\n            this._increaseReferenceCount(textKey);\n\n            return this._activeTextures[textKey].promise;\n        }\n\n        const promise = this._buildTexturePromise(text, resolution, style)\n            .then((texture) =>\n            {\n                this._activeTextures[textKey].texture = texture;\n\n                return texture;\n            });\n\n        this._activeTextures[textKey] = {\n            texture: null,\n            promise,\n            usageCount: 1,\n        };\n\n        return promise;\n    }\n\n    private async _buildTexturePromise(\n        text: string,\n        resolution: number,\n        style: HTMLTextStyle,\n    )\n    {\n        const htmlTextData = BigPool.get(HTMLTextRenderData);\n        const fontFamilies = extractFontFamilies(text, style);\n        const fontCSS = await getFontCss(\n            fontFamilies,\n            style,\n            HTMLTextStyle.defaultTextStyle as {fontWeight: string, fontStyle: string}\n        );\n        const measured = measureHtmlText(text, style, fontCSS, htmlTextData);\n\n        const width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        const height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        const image = htmlTextData.image;\n\n        image.width = width | 0;\n        image.height = height | 0;\n\n        const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);\n\n        await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);\n\n        let resource: HTMLImageElement | HTMLCanvasElement = image;\n\n        if (this._createCanvas)\n        {\n            // silly webGPU workaround..\n            resource = getTemporaryCanvasFromImage(image, resolution);\n        }\n\n        const texture = getPo2TextureFromSource(resource, image.width, image.height, resolution);\n\n        if (this._createCanvas)\n        {\n            this._renderer.texture.initSource(texture.source);\n        }\n\n        BigPool.return(htmlTextData as PoolItem);\n\n        return texture;\n    }\n\n    private _increaseReferenceCount(textKey: string)\n    {\n        this._activeTextures[textKey].usageCount++;\n    }\n\n    public decreaseReferenceCount(textKey: string)\n    {\n        const activeTexture = this._activeTextures[textKey];\n\n        // TODO SHOULD NOT BE NEEDED\n        if (!activeTexture) return;\n\n        activeTexture.usageCount--;\n\n        if (activeTexture.usageCount === 0)\n        {\n            if (activeTexture.texture)\n            {\n                this._cleanUp(activeTexture);\n            }\n            else\n            {\n                // we did not resolve...\n                activeTexture.promise.then((texture) =>\n                {\n                    activeTexture.texture = texture;\n\n                    this._cleanUp(activeTexture);\n                }).catch(() =>\n                {\n                    // #if _DEBUG\n                    warn('HTMLTextSystem: Failed to clean texture');\n                    // #endif\n                });\n            }\n\n            this._activeTextures[textKey] = null;\n        }\n    }\n\n    private _cleanUp(activeTexture: HTMLTextTexture)\n    {\n        TexturePool.returnTexture(activeTexture.texture);\n        activeTexture.texture.source.resource = null;\n        activeTexture.texture.source.uploadMethodId = 'unknown';\n    }\n\n    public getReferenceCount(textKey: string)\n    {\n        return this._activeTextures[textKey].usageCount;\n    }\n\n    public destroy(): void\n    {\n        this._activeTextures = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { HTMLTextPipe } from './HTMLTextPipe';\nimport { HTMLTextSystem } from './HTMLTextSystem';\n\nextensions.add(HTMLTextSystem);\nextensions.add(HTMLTextPipe);\n","import { Color } from '../../../../color/Color';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { warn } from '../../../../utils/logging/warn';\nimport { FillGradient } from '../../../graphics/shared/fill/FillGradient';\nimport { FillPattern } from '../../../graphics/shared/fill/FillPattern';\n\nimport type { ICanvasRenderingContext2D } from '../../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { ConvertedFillStyle } from '../../../graphics/shared/GraphicsContext';\n\nexport function getCanvasFillStyle(\n    fillStyle: ConvertedFillStyle,\n    context: ICanvasRenderingContext2D): string | CanvasGradient | CanvasPattern\n{\n    if (fillStyle.texture === Texture.WHITE && !fillStyle.fill)\n    {\n        return Color.shared.setValue(fillStyle.color).toHex();\n    }\n    else if (!fillStyle.fill)\n    {\n        // fancy set up...\n        const pattern = context.createPattern(fillStyle.texture.source.resource, 'repeat');\n\n        // create an inverted scale matrix..\n        const tempMatrix = fillStyle.matrix.copyTo(Matrix.shared);\n\n        tempMatrix.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);\n\n        pattern.setTransform(tempMatrix);\n\n        return pattern;\n    }\n    else if (fillStyle.fill instanceof FillPattern)\n    {\n        const fillPattern = fillStyle.fill as FillPattern;\n\n        const pattern = context.createPattern(fillPattern.texture.source.resource, 'repeat');\n\n        const tempMatrix = fillPattern.transform.copyTo(Matrix.shared);\n\n        tempMatrix.scale(\n            fillPattern.texture.frame.width,\n            fillPattern.texture.frame.height\n        );\n\n        pattern.setTransform(tempMatrix);\n\n        return pattern;\n    }\n    else if (fillStyle.fill instanceof FillGradient)\n    {\n        const fillGradient = fillStyle.fill as FillGradient;\n\n        if (fillGradient.type === 'linear')\n        {\n            const gradient = context.createLinearGradient(\n                fillGradient.x0,\n                fillGradient.y0,\n                fillGradient.x1,\n                fillGradient.y1\n            );\n\n            fillGradient.gradientStops.forEach((stop) =>\n            {\n                gradient.addColorStop(stop.offset, Color.shared.setValue(stop.color).toHex());\n            });\n\n            return gradient;\n        }\n    }\n\n    // #if _DEBUG\n    warn('FillStyle not recognised', fillStyle);\n    // #endif\n\n    return 'red';\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { updateQuadBounds } from '../../../utils/data/updateQuadBounds';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { BatchableSprite } from '../../sprite/BatchableSprite';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { Text } from '../Text';\n\nexport class CanvasTextPipe implements RenderPipe<Text>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'text',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private _gpuText: Record<number, {\n        texture: Texture,\n        currentKey: string,\n        batchableSprite: BatchableSprite,\n    }> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(text: Text): boolean\n    {\n        const gpuText = this._getGpuText(text);\n\n        const newKey = text._getKey();\n\n        if (gpuText.currentKey !== newKey)\n        {\n            const resolution = text.resolution ?? this._renderer.resolution;\n\n            const { width, height } = this._renderer.canvasText.getTextureSize(\n                text.text,\n                resolution,\n                text._style,\n            );\n\n            if (\n                // is only being used by this text:\n                this._renderer.canvasText.getReferenceCount(gpuText.currentKey) === 1\n                // check the size of the text is the same po2\n                && width === gpuText.texture._source.width\n                && height === gpuText.texture._source.height\n            )\n            {\n                return false;\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(text: Text, _instructionSet: InstructionSet)\n    {\n        const gpuText = this._getGpuText(text);\n\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (text._didTextUpdate)\n        {\n            this._updateText(text);\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableSprite);\n    }\n\n    public updateRenderable(text: Text)\n    {\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (text._didTextUpdate)\n        {\n            this._updateText(text);\n        }\n\n        batchableSprite.batcher.updateElement(batchableSprite);\n    }\n\n    public destroyRenderable(text: Text)\n    {\n        this._destroyRenderableById(text.uid);\n    }\n\n    private _destroyRenderableById(textUid: number)\n    {\n        const gpuText = this._gpuText[textUid];\n\n        this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n\n        BigPool.return(gpuText.batchableSprite);\n\n        this._gpuText[textUid] = null;\n    }\n\n    private _updateText(text: Text)\n    {\n        const newKey = text._getKey();\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (gpuText.currentKey !== newKey)\n        {\n            this._updateGpuText(text);\n        }\n\n        text._didTextUpdate = false;\n\n        const padding = text._style.padding;\n\n        updateQuadBounds(batchableSprite.bounds, text._anchor, batchableSprite.texture, padding);\n    }\n\n    private _updateGpuText(text: Text)\n    {\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (gpuText.texture)\n        {\n            this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n        }\n\n        const resolution = text.resolution ?? this._renderer.resolution;\n\n        gpuText.texture = batchableSprite.texture = this._renderer.canvasText.getTexture(\n            text.text,\n            resolution,\n            text._style,\n            text._getKey()\n        );\n\n        gpuText.currentKey = text._getKey();\n        batchableSprite.texture = gpuText.texture;\n    }\n\n    private _getGpuText(text: Text)\n    {\n        return this._gpuText[text.uid] || this.initGpuText(text);\n    }\n\n    public initGpuText(text: Text)\n    {\n        const gpuTextData: CanvasTextPipe['_gpuText'][number] = {\n            texture: null,\n            currentKey: '--',\n            batchableSprite: BigPool.get(BatchableSprite),\n        };\n\n        gpuTextData.batchableSprite.renderable = text;\n        gpuTextData.batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        gpuTextData.batchableSprite.roundPixels = (this._renderer._roundPixels | text._roundPixels) as 0 | 1;\n\n        this._gpuText[text.uid] = gpuTextData;\n\n        this._updateText(text);\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        text.on('destroyed', () =>\n        {\n            this.destroyRenderable(text);\n        });\n\n        return gpuTextData;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuText)\n        {\n            this._destroyRenderableById(i as unknown as number);\n        }\n\n        this._gpuText = null;\n        this._renderer = null;\n    }\n}\n","import { Rectangle } from '../../maths/shapes/Rectangle';\n\nimport type { ICanvas } from '../../environment/canvas/ICanvas';\n\nfunction checkRow(data: Uint8ClampedArray, width: number, y: number)\n{\n    for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4)\n    {\n        if (data[index + 3] !== 0) return false;\n    }\n\n    return true;\n}\n\nfunction checkColumn(data: Uint8ClampedArray, width: number, x: number, top: number, bottom: number)\n{\n    const stride = 4 * width;\n\n    for (let y = top, index = (top * stride) + (4 * x); y <= bottom; ++y, index += stride)\n    {\n        if (data[index + 3] !== 0) return false;\n    }\n\n    return true;\n}\n\n/**\n * Measuring the bounds of a canvas' visible (non-transparent) pixels.\n * @param canvas - The canvas to measure.\n * @param resolution - The resolution of the canvas.\n * @returns The bounding box of the canvas' visible pixels.\n * @since 7.1.0\n * @memberof utils\n */\nexport function getCanvasBoundingBox(canvas: ICanvas, resolution = 1): Rectangle\n{\n    // https://gist.github.com/timdown/021d9c8f2aabc7092df564996f5afbbf\n\n    const { width, height } = canvas;\n\n    const context = canvas.getContext('2d', {\n        willReadFrequently: true,\n    });\n\n    if (context === null)\n    {\n        throw new TypeError('Failed to get canvas 2D context');\n    }\n\n    const imageData = context.getImageData(0, 0, width, height);\n    const data = imageData.data;\n\n    let left = 0;\n    let top = 0;\n    let right = width - 1;\n    let bottom = height - 1;\n\n    while (top < height && checkRow(data, width, top)) ++top;\n    if (top === height) return Rectangle.EMPTY;\n    while (checkRow(data, width, bottom)) --bottom;\n    while (checkColumn(data, width, left, top, bottom)) ++left;\n    while (checkColumn(data, width, right, top, bottom)) --right;\n\n    ++right;\n    ++bottom;\n\n    return new Rectangle(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);\n}\n","import { Color } from '../../../color/Color';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { nextPow2 } from '../../../maths/misc/pow2';\nimport { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool';\nimport { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { getCanvasBoundingBox } from '../../../utils/canvas/getCanvasBoundingBox';\nimport { getPo2TextureFromSource } from '../utils/getPo2TextureFromSource';\nimport { CanvasTextMetrics } from './CanvasTextMetrics';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle';\nimport { getCanvasFillStyle } from './utils/getCanvasFillStyle';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { System } from '../../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { TextStyle } from '../TextStyle';\n\ninterface CanvasAndContext\n{\n    canvas: ICanvas;\n    context: ICanvasRenderingContext2D;\n}\n\n/**\n * System plugin to the renderer to manage canvas text.\n * @memberof rendering\n */\nexport class CanvasTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'canvasText',\n    } as const;\n\n    private _activeTextures: Record<string, {\n        canvasAndContext: CanvasAndContext,\n        texture: Texture,\n        usageCount: number,\n    }> = {};\n\n    public getTextureSize(text: string, resolution: number, style: TextStyle): { width: number, height: number }\n    {\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);\n\n        let width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        let height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        width = Math.ceil((width) - 1e-6);\n        height = Math.ceil((height) - 1e-6);\n        width = nextPow2(width);\n        height = nextPow2(height);\n\n        return { width, height };\n    }\n\n    public getTexture(text: string, resolution: number, style: TextStyle, textKey: string)\n    {\n        if (this._activeTextures[textKey])\n        {\n            this._increaseReferenceCount(textKey);\n\n            return this._activeTextures[textKey].texture;\n        }\n\n        // create a canvas with the word hello on it\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);\n\n        const width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        const height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);\n\n        // create a texture from the canvas\n        const { canvas } = canvasAndContext;\n\n        this.renderTextToCanvas(text, style, resolution, canvasAndContext);\n\n        const texture = getPo2TextureFromSource(canvas, width, height, resolution);\n\n        if (style.trim)\n        {\n            const trimmed = getCanvasBoundingBox(canvas, resolution);\n\n            texture.frame.copyFrom(trimmed);\n\n            texture.updateUvs();\n        }\n\n        this._activeTextures[textKey] = {\n            canvasAndContext,\n            texture,\n            usageCount: 1,\n        };\n\n        return texture;\n    }\n\n    private _increaseReferenceCount(textKey: string)\n    {\n        this._activeTextures[textKey].usageCount++;\n    }\n\n    public decreaseReferenceCount(textKey: string)\n    {\n        const activeTexture = this._activeTextures[textKey];\n\n        activeTexture.usageCount--;\n\n        if (activeTexture.usageCount === 0)\n        {\n            CanvasPool.returnCanvasAndContext(activeTexture.canvasAndContext);\n            TexturePool.returnTexture(activeTexture.texture);\n\n            const source = activeTexture.texture.source;\n\n            source.resource = null;\n            source.uploadMethodId = 'unknown';\n            source.alphaMode = 'no-premultiply-alpha';\n\n            this._activeTextures[textKey] = null;\n        }\n    }\n\n    public getReferenceCount(textKey: string)\n    {\n        return this._activeTextures[textKey].usageCount;\n    }\n\n    /**\n     * Renders text to its canvas, and updates its texture.\n     *\n     * By default this is used internally to ensure the texture is correct before rendering,\n     * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,\n     * and then shared across multiple Sprites.\n     * @param text\n     * @param style\n     * @param resolution\n     * @param canvasAndContext\n     */\n    public renderTextToCanvas(text: string, style: TextStyle, resolution: number, canvasAndContext: CanvasAndContext): void\n    {\n        const { canvas, context } = canvasAndContext;\n\n        const font = fontStringFromTextStyle(style);\n\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);// , canvas);\n        const lines = measured.lines;\n        const lineHeight = measured.lineHeight;\n        const lineWidths = measured.lineWidths;\n        const maxLineWidth = measured.maxLineWidth;\n        const fontProperties = measured.fontProperties;\n\n        const height = canvas.height;\n\n        context.resetTransform();\n\n        context.scale(resolution, resolution);\n\n        context.clearRect(0, 0, measured.width + 4, measured.height + 4);\n\n        // set stroke styles..\n\n        if (style._stroke?.width)\n        {\n            const strokeStyle = style._stroke;\n\n            context.lineWidth = strokeStyle.width;\n\n            context.miterLimit = strokeStyle.miterLimit;\n            context.lineJoin = strokeStyle.join;\n            context.lineCap = strokeStyle.cap;\n        }\n\n        // return;\n        context.font = font;\n\n        let linePositionX: number;\n        let linePositionY: number;\n\n        // require 2 passes if a shadow; the first to draw the drop shadow, the second to draw the text\n        const passesCount = style.dropShadow ? 2 : 1;\n\n        // For v4, we drew text at the colours of the drop shadow underneath the normal text. This gave the correct zIndex,\n        // but features such as alpha and shadowblur did not look right at all, since we were using actual text as a shadow.\n        //\n        // For v5.0.0, we moved over to just use the canvas API for drop shadows, which made them look much nicer and more\n        // visually please, but now because the stroke is drawn and then the fill, drop shadows would appear on both the fill\n        // and the stroke; and fill drop shadows would appear over the top of the stroke.\n        //\n        // For v5.1.1, the new route is to revert to v4 style of drawing text first to get the drop shadows underneath normal\n        // text, but instead drawing text in the correct location, we'll draw it off screen (-paddingY), and then adjust the\n        // drop shadow so only that appears on screen (+paddingY). Now we'll have the correct draw order of the shadow\n        // beneath the text, whilst also having the proper text shadow styling.\n        for (let i = 0; i < passesCount; ++i)\n        {\n            const isShadowPass = style.dropShadow && i === 0;\n            // we only want the drop shadow, so put text way off-screen\n            const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + (style.padding * 2)) : 0;\n            const dsOffsetShadow = dsOffsetText * resolution;\n\n            if (isShadowPass)\n            {\n                // On Safari, text with gradient and drop shadows together do not position correctly\n                // if the scale of the canvas is not 1: https://bugs.webkit.org/show_bug.cgi?id=197689\n                // Therefore we'll set the styles to be a plain black whilst generating this drop shadow\n                context.fillStyle = 'black';\n                context.strokeStyle = 'black';\n\n                const shadowOptions = style.dropShadow;\n\n                const dropShadowColor = shadowOptions.color;\n                const dropShadowAlpha = shadowOptions.alpha;\n\n                context.shadowColor = Color.shared\n                    .setValue(dropShadowColor)\n                    .setAlpha(dropShadowAlpha)\n                    .toRgbaString();\n\n                const dropShadowBlur = shadowOptions.blur * resolution;\n                const dropShadowDistance = shadowOptions.distance * resolution;\n\n                context.shadowBlur = dropShadowBlur;\n                context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n                context.shadowOffsetY = (Math.sin(shadowOptions.angle) * dropShadowDistance) + dsOffsetShadow;\n            }\n            else\n            {\n                context.globalAlpha = style._fill?.alpha ?? 1;\n                context.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context) : null;\n\n                if (style._stroke?.width)\n                {\n                    context.strokeStyle = getCanvasFillStyle(style._stroke, context);\n                }\n\n                context.shadowColor = 'black';\n            }\n\n            let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n\n            if (lineHeight - fontProperties.fontSize < 0)\n            {\n                linePositionYShift = 0;\n            }\n\n            const strokeWidth = style._stroke?.width ?? 0;\n\n            // draw lines line by line\n            for (let i = 0; i < lines.length; i++)\n            {\n                linePositionX = strokeWidth / 2;\n                linePositionY = ((strokeWidth / 2) + (i * lineHeight)) + fontProperties.ascent + linePositionYShift;\n\n                if (style.align === 'right')\n                {\n                    linePositionX += maxLineWidth - lineWidths[i];\n                }\n                else if (style.align === 'center')\n                {\n                    linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n                }\n\n                if (style._stroke)\n                {\n                    this._drawLetterSpacing(\n                        lines[i],\n                        style,\n                        canvasAndContext,\n                        linePositionX + style.padding,\n                        linePositionY + style.padding - dsOffsetText,\n                        true\n                    );\n                }\n\n                if (style._fill !== undefined)\n                {\n                    this._drawLetterSpacing(\n                        lines[i],\n                        style,\n                        canvasAndContext,\n                        linePositionX + style.padding,\n                        linePositionY + style.padding - dsOffsetText\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Render the text with letter-spacing.\n     * @param text - The text to draw\n     * @param style\n     * @param canvasAndContext\n     * @param x - Horizontal position to draw the text\n     * @param y - Vertical position to draw the text\n     * @param isStroke - Is this drawing for the outside stroke of the\n     *  text? If not, it's for the inside fill\n     */\n    private _drawLetterSpacing(\n        text: string,\n        style: TextStyle,\n        canvasAndContext: CanvasAndContext,\n        x: number, y: number,\n        isStroke = false\n    ): void\n    {\n        const { context } = canvasAndContext;\n\n        // letterSpacing of 0 means normal\n        const letterSpacing = style.letterSpacing;\n\n        let useExperimentalLetterSpacing = false;\n\n        if (CanvasTextMetrics.experimentalLetterSpacingSupported)\n        {\n            if (CanvasTextMetrics.experimentalLetterSpacing)\n            {\n                context.letterSpacing = `${letterSpacing}px`;\n                context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            }\n            else\n            {\n                context.letterSpacing = '0px';\n                context.textLetterSpacing = '0px';\n            }\n        }\n\n        if (letterSpacing === 0 || useExperimentalLetterSpacing)\n        {\n            if (isStroke)\n            {\n                context.strokeText(text, x, y);\n            }\n            else\n            {\n                context.fillText(text, x, y);\n            }\n\n            return;\n        }\n\n        let currentPosition = x;\n\n        const stringArray = CanvasTextMetrics.graphemeSegmenter(text);\n        let previousWidth = context.measureText(text).width;\n        let currentWidth = 0;\n\n        for (let i = 0; i < stringArray.length; ++i)\n        {\n            const currentChar = stringArray[i];\n\n            if (isStroke)\n            {\n                context.strokeText(currentChar, currentPosition, y);\n            }\n            else\n            {\n                context.fillText(currentChar, currentPosition, y);\n            }\n            let textStr = '';\n\n            for (let j = i + 1; j < stringArray.length; ++j)\n            {\n                textStr += stringArray[j];\n            }\n            currentWidth = context.measureText(textStr).width;\n            currentPosition += previousWidth - currentWidth + letterSpacing;\n            previousWidth = currentWidth;\n        }\n    }\n\n    public destroy(): void\n    {\n        this._activeTextures = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { CanvasTextPipe } from './canvas/CanvasTextPipe';\nimport { CanvasTextSystem } from './canvas/CanvasTextSystem';\n\nextensions.add(CanvasTextSystem);\nextensions.add(CanvasTextPipe);\n","import { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { Bounds } from '../../container/bounds/Bounds';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\n\nconst tempBounds = new Bounds();\n\n/**\n * Takes an image and creates a texture from it, using a power of 2 texture from the texture pool.\n * Remember to return the texture when you don't need it any more!\n * @param image - The image to create a texture from\n * @param width - the frame width of the texture\n * @param height - the frame height of the texture\n * @param resolution - The resolution of the texture\n * @returns - The texture\n */\nexport function getPo2TextureFromSource(\n    image: HTMLImageElement | HTMLCanvasElement | ICanvas,\n    width: number,\n    height: number,\n    resolution: number\n): Texture\n{\n    const bounds = tempBounds;\n\n    bounds.minX = 0;\n    bounds.minY = 0;\n\n    bounds.maxX = (image.width / resolution) | 0;\n    bounds.maxY = (image.height / resolution) | 0;\n\n    const texture = TexturePool.getOptimalTexture(\n        bounds.width,\n        bounds.height,\n        resolution,\n        false\n    );\n\n    texture.source.uploadMethodId = 'image';\n    texture.source.resource = image;\n    texture.source.alphaMode = 'premultiply-alpha-on-upload';\n\n    texture.frame.width = width / resolution;\n    texture.frame.height = height / resolution;\n\n    // We want to update the resource on the GPU,\n    // but we do not want to resize the texture.\n    // calling `texture.source.update` will fit the resource to the texture\n    // causing a resize of the texture on the GPU.\n    // which is not what we want!\n    texture.source.emit('update', texture.source);\n\n    texture.updateUvs();\n\n    return texture;\n}\n"],"names":["ResizePlugin","init","options","Object","defineProperty","this","set","dom","globalThis","removeEventListener","queueResize","_resizeTo","addEventListener","resize","get","_cancelResize","_resizeId","requestAnimationFrame","cancelAnimationFrame","width","height","window","innerWidth","innerHeight","clientWidth","clientHeight","renderer","render","resizeTo","destroy","extension","ExtensionType","Application","TickerPlugin","assign","autoStart","sharedTicker","ticker","_ticker","remove","add","UPDATE_PRIORITY","LOW","stop","start","Ticker","shared","oldTicker","extensions","FilterPipe","constructor","_renderer","push","filterEffect","container","instructionSet","renderPipes","batch","break","renderPipeId","canBundle","action","pop","_filterEffect","_container","execute","instruction","filter","type","WebGLPipes","WebGPUPipes","CanvasPipes","name","tempMatrix","Matrix","getFastGlobalBounds","target","bounds","clear","_getGlobalBoundsRecursive","isValid","isRenderGroupRoot","applyMatrix","renderGroup","localTransform","worldTransform","localDisplayStatus","measurable","manageEffects","effects","length","localBounds","boundsPool","boundsArea","addRect","viewBounds","addFrame","minX","minY","maxX","maxY","groupTransform","children","i","advanced","addBounds","copyTo","invert","relativeGroupTransform","return","getGlobalRenderableBounds","renderables","matrix","renderable","globalDisplayStatus","quadGeometry","Geometry","attributes","aPosition","buffer","Float32Array","location","format","stride","offset","indexBuffer","Uint32Array","FilterSystem","_filterStackIndex","_filterStack","_filterGlobalUniforms","UniformGroup","uInputSize","value","uInputPixel","uInputClamp","uOutputFrame","uGlobalFrame","uOutputTexture","_globalFilterBindGroup","BindGroup","activeBackTexture","_activeFilterData","backTexture","filters","_getFilterData","filterData","skip","filterArea","colorTextureSource","renderTarget","rootRenderTarget","colorTexture","source","resolution","_resolution","padding","antialias","blendRequired","enabled","Math","min","isCompatible","compatibleRenderers","backBuffer","useBackBuffer","warn","scale","fit","rootViewPort","pad","ceil","isPositive","previousRenderSurface","renderSurface","inputTexture","TexturePool","getOptimalTexture","bind","globalUniforms","Texture","EMPTY","finishRenderPass","previousBounds","getRenderTarget","getBackTexture","setResource","style","apply","returnTexture","flip","flop","t","lastRenderSurface","backgroundResolution","x","y","floor","copyToTexture","applyFilter","input","output","Point","isFinalTarget","currentIndex","filterUniforms","uniforms","outputFrame","inputSize","inputPixel","inputClamp","globalFrame","outputTexture","lastIndex","filterData2","frame","pixelWidth","pixelHeight","rootTexture","isRoot","update","uniformBatch","batchUniforms","getUboResource","groups","encoder","draw","geometry","shader","state","_state","topology","RendererType","WEBGL","Bounds","calculateSpriteMatrix","outputMatrix","sprite","data","mappedMatrix","_source","prepend","texture","translate","anchor","WebGLSystem","WebGPUSystem","sampleValues","Int32Array","MAX_TEXTURES","batchSamplersUniformGroup","uTextures","size","isStatic","CanvasPoolClass","canvasOptions","_canvasPool","create","enableFullScreen","_createCanvasAndContext","canvas","DOMAdapter","createCanvas","context","getContext","getOptimalCanvasAndContext","minWidth","minHeight","nextPow2","key","canvasAndContext","returnCanvasAndContext","CanvasPool","GraphicsPipe","adaptor","State","for2d","_graphicsBatchesHash","_adaptor","validateRenderable","graphics","wasBatched","uid","gpuContext","graphicsContext","updateGpuContext","isBatchable","addRenderable","_didGraphicsUpdate","_rebuild","_addToBatcher","updateRenderable","batches","batcher","updateElement","destroyRenderable","_removeBatchForRenderable","isRenderable","contextSystem","getGpuContext","customShader","blendMode","groupBlendMode","localUniforms","resources","uTransformMatrix","uRound","_roundPixels","color32BitToUniform","groupColorAlpha","uColor","_initBatchesForRenderable","batched","batchPipe","_getBatchesForRenderable","addToBatch","roundPixels","map","batchClone","BigPool","BatchableGraphics","on","graphicsUid","forEach","GraphicsContextSystem","MeshPipe","localUniformsBindGroup","_meshDataHash","_gpuBatchableMeshHash","mesh","meshData","_getMeshData","isBatched","_geometry","indices","indexSize","positions","vertexSize","batchableMesh","_getBatchableMesh","checkAndUpdateTexture","gpuBatchableMesh","_texture","gpuMesh","_initMeshData","_initBatchableMesh","BatchableMesh","_uvMatrix","reset","packIndex","index","indicesOffset","packAttributes","float32View","uint32View","textureId","wt","textureIdAndRound","a","b","c","d","tx","ty","uvs","transformedUvs","textureMatrix","isSimple","_transformedUvs","mapCoord","equals","copyFrom","multiplyUvs","abgr","_MeshGeometry","args","deprecation","v8_0_0","defaultOptions","shrinkToFit","shrinkBuffersToFit","positionBuffer","Buffer","label","usage","BufferUsage","VERTEX","COPY_DST","uvBuffer","INDEX","aUV","batchMode","MeshGeometry","_PlaneGeometry","super","verticesX","verticesY","build","total","verts","sizeX","sizeY","totalSub","xpos","ypos","value2","value3","value4","buffers","PlaneGeometry","_NineSliceGeometry","_textureMatrix","_originalWidth","originalWidth","_originalHeight","originalHeight","_leftWidth","leftWidth","_rightWidth","rightWidth","_topHeight","topHeight","_bottomHeight","bottomHeight","updateUvs","updatePositions","w","scaleW","h","scaleH","getBuffer","_uvw","_uvh","NineSliceGeometry","out","NineSliceSpritePipe","_gpuSpriteHash","_instructionSet","gpuSprite","_getGpuSprite","_didSpriteUpdate","_updateBatchableSprite","batchableSprite","_initGPUSprite","tilingBit","vertex","header","main","fragment","tilingBitGl","gpuProgram","glProgram","TilingSpriteShader","Shader","compileHighShaderGpuProgram","bits","localUniformBit","roundPixelsBit","compileHighShaderGlProgram","localUniformBitGl","roundPixelsBitGl","tilingUniforms","uMapCoord","uClampFrame","uClampOffset","uTextureTransform","uSizeAnchor","uTexture","uSampler","updateUniforms","anchorX","anchorY","textureWidth","textureHeight","QuadGeometry","setPositions","tilingSprite","array","setUvs","_applyAnchorToTexture","_tileTransform","sharedQuad","TilingSpritePipe","_tilingSpriteDataHash","tilingSpriteData","_getTilingSpriteData","couldBatch","canBatch","_updateCanBatch","_didTilingSpriteUpdate","_updateBatchableMesh","bindGroup","default2d","_initTilingSpriteData","slice","renderableData","addressMode","_nonPowOf2wrapping","supports","nonPowOf2wrapping","isPowerOfTwo","AbstractBitmapFont","EventEmitter","arguments","chars","lineHeight","fontFamily","fontMetrics","fontSize","ascent","descent","baseLineOffset","distanceField","range","pages","baseMeasurementFontSize","baseRenderedFontSize","font","pageTextures","distanceFieldRange","distanceFieldType","destroyTextures","emit","removeAllListeners","page","resolveCharacters","result","j","item","Array","isArray","Error","startCode","charCodeAt","endCode","i2","j2","String","fromCharCode","from","DynamicBitmapFont","_padding","_measureCache","_currentChars","_currentX","_currentY","_currentPageIndex","_skipKerning","dynamicOptions","clone","overrideFill","_fill","color","alpha","WHITE","fill","requestedFontSize","fontStringFromTextStyle","overrideSize","_stroke","_style","skipKerning","CanvasTextMetrics","measureFont","ensureCharacters","charList","char","includes","self","indexOf","pageData","_nextPage","textureSource","currentX","currentY","fontScale","widthScale","fontStyle","maxCharHeight","skipTexture","metrics","measureText","paddedWidth","paddedHeight","max","pageData2","xAdvance","dropShadow","distance","id","codePointAt","xOffset","yOffset","kerning","_drawGlyph","px","py","Rectangle","_applyKerning","newChars","measureCache","first","second","c1","c2","amount","textureResolution","_setupContext","ImageSource","resource","alphaMode","textBaseline","stroke","strokeThickness","lineWidth","lineJoin","join","miterLimit","strokeStyle","getCanvasFillStyle","fillStyle","shadowOptions","rgb","Color","setValue","toArray","dropShadowBlur","blur","dropShadowDistance","shadowColor","shadowBlur","shadowOffsetX","cos","angle","shadowOffsetY","sin","text","fontProperties","strokeText","fillText","getBitmapTextLayout","layoutData","offsetY","lines","charPositions","spaceWidth","spacesIndex","currentLine","previousChar","firstWord","currentWord","spaceWord","nextWord","word","position","nextLine","lastChar","adjustedLetterSpacing","letterSpacing","adjustedWordWrapWidth","wordWrapWidth","isEnd","charData","isSpace","test","isWordBreak","addWordToNextLine","wordWrap","nextCharWidth","align","alignCenter","alignRight","alignJustify","measurementData","line","indy","spaceIndex","totalSpaces","newSpaceWidth","BitmapFontManagerClass","ALPHA","NUMERIC","ALPHANUMERIC","ASCII","getFont","fontFamilyKey","Cache","has","fnt","once","dynamicFont","getLayout","bitmapFont","split","install","textStyle","TextStyle","flatChars","uninstall","cacheKey","BitmapFontManager","BitmapFont","url","textures","keys","parseInt","frameReal","bitmapFontTextParser","startsWith","parse","txt","items","match","rawData","info","common","kernings","attributeList","itemData","strValue","replace","floatValue","parseFloat","isNaN","distanceRange","fieldType","face","file","base","charNode","letter","xoffset","yoffset","xadvance","bitmapFontXMLParser","xml","getElementsByTagName","getAttribute","bitmapFontXMLStringParser","parseXML","validExtensions","bitmapFontCachePlugin","CacheParser","asset","getCacheableAssets","loadBitmapFont","LoadParser","priority","LoaderParserPriority","Normal","path","extname","toLowerCase","testParse","loader","bitmapFontData","src","textureUrls","pageFile","imagePath","dirname","copySearchParams","loadedTextures","load","_options","response","fetch","unload","_resolvedAsset","Promise","all","_sourceOrigin","Graphics","Container","GraphicsContext","rest","_context","_ownedContext","onViewUpdate","allowChildren","off","containsPoint","point","_didChangeId","didViewUpdate","onChildViewUpdate","_callContextMethod","method","setFillStyle","setStrokeStyle","beginPath","cut","arc","arcTo","arcToSvg","bezierCurveTo","closePath","ellipse","circle","lineTo","moveTo","quadraticCurveTo","rect","roundRect","poly","regularPoly","roundPoly","roundShape","filletRect","chamferRect","star","svg","restore","save","getTransform","resetTransform","rotateTransform","scaleTransform","setTransform","transform","translateTransform","deep","lineStyle","beginFill","endFill","defaultStrokeStyle","drawCircle","drawEllipse","drawPolygon","drawRect","drawRoundedRect","drawStar","localUniformMSDFBit","end","localUniformMSDFBitGl","mSDFBit","mSDFBitGl","SdfShader","uDistance","colorBit","generateTextureBatchBit","colorBitGl","generateTextureBatchBitGl","batchSamplers","BitmapTextPipe","_gpuBitmapText","bitmapText","graphicsRenderable","_getGpuBitmapText","_didTextUpdate","_updateContext","syncWithProxy","_updateDistanceField","_destroyRenderableByUid","renderableUid","proxyGraphics","_sdfShader","bitmapTextLayout","_anchor","_x","_y","tint","round","initGpuText","proxyRenderable","dx","sqrt","dy","worldScale","abs","proxy","groupColor","groupAlpha","HTMLTextPipe","_gpuText","htmlText","gpuText","_getGpuText","newKey","_getKey","textureNeedsUploading","currentKey","_updateText","_destroyRenderableById","htmlTextUid","decreaseReferenceCount","_updateGpuText","catch","e","console","error","updateQuadBounds","generatingTexture","getManagedTexture","gpuTextData","BatchableSprite","isSafari","userAgent","getNavigator","nssvg","nsxhtml","HTMLTextRenderData","svgRoot","document","createElementNS","foreignObject","domElement","styleElement","image","Image","setAttribute","overflow","appendChild","textStyleToCSS","cssStyleString","toHex","fontWeight","fontVariant","whiteSpace","breakWords","strokeToCSS","dropShadowToCSS","cssOverrides","cssStyles","tagStyleToCSS","tagStyles","dropShadowStyle","setAlpha","toHexa","templates","tagStyle","cssTagStyle","HTMLTextStyle","_cssOverrides","_generateKey","_styleKey","generateTextStyleKey","_cssStyle","cssStyle","addOverride","toAdd","v","removeOverride","toRemove","extractFontFamilies","fontFamilies","dedupe","regex","matches","addFontFamily","fontFamily2","trim","loadFontAsBase64","blob","reader","FileReader","dataSrc","resolve","reject","onloadend","onerror","readAsDataURL","loadFontCSS","FontStylePromiseCache","Map","getFontCss","fontPromises","getSVGUrl","fontCSS","htmlTextData","innerHTML","textContent","toString","XMLSerializer","serializeToString","getTemporaryCanvasFromImage","clearRect","drawImage","loadSVGImage","delay","async","resolve2","setTimeout","onload","encodeURIComponent","crossOrigin","tempHTMLTextRenderData","measureHtmlText","fontStyleCSS","htmlTextRenderData","body","contentBounds","getBoundingClientRect","descenderPadding","HTMLTextSystem","_activeTextures","_createCanvas","WEBGPU","getTexture","_buildTexturePromise","textKey","_increaseReferenceCount","promise","then","usageCount","defaultTextStyle","measured","svgURL","getPo2TextureFromSource","initSource","activeTexture","_cleanUp","uploadMethodId","getReferenceCount","CanvasSystem","defaultFontOptions","pattern","createPattern","FillPattern","fillPattern","FillGradient","fillGradient","gradient","createLinearGradient","x0","y0","x1","y1","gradientStops","addColorStop","CanvasTextPipe","canvasText","getTextureSize","textUid","checkRow","checkColumn","top","bottom","getCanvasBoundingBox","willReadFrequently","TypeError","imageData","getImageData","left","right","CanvasTextSystem","renderTextToCanvas","trimmed","lineWidths","maxLineWidth","lineCap","cap","linePositionX","linePositionY","passesCount","isShadowPass","dsOffsetText","dsOffsetShadow","dropShadowColor","dropShadowAlpha","toRgbaString","globalAlpha","linePositionYShift","strokeWidth","_drawLetterSpacing","isStroke","useExperimentalLetterSpacing","experimentalLetterSpacingSupported","experimentalLetterSpacing","textLetterSpacing","currentPosition","stringArray","graphemeSegmenter","previousWidth","currentWidth","currentChar","textStr","tempBounds"],"sourceRoot":""}